###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.60.1.5097/W32 for ARM      31/Oct/2014  21:00:49 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\FredZhou\Documents\Origin\Projects\platform\STM #
#                    32L1XX\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1x #
#                    x_tim.c                                                  #
#    Command line =  C:\Users\FredZhou\Documents\Origin\Projects\platform\STM #
#                    32L1XX\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1x #
#                    x_tim.c -D USE_STDPERIPH_DRIVER -D STM32L1XX_MD -D       #
#                    SYSCLK_FREQ_HSI_32MHz -D ENABLE_USB -D                   #
#                    ENABLE_USB_PRINTF -D DEBUG -D SERVER -D ACCEL_TEST -lcN  #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Server\List\ --diag_suppress Pa050 -o         #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Server\Obj\ --debug --endian=little           #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.5\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\inc\ -I "C:\Users\FredZhou\Documents\Origi #
#                    n\Projects\Project\BLE_Chat\EWARM\..\..\..\Bluetooth     #
#                    LE\SimpleBlueNRG_HCI\" -I "C:\Users\FredZhou\Documents\O #
#                    rigin\Projects\Project\BLE_Chat\EWARM\..\..\..\Bluetooth #
#                     LE\SimpleBlueNRG_HCI\includes\" -I                      #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\ -I               #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\ -I     #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\CMSIS\C #
#                    M3\DeviceSupport\ST\STM32L1xx\ -I                        #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32_U #
#                    SB-FS-Device_Driver\inc\ -I                              #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32L1 #
#                    xx_StdPeriph_Driver\inc\ -I                              #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\I2C\inc #
#                    \ -I C:\Users\FredZhou\Documents\Origin\Projects\Project #
#                    \BLE_Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\LI #
#                    S3DH\inc\ -I C:\Users\FredZhou\Documents\Origin\Projects #
#                    \Project\BLE_Chat\EWARM\..\..\..\platform\STM32L1XX\Libr #
#                    aries\STLM75\inc\ -I C:\Users\FredZhou\Documents\Origin\ #
#                    Projects\Project\BLE_Chat\EWARM\..\..\..\platform\STM32L #
#                    1XX\Libraries\HTS221\inc\ -I                             #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\LPS25H\ #
#                    inc\ -I C:\Users\FredZhou\Documents\Origin\Projects\Proj #
#                    ect\BLE_Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries #
#                    \SDK_Eval_STM32L\inc\ -Ohs --use_c++_inline -I           #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Server\List\stm32l1xx_tim.lst                 #
#    Object file  =  C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Server\Obj\stm32l1xx_tim.o                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\FredZhou\Documents\Origin\Projects\platform\STM32L1XX\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_tim.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    31-January-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the TIM peripheral:
      9            *            + TimeBase management
     10            *            + Output Compare management
     11            *            + Input Capture management
     12            *            + Interrupts, DMA and flags management
     13            *            + Clocks management
     14            *            + Synchronization management
     15            *            + Specific interface management
     16            *            + Specific remapping management      
     17            *              
     18          *  @verbatim
     19            
     20           ===============================================================================
     21                              ##### How to use this driver #####
     22           ===============================================================================
     23              [..] This driver provides functions to configure and program the TIM 
     24                   of all STM32L1xx devices These functions are split in 8 groups: 
     25                   (#) TIM TimeBase management: this group includes all needed functions 
     26                       to configure the TM Timebase unit:
     27                       (++) Set/Get Prescaler.
     28                       (++) Set/Get Autoreload.
     29                       (++) Counter modes configuration.
     30                       (++) Set Clock division.
     31                       (++) Select the One Pulse mode.
     32                       (++) Update Request Configuration.
     33                       (++) Update Disable Configuration.
     34                       (++) Auto-Preload Configuration.
     35                       (++) Enable/Disable the counter.
     36            
     37                   (#) TIM Output Compare management: this group includes all needed 
     38                       functions to configure the Capture/Compare unit used in Output 
     39                       compare mode: 
     40                       (++) Configure each channel, independently, in Output Compare mode.
     41                       (++) Select the output compare modes.
     42                       (++) Select the Polarities of each channel.
     43                       (++) Set/Get the Capture/Compare register values.
     44                       (++) Select the Output Compare Fast mode. 
     45                       (++) Select the Output Compare Forced mode.  
     46                       (++) Output Compare-Preload Configuration. 
     47                       (++) Clear Output Compare Reference.
     48                       (++) Select the OCREF Clear signal.
     49                       (++) Enable/Disable the Capture/Compare Channels.    
     50            
     51                   (#) TIM Input Capture management: this group includes all needed 
     52                       functions to configure the Capture/Compare unit used in 
     53                       Input Capture mode:
     54                       (++) Configure each channel in input capture mode.
     55                       (++) Configure Channel1/2 in PWM Input mode.
     56                       (++) Set the Input Capture Prescaler.
     57                       (++) Get the Capture/Compare values.      
     58            
     59                   (#) TIM interrupts, DMA and flags management.
     60                       (++) Enable/Disable interrupt sources.
     61                       (++) Get flags status.
     62                       (++) Clear flags/ Pending bits.
     63                       (++) Enable/Disable DMA requests. 
     64                       (++) Configure DMA burst mode.
     65                       (++) Select CaptureCompare DMA request.  
     66            
     67                   (#) TIM clocks management: this group includes all needed functions 
     68                       to configure the clock controller unit:
     69                       (++) Select internal/External clock.
     70                       (++) Select the external clock mode: ETR(Mode1/Mode2), TIx or ITRx.
     71            
     72                   (#) TIM synchronization management: this group includes all needed. 
     73                       functions to configure the Synchronization unit:
     74                       (++) Select Input Trigger.  
     75                       (++) Select Output Trigger.  
     76                       (++) Select Master Slave Mode. 
     77                       (++) ETR Configuration when used as external trigger.   
     78            
     79                   (#) TIM specific interface management, this group includes all 
     80                       needed functions to use the specific TIM interface:
     81                       (++) Encoder Interface Configuration.
     82                       (++) Select Hall Sensor.   
     83            
     84                   (#) TIM specific remapping management includes the Remapping 
     85                       configuration of specific timers
     86            
     87          @endverbatim
     88            
     89            ******************************************************************************
     90            * @attention
     91            *
     92            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     93            *
     94            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     95            * You may not use this file except in compliance with the License.
     96            * You may obtain a copy of the License at:
     97            *
     98            *        http://www.st.com/software_license_agreement_liberty_v2
     99            *
    100            * Unless required by applicable law or agreed to in writing, software 
    101            * distributed under the License is distributed on an "AS IS" BASIS, 
    102            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    103            * See the License for the specific language governing permissions and
    104            * limitations under the License.
    105            *
    106            ******************************************************************************
    107            */
    108          
    109          /* Includes ------------------------------------------------------------------*/
    110          #include "stm32l1xx_tim.h"
    111          #include "stm32l1xx_rcc.h"
    112          
    113          /** @addtogroup STM32L1xx_StdPeriph_Driver
    114            * @{
    115            */
    116          
    117          /** @defgroup TIM 
    118            * @brief TIM driver modules
    119            * @{
    120            */
    121          
    122          /* Private typedef -----------------------------------------------------------*/
    123          /* Private define ------------------------------------------------------------*/
    124          
    125          /* ---------------------- TIM registers bit mask ------------------------ */
    126          #define SMCR_ETR_MASK               ((uint16_t)0x00FF) 
    127          #define CCMR_OFFSET                 ((uint16_t)0x0018)
    128          #define CCER_CCE_SET                ((uint16_t)0x0001)  
    129            
    130          /* Private macro -------------------------------------------------------------*/
    131          /* Private variables ---------------------------------------------------------*/
    132          /* Private function prototypes -----------------------------------------------*/
    133          
    134          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    135                                 uint16_t TIM_ICFilter);
    136          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    137                                 uint16_t TIM_ICFilter);
    138          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    139                                 uint16_t TIM_ICFilter);
    140          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    141                                 uint16_t TIM_ICFilter);
    142          /* Private functions ---------------------------------------------------------*/
    143          
    144          /** @defgroup TIM_Private_Functions
    145            * @{
    146            */
    147          
    148          /** @defgroup TIM_Group1 TimeBase management functions
    149           *  @brief   TimeBase management functions 
    150           *
    151          @verbatim
    152           ===============================================================================
    153                           ##### TimeBase management functions #####
    154           ===============================================================================
    155            
    156                  *** TIM Driver: how to use it in Timing(Time base) Mode ***
    157           ===============================================================================
    158              [..] To use the Timer in Timing(Time base) mode, the following steps are 
    159                   mandatory:
    160                   (#) Enable TIM clock using 
    161                       RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function.
    162                   (#) Fill the TIM_TimeBaseInitStruct with the desired parameters.
    163                   (#) Call TIM_TimeBaseInit(TIMx, &TIM_TimeBaseInitStruct) to configure 
    164                       the Time Base unit with the corresponding configuration.
    165                   (#) Enable the NVIC if you need to generate the update interrupt. 
    166                   (#) Enable the corresponding interrupt using the function 
    167                       TIM_ITConfig(TIMx, TIM_IT_Update). 
    168                   (#) Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
    169              [..]
    170                  (@) All other functions can be used seperatly to modify, if needed,
    171                      a specific feature of the Timer. 
    172          
    173          @endverbatim
    174            * @{
    175            */
    176          
    177          /**
    178            * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
    179            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    180            * @retval None
    181            *   
    182            */
    183          void TIM_DeInit(TIM_TypeDef* TIMx)
    184          {
    185            /* Check the parameters */
    186            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    187             
    188            if (TIMx == TIM2)
    189            {
    190              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
    191              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
    192            }
    193            else if (TIMx == TIM3)
    194            {
    195              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
    196              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
    197            }
    198            else if (TIMx == TIM4)
    199            {
    200              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
    201              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
    202            } 
    203            else if (TIMx == TIM5)
    204            {
    205              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
    206              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
    207            } 
    208            else if (TIMx == TIM6)
    209            {
    210              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
    211              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
    212            } 
    213            else if (TIMx == TIM7)
    214            {
    215              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
    216              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
    217            } 
    218          
    219            else if (TIMx == TIM9)
    220            {
    221              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
    222              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);
    223            } 
    224            else if (TIMx == TIM10)
    225            {
    226              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
    227              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);
    228            } 
    229            else
    230            {
    231              if (TIMx == TIM11)
    232              {
    233                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
    234                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE); 
    235              }  
    236            }
    237               
    238          }
    239          
    240          /**
    241            * @brief  Initializes the TIMx Time Base Unit peripheral according to 
    242            *         the specified parameters in the TIM_TimeBaseInitStruct.
    243            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    244            * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
    245            *         structure that contains the configuration information for
    246            *         the specified TIM peripheral.
    247            * @retval None
    248            */
    249          void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    250          {
    251            uint16_t tmpcr1 = 0;
    252          
    253            /* Check the parameters */
    254            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    255            assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
    256            assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
    257          
    258            tmpcr1 = TIMx->CR1;  
    259          
    260            if(((TIMx) == TIM2) || ((TIMx) == TIM3) || ((TIMx) == TIM4) || ((TIMx) == TIM5))
    261            {											
    262              /* Select the Counter Mode */
    263              tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
    264              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
    265            }
    266           
    267            if(((TIMx) != TIM6) && ((TIMx) != TIM7))
    268            {
    269              /* Set the clock division */
    270              tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
    271              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
    272            }
    273          
    274            TIMx->CR1 = tmpcr1;
    275          
    276            /* Set the Autoreload value */
    277            TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
    278           
    279            /* Set the Prescaler value */
    280            TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
    281              
    282            /* Generate an update event to reload the Prescaler value immediatly */
    283            TIMx->EGR = TIM_PSCReloadMode_Immediate;          
    284          }
    285          
    286          /**
    287            * @brief  Fills each TIM_TimeBaseInitStruct member with its default value.
    288            * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
    289            *         structure which will be initialized.
    290            * @retval None
    291            */
    292          void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    293          {
    294            /* Set the default configuration */
    295            TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
    296            TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
    297            TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
    298            TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
    299          }
    300          
    301          /**
    302            * @brief  Configures the TIMx Prescaler.
    303            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    304            * @param  Prescaler: specifies the Prescaler Register value.
    305            * @param  TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
    306            *   This parameter can be one of the following values:
    307            *     @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
    308            *     @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediatly.
    309            * @retval None
    310            */
    311          void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
    312          {
    313            /* Check the parameters */
    314            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    315            assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
    316            
    317            /* Set the Prescaler value */
    318            TIMx->PSC = Prescaler;
    319            /* Set or reset the UG Bit */
    320            TIMx->EGR = TIM_PSCReloadMode;
    321          }
    322          
    323          /**
    324            * @brief  Specifies the TIMx Counter Mode to be used.
    325            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
    326            * @param  TIM_CounterMode: specifies the Counter Mode to be used
    327            *   This parameter can be one of the following values:
    328            *     @arg TIM_CounterMode_Up: TIM Up Counting Mode.
    329            *     @arg TIM_CounterMode_Down: TIM Down Counting Mode.
    330            *     @arg TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1.
    331            *     @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2.
    332            *     @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3.
    333            * @retval None
    334            */
    335          void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
    336          {
    337            uint16_t tmpcr1 = 0;
    338            
    339            /* Check the parameters */
    340            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    341            assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
    342            
    343            tmpcr1 = TIMx->CR1;
    344            /* Reset the CMS and DIR Bits */
    345            tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
    346            /* Set the Counter Mode */
    347            tmpcr1 |= TIM_CounterMode;
    348            /* Write to TIMx CR1 register */
    349            TIMx->CR1 = tmpcr1;
    350          }
    351          
    352          /**
    353            * @brief  Sets the TIMx Counter Register value
    354            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    355            * @param  Counter: specifies the Counter register new value.
    356            * @retval None
    357            */
    358          void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
    359          {
    360            /* Check the parameters */
    361             assert_param(IS_TIM_ALL_PERIPH(TIMx));
    362             
    363            /* Set the Counter Register value */
    364            TIMx->CNT = Counter;
    365          }
    366          
    367          /**
    368            * @brief  Sets the TIMx Autoreload Register value
    369            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    370            * @param  Autoreload: specifies the Autoreload register new value.
    371            * @retval None
    372            */
    373          void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
    374          {
    375            /* Check the parameters */
    376            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    377            
    378            /* Set the Autoreload Register value */
    379            TIMx->ARR = Autoreload;
    380          }
    381          
    382          /**
    383            * @brief  Gets the TIMx Counter value.
    384            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    385            * @retval Counter Register value.
    386            */
    387          uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
    388          {
    389            /* Check the parameters */
    390            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    391            
    392            /* Get the Counter Register value */
    393            return TIMx->CNT;
    394          }
    395          
    396          /**
    397            * @brief  Gets the TIMx Prescaler value.
    398            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    399            * @retval Prescaler Register value.
    400            */
    401          uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
    402          {
    403            /* Check the parameters */
    404            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    405            
    406            /* Get the Prescaler Register value */
    407            return TIMx->PSC;
    408          }
    409          
    410          /**
    411            * @brief  Enables or Disables the TIMx Update event.
    412            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    413            * @param  NewState: new state of the TIMx UDIS bit
    414            *   This parameter can be: ENABLE or DISABLE.
    415            * @retval None
    416            */
    417          void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
    418          {
    419            /* Check the parameters */
    420            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    421            assert_param(IS_FUNCTIONAL_STATE(NewState));
    422            
    423            if (NewState != DISABLE)
    424            {
    425              /* Set the Update Disable Bit */
    426              TIMx->CR1 |= TIM_CR1_UDIS;
    427            }
    428            else
    429            {
    430              /* Reset the Update Disable Bit */
    431              TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
    432            }
    433          }
    434          
    435          /**
    436            * @brief  Configures the TIMx Update Request Interrupt source.
    437            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    438            * @param  TIM_UpdateSource: specifies the Update source.
    439            *   This parameter can be one of the following values:
    440            *     @arg TIM_UpdateSource_Global: Source of update is the counter overflow/underflow
    441                                                 or the setting of UG bit, or an update generation
    442                                                 through the slave mode controller.
    443            *     @arg TIM_UpdateSource_Regular: Source of update is counter overflow/underflow.
    444            * @retval None
    445            */
    446          void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
    447          {
    448            /* Check the parameters */
    449            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    450            assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
    451            
    452            if (TIM_UpdateSource != TIM_UpdateSource_Global)
    453            {
    454              /* Set the URS Bit */
    455              TIMx->CR1 |= TIM_CR1_URS;
    456            }
    457            else
    458            {
    459              /* Reset the URS Bit */
    460              TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
    461            }
    462          }
    463          
    464          /**
    465            * @brief  Enables or disables TIMx peripheral Preload register on ARR.
    466            * @param  TIMx: where x can be  2 to 11 to select the TIM peripheral.
    467            * @param  NewState: new state of the TIMx peripheral Preload register
    468            *   This parameter can be: ENABLE or DISABLE.
    469            * @retval None
    470            */
    471          void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
    472          {
    473            /* Check the parameters */
    474            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    475            assert_param(IS_FUNCTIONAL_STATE(NewState));
    476            
    477            if (NewState != DISABLE)
    478            {
    479              /* Set the ARR Preload Bit */
    480              TIMx->CR1 |= TIM_CR1_ARPE;
    481            }
    482            else
    483            {
    484              /* Reset the ARR Preload Bit */
    485              TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
    486            }
    487          }
    488          
    489          /**
    490            * @brief  Selects the TIMx's One Pulse Mode.
    491            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    492            * @param  TIM_OPMode: specifies the OPM Mode to be used.
    493            *   This parameter can be one of the following values:
    494            *     @arg TIM_OPMode_Single:: TIM One Pulse Single Mode (Counter stops counting 
    495            *                              at the next update event (clearing the bit CEN)).
    496            *     @arg TIM_OPMode_Repetitive: TIM One Pulse Repetitive Mode 
    497            *                                 (Counter is not stopped at update event).
    498            * @retval None
    499            */
    500          void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
    501          {
    502            /* Check the parameters */
    503            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    504            assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
    505            
    506            /* Reset the OPM Bit */
    507            TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
    508            /* Configure the OPM Mode */
    509            TIMx->CR1 |= TIM_OPMode;
    510          }
    511          
    512          /**
    513            * @brief  Sets the TIMx Clock Division value.
    514            * @param  TIMx: where x can be  2, 3, 4, 5, 9, 10 or 11 to select the TIM peripheral.
    515            * @param  TIM_CKD: specifies the clock division value.
    516            *   This parameter can be one of the following value:
    517            *     @arg TIM_CKD_DIV1: TDTS = Tck_tim.
    518            *     @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim.
    519            *     @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim.
    520            * @retval None
    521            */
    522          void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
    523          {
    524            /* Check the parameters */
    525            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
    526            assert_param(IS_TIM_CKD_DIV(TIM_CKD));
    527            
    528            /* Reset the CKD Bits */
    529            TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
    530            /* Set the CKD value */
    531            TIMx->CR1 |= TIM_CKD;
    532          }
    533          
    534          /**
    535            * @brief  Enables or disables the specified TIM peripheral.
    536            * @param  TIMx: where x can be 2 to 11 to select the TIMx peripheral.
    537            * @param  NewState: new state of the TIMx peripheral.
    538            *         This parameter can be: ENABLE or DISABLE.
    539            * @retval None
    540            */
    541          void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
    542          {
    543            /* Check the parameters */
    544            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    545            assert_param(IS_FUNCTIONAL_STATE(NewState));
    546            
    547            if (NewState != DISABLE)
    548            {
    549              /* Enable the TIM Counter */
    550              TIMx->CR1 |= TIM_CR1_CEN;
    551            }
    552            else
    553            {
    554              /* Disable the TIM Counter */
    555              TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
    556            }
    557          }
    558          
    559          /**
    560            * @}
    561            */
    562          
    563          /** @defgroup TIM_Group2 Output Compare management functions
    564           *  @brief    Output Compare management functions 
    565           *
    566          @verbatim
    567           ===============================================================================
    568                          ##### Output Compare management functions #####
    569           ===============================================================================
    570                  *** TIM Driver: how to use it in Output Compare Mode ***
    571           ===============================================================================
    572              [..] To use the Timer in Output Compare mode, the following steps are mandatory:
    573                   (#) Enable TIM clock using 
    574                       RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function.
    575                   (#) Configure the TIM pins by configuring the corresponding GPIO pins
    576                   (#) Configure the Time base unit as described in the first part of this 
    577                       driver, if needed, else the Timer will run with the default 
    578                       configuration:
    579                       (++) Autoreload value = 0xFFFF.
    580                       (++) Prescaler value = 0x0000.
    581                       (++) Counter mode = Up counting.
    582                       (++) Clock Division = TIM_CKD_DIV1.
    583                   (#) Fill the TIM_OCInitStruct with the desired parameters including:
    584                       (++) The TIM Output Compare mode: TIM_OCMode.
    585                       (++) TIM Output State: TIM_OutputState.
    586                       (++) TIM Pulse value: TIM_Pulse.
    587                       (++) TIM Output Compare Polarity : TIM_OCPolarity.
    588                   (#) Call TIM_OCxInit(TIMx, &TIM_OCInitStruct) to configure the desired 
    589                       channel with the corresponding configuration.
    590                   (#) Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
    591              [..]
    592                  (@) All other functions can be used separately to modify, if needed,
    593                    a specific feature of the Timer.
    594                  (@) In case of PWM mode, this function is mandatory:
    595                      TIM_OCxPreloadConfig(TIMx, TIM_OCPreload_ENABLE).
    596                  (@) If the corresponding interrupt or DMA request are needed, the user should:
    597                      (#@) Enable the NVIC (or the DMA) to use the TIM interrupts (or DMA requests).
    598                      (#@) Enable the corresponding interrupt (or DMA request) using the function
    599                           TIM_ITConfig(TIMx, TIM_IT_CCx) (or TIM_DMA_Cmd(TIMx, TIM_DMA_CCx)).
    600          
    601          @endverbatim
    602            * @{
    603            */
    604          
    605          /**
    606            * @brief  Initializes the TIMx Channel1 according to the specified
    607            *         parameters in the TIM_OCInitStruct.
    608            * @param  TIMx: where x can be 2, 3, 4, 5, 9, 10 or 11 to select the TIM peripheral.
    609            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    610            *         that contains the configuration information for the specified TIM 
    611            *         peripheral.
    612            * @retval None
    613            */
    614          void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    615          {
    616            uint16_t tmpccmrx = 0, tmpccer = 0;
    617             
    618            /* Check the parameters */
    619            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
    620            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    621            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    622            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    623            /* Disable the Channel 1: Reset the CC1E Bit */
    624            TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
    625            
    626            /* Get the TIMx CCER register value */
    627            tmpccer = TIMx->CCER;
    628            
    629            /* Get the TIMx CCMR1 register value */
    630            tmpccmrx = TIMx->CCMR1;
    631              
    632            /* Reset the Output Compare Mode Bits */
    633            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
    634            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
    635            
    636            /* Select the Output Compare Mode */
    637            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    638            
    639            /* Reset the Output Polarity level */
    640            tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
    641            /* Set the Output Compare Polarity */
    642            tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
    643            
    644            /* Set the Output State */
    645            tmpccer |= TIM_OCInitStruct->TIM_OutputState;
    646            
    647            /* Set the Capture Compare Register value */
    648            TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
    649            
    650            /* Write to TIMx CCMR1 */
    651            TIMx->CCMR1 = tmpccmrx;
    652            
    653            /* Write to TIMx CCER */
    654            TIMx->CCER = tmpccer;
    655          }
    656          
    657          /**
    658            * @brief  Initializes the TIMx Channel2 according to the specified
    659            *         parameters in the TIM_OCInitStruct.
    660            * @param  TIMx: where x can be 2, 3, 4, 5 or 9 to select the TIM peripheral.
    661            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    662            *         that contains the configuration information for the specified TIM 
    663            *         peripheral.
    664            * @retval None
    665            */
    666          void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    667          {
    668            uint16_t tmpccmrx = 0, tmpccer = 0;
    669             
    670            /* Check the parameters */
    671            assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
    672            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    673            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    674            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    675            /* Disable the Channel 2: Reset the CC2E Bit */
    676            TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
    677            
    678            /* Get the TIMx CCER register value */  
    679            tmpccer = TIMx->CCER;
    680            
    681            /* Get the TIMx CCMR1 register value */
    682            tmpccmrx = TIMx->CCMR1;
    683              
    684            /* Reset the Output Compare Mode Bits */
    685            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
    686            
    687            /* Select the Output Compare Mode */
    688            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
    689            
    690            /* Reset the Output Polarity level */
    691            tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
    692            /* Set the Output Compare Polarity */
    693            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
    694            
    695            /* Set the Output State */
    696            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
    697            
    698            /* Set the Capture Compare Register value */
    699            TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
    700              
    701            /* Write to TIMx CCMR1 */
    702            TIMx->CCMR1 = tmpccmrx;
    703            
    704            /* Write to TIMx CCER */
    705            TIMx->CCER = tmpccer;
    706          }
    707          
    708          /**
    709            * @brief  Initializes the TIMx Channel3 according to the specified
    710            *         parameters in the TIM_OCInitStruct.
    711            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
    712            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    713            *         that contains the configuration information for the specified TIM 
    714            *         peripheral.
    715            * @retval None
    716            */
    717          void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    718          {
    719            uint16_t tmpccmrx = 0, tmpccer = 0;
    720             
    721            /* Check the parameters */
    722            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    723            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    724            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    725            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    726          
    727            /* Disable the Channel 2: Reset the CC2E Bit */
    728            TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
    729            
    730            /* Get the TIMx CCER register value */
    731            tmpccer = TIMx->CCER;
    732            
    733            /* Get the TIMx CCMR2 register value */
    734            tmpccmrx = TIMx->CCMR2;
    735              
    736            /* Reset the Output Compare Mode Bits */
    737            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
    738            
    739            /* Select the Output Compare Mode */
    740            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    741            
    742            /* Reset the Output Polarity level */
    743            tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
    744            /* Set the Output Compare Polarity */
    745            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
    746            
    747            /* Set the Output State */
    748            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
    749            
    750            /* Set the Capture Compare Register value */
    751            TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
    752            
    753            /* Write to TIMx CCMR2 */
    754            TIMx->CCMR2 = tmpccmrx;
    755            
    756            /* Write to TIMx CCER */
    757            TIMx->CCER = tmpccer;
    758          }
    759          
    760          /**
    761            * @brief  Initializes the TIMx Channel4 according to the specified
    762            *         parameters in the TIM_OCInitStruct.
    763            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
    764            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    765            *         that contains the configuration information for the specified TIM 
    766            *         peripheral.
    767            * @retval None
    768            */
    769          void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    770          {
    771            uint16_t tmpccmrx = 0, tmpccer = 0;
    772             
    773            /* Check the parameters */
    774            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
    775            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    776            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    777            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    778          
    779            /* Disable the Channel 2: Reset the CC4E Bit */
    780            TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
    781            
    782            /* Get the TIMx CCER register value */
    783            tmpccer = TIMx->CCER;
    784            
    785            /* Get the TIMx CCMR2 register value */
    786            tmpccmrx = TIMx->CCMR2;
    787              
    788            /* Reset the Output Compare Mode Bits */
    789            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
    790            
    791            /* Select the Output Compare Mode */
    792            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
    793            
    794            /* Reset the Output Polarity level */
    795            tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
    796            /* Set the Output Compare Polarity */
    797            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
    798            
    799            /* Set the Output State */
    800            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
    801            
    802            /* Set the Capture Compare Register value */
    803            TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
    804            
    805            /* Write to TIMx CCMR2 */  
    806            TIMx->CCMR2 = tmpccmrx;
    807            
    808            /* Write to TIMx CCER */
    809            TIMx->CCER = tmpccer;
    810          }
    811          
    812          /**
    813            * @brief  Fills each TIM_OCInitStruct member with its default value.
    814            * @param  TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure which will
    815            *         be initialized.
    816            * @retval None
    817            */
    818          void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
    819          {
    820            /* Set the default configuration */
    821            TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
    822            TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
    823            TIM_OCInitStruct->TIM_Pulse = 0x0000;
    824            TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
    825          }
    826          
    827          /**
    828            * @brief  Selects the TIM Output Compare Mode.
    829            * @note   This function disables the selected channel before changing the Output
    830            *         Compare Mode.
    831            *         User has to enable this channel using TIM_CCxCmd and TIM_CCxNCmd functions.
    832            * @param  TIMx: where x can be 2, 3, 4, 5, 9, 10 or 11 to select the TIM peripheral.
    833            * @param  TIM_Channel: specifies the TIM Channel.
    834            *   This parameter can be one of the following values:
    835            *     @arg TIM_Channel_1: TIM Channel 1.
    836            *     @arg TIM_Channel_2: TIM Channel 2.
    837            *     @arg TIM_Channel_3: TIM Channel 3.
    838            *     @arg TIM_Channel_4: TIM Channel 4.
    839            * @param  TIM_OCMode: specifies the TIM Output Compare Mode.
    840            *   This parameter can be one of the following values:
    841            *     @arg TIM_OCMode_Timing: TIM Output Compare Timing mode.
    842            *     @arg TIM_OCMode_Active: TIM Output Compare Active mode.
    843            *     @arg TIM_OCMode_Inactive: TIM Output Compare Inactive mode.
    844            *     @arg TIM_OCMode_Toggle: TIM Output Compare Toggle mode.
    845            *     @arg TIM_OCMode_PWM1: TIM Output Compare PWM1 mode.
    846            *     @arg TIM_OCMode_PWM2: TIM Output Compare PWM2 mode.
    847            *     @arg TIM_ForcedAction_Active: TIM Forced Action Active mode.
    848            *     @arg TIM_ForcedAction_InActive: TIM Forced Action Inactive mode.
    849            * @retval None
    850            */
    851          void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
    852          {
    853            uint32_t tmp = 0;
    854            uint16_t tmp1 = 0;
    855          
    856            /* Check the parameters */
    857            assert_param(IS_TIM_LIST1_PERIPH(TIMx));  
    858            assert_param(IS_TIM_OCM(TIM_OCMode));
    859            
    860            tmp = (uint32_t) TIMx;
    861            tmp += CCMR_OFFSET;
    862          
    863            tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
    864          
    865            /* Disable the Channel: Reset the CCxE Bit */
    866            TIMx->CCER &= (uint16_t) ~tmp1;
    867          
    868            if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
    869            {
    870              tmp += (TIM_Channel>>1);
    871          
    872              /* Reset the OCxM bits in the CCMRx register */
    873              *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
    874             
    875              /* Configure the OCxM bits in the CCMRx register */
    876              *(__IO uint32_t *) tmp |= TIM_OCMode;
    877            }
    878            else
    879            {
    880              tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
    881          
    882              /* Reset the OCxM bits in the CCMRx register */
    883              *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
    884              
    885              /* Configure the OCxM bits in the CCMRx register */
    886              *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
    887            }
    888          }
    889          
    890          /**
    891            * @brief  Sets the TIMx Capture Compare1 Register value
    892            * @param  TIMx: where x can be 2, 3, 4, 5, 9, 10 or 11 to select the TIM peripheral.
    893            * @param  Compare1: specifies the Capture Compare1 register new value.
    894            * @retval None
    895            */
    896          void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
    897          {
    898            /* Check the parameters */
    899            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
    900            
    901            /* Set the Capture Compare1 Register value */
    902            TIMx->CCR1 = Compare1;
    903          }
    904          
    905          /**
    906            * @brief  Sets the TIMx Capture Compare2 Register value.
    907            * @param  TIMx: where x can be 2, 3, 4, 5 or 9 to select the TIM peripheral.
    908            * @param  Compare2: specifies the Capture Compare2 register new value.
    909            * @retval None
    910            */
    911          void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
    912          {
    913            /* Check the parameters */
    914            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    915            
    916            /* Set the Capture Compare2 Register value */
    917            TIMx->CCR2 = Compare2;
    918          }
    919          
    920          /**
    921            * @brief  Sets the TIMx Capture Compare3 Register value.
    922            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
    923            * @param  Compare3: specifies the Capture Compare3 register new value.
    924            * @retval None
    925            */
    926          void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
    927          {
    928            /* Check the parameters */
    929            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    930            
    931            /* Set the Capture Compare3 Register value */
    932            TIMx->CCR3 = Compare3;
    933          }
    934          
    935          /**
    936            * @brief  Sets the TIMx Capture Compare4 Register value.
    937            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
    938            * @param  Compare4: specifies the Capture Compare4 register new value.
    939            * @retval None
    940            */
    941          void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
    942          {
    943            /* Check the parameters */
    944            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    945            
    946            /* Set the Capture Compare4 Register value */
    947            TIMx->CCR4 = Compare4;
    948          }
    949          
    950          /**
    951            * @brief  Forces the TIMx output 1 waveform to active or inactive level.
    952            * @param  TIMx: where x can be 2, 3, 4, 5, 9, 10 or 11 to select the TIM peripheral.
    953            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
    954            *   This parameter can be one of the following values:
    955            *     @arg TIM_ForcedAction_Active: Force active level on OC1REF.
    956            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
    957            * @retval None
    958            */
    959          void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
    960          {
    961            uint16_t tmpccmr1 = 0;
    962            /* Check the parameters */
    963            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
    964            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
    965            tmpccmr1 = TIMx->CCMR1;
    966            /* Reset the OC1M Bits */
    967            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
    968            /* Configure The Forced output Mode */
    969            tmpccmr1 |= TIM_ForcedAction;
    970            /* Write to TIMx CCMR1 register */
    971            TIMx->CCMR1 = tmpccmr1;
    972          }
    973           
    974          /**
    975            * @brief  Forces the TIMx output 2 waveform to active or inactive level.
    976            * @param  TIMx: where x can be 2, 3, 4, 5 or 9 to select the TIM 
    977            *   peripheral.
    978            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
    979            *   This parameter can be one of the following values:
    980            *     @arg TIM_ForcedAction_Active: Force active level on OC2REF.
    981            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
    982            * @retval None
    983            */
    984          void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
    985          {
    986            uint16_t tmpccmr1 = 0;
    987            
    988            /* Check the parameters */
    989            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    990            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
    991            
    992            tmpccmr1 = TIMx->CCMR1;
    993            /* Reset the OC2M Bits */
    994            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
    995            /* Configure The Forced output Mode */
    996            tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
    997            /* Write to TIMx CCMR1 register */
    998            TIMx->CCMR1 = tmpccmr1;
    999          }
   1000          
   1001          /**
   1002            * @brief  Forces the TIMx output 3 waveform to active or inactive level.
   1003            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
   1004            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1005            *   This parameter can be one of the following values:
   1006            *     @arg TIM_ForcedAction_Active: Force active level on OC3REF.
   1007            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
   1008            * @retval None
   1009            */
   1010          void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1011          {
   1012            uint16_t tmpccmr2 = 0;
   1013            
   1014            /* Check the parameters */
   1015            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1016            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1017            
   1018            tmpccmr2 = TIMx->CCMR2;
   1019            /* Reset the OC1M Bits */
   1020            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
   1021            /* Configure The Forced output Mode */
   1022            tmpccmr2 |= TIM_ForcedAction;
   1023            /* Write to TIMx CCMR2 register */
   1024            TIMx->CCMR2 = tmpccmr2;
   1025          }
   1026          
   1027          /**
   1028            * @brief  Forces the TIMx output 4 waveform to active or inactive level.
   1029            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
   1030            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1031            *   This parameter can be one of the following values:
   1032            *     @arg TIM_ForcedAction_Active: Force active level on OC4REF.
   1033            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
   1034            * @retval None
   1035            */
   1036          void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1037          {
   1038            uint16_t tmpccmr2 = 0;
   1039            /* Check the parameters */
   1040            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1041            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1042            
   1043            tmpccmr2 = TIMx->CCMR2;
   1044            /* Reset the OC2M Bits */
   1045            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
   1046            /* Configure The Forced output Mode */
   1047            tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
   1048            /* Write to TIMx CCMR2 register */
   1049            TIMx->CCMR2 = tmpccmr2;
   1050          }
   1051          
   1052          /**
   1053            * @brief  Enables or disables the TIMx peripheral Preload register on CCR1.
   1054            * @param  TIMx: where x can be 2, 3, 4, 5, 9, 10 or 11 to select the TIM peripheral.
   1055            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register.
   1056            *   This parameter can be one of the following values:
   1057            *     @arg TIM_OCPreload_Enable: Enable TIM output compare Preload
   1058            *     @arg TIM_OCPreload_Disable: Disable TIM output compare Preload
   1059            * @retval None
   1060            */
   1061          void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1062          {
   1063            uint16_t tmpccmr1 = 0;
   1064            /* Check the parameters */
   1065            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1066            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1067            
   1068            tmpccmr1 = TIMx->CCMR1;
   1069            /* Reset the OC1PE Bit */
   1070            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
   1071            /* Enable or Disable the Output Compare Preload feature */
   1072            tmpccmr1 |= TIM_OCPreload;
   1073            /* Write to TIMx CCMR1 register */
   1074            TIMx->CCMR1 = tmpccmr1;
   1075          }
   1076          
   1077          /**
   1078            * @brief  Enables or disables the TIMx peripheral Preload register on CCR2.
   1079            * @param  TIMx: where x can be 2, 3, 4, 5 or 9 to select the TIM peripheral.
   1080            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register.
   1081            *   This parameter can be one of the following values:
   1082            *     @arg TIM_OCPreload_Enable: Enable TIM output compare Preload
   1083            *     @arg TIM_OCPreload_Disable: Disable TIM output compare Preload
   1084            * @retval None
   1085            */
   1086          void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1087          {
   1088            uint16_t tmpccmr1 = 0;
   1089            /* Check the parameters */
   1090            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1091            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1092            
   1093            tmpccmr1 = TIMx->CCMR1;
   1094            /* Reset the OC2PE Bit */
   1095            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
   1096            /* Enable or Disable the Output Compare Preload feature */
   1097            tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
   1098            /* Write to TIMx CCMR1 register */
   1099            TIMx->CCMR1 = tmpccmr1;
   1100          }
   1101          
   1102          /**
   1103            * @brief  Enables or disables the TIMx peripheral Preload register on CCR3.
   1104            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
   1105            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register.
   1106            *   This parameter can be one of the following values:
   1107            *     @arg TIM_OCPreload_Enable: Enable TIM output compare Preload
   1108            *     @arg TIM_OCPreload_Disable: Disable TIM output compare Preload
   1109            * @retval None
   1110            */
   1111          void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1112          {
   1113            uint16_t tmpccmr2 = 0;
   1114            
   1115            /* Check the parameters */
   1116            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1117            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1118            
   1119            tmpccmr2 = TIMx->CCMR2;
   1120            /* Reset the OC3PE Bit */
   1121            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
   1122            /* Enable or Disable the Output Compare Preload feature */
   1123            tmpccmr2 |= TIM_OCPreload;
   1124            /* Write to TIMx CCMR2 register */
   1125            TIMx->CCMR2 = tmpccmr2;
   1126          }
   1127          
   1128          /**
   1129            * @brief  Enables or disables the TIMx peripheral Preload register on CCR4.
   1130            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
   1131            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register.
   1132            *   This parameter can be one of the following values:
   1133            *     @arg TIM_OCPreload_Enable: Enable TIM output compare Preload
   1134            *     @arg TIM_OCPreload_Disable: Disable TIM output compare Preload
   1135            * @retval None
   1136            */
   1137          void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1138          {
   1139            uint16_t tmpccmr2 = 0;
   1140            
   1141            /* Check the parameters */
   1142            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1143            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1144            
   1145            tmpccmr2 = TIMx->CCMR2;
   1146            /* Reset the OC4PE Bit */
   1147            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
   1148            /* Enable or Disable the Output Compare Preload feature */
   1149            tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
   1150            /* Write to TIMx CCMR2 register */
   1151            TIMx->CCMR2 = tmpccmr2;
   1152          }
   1153          
   1154          /**
   1155            * @brief  Configures the TIMx Output Compare 1 Fast feature.
   1156            * @param  TIMx: where x can be 2, 3, 4, 5, 9, 10 or 11 to select the TIM peripheral.
   1157            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1158            *   This parameter can be one of the following values:
   1159            *     @arg TIM_OCFast_Enable: TIM output compare fast enable.
   1160            *     @arg TIM_OCFast_Disable: TIM output compare fast disable.
   1161            * @retval None
   1162            */
   1163          void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1164          {
   1165            uint16_t tmpccmr1 = 0;
   1166            
   1167            /* Check the parameters */
   1168            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1169            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1170            
   1171            /* Get the TIMx CCMR1 register value */
   1172            tmpccmr1 = TIMx->CCMR1;
   1173            /* Reset the OC1FE Bit */
   1174            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
   1175            /* Enable or Disable the Output Compare Fast Bit */
   1176            tmpccmr1 |= TIM_OCFast;
   1177            /* Write to TIMx CCMR1 */
   1178            TIMx->CCMR1 = tmpccmr1;
   1179          }
   1180          
   1181          /**
   1182            * @brief  Configures the TIMx Output Compare 2 Fast feature.
   1183            * @param  TIMx: where x can be 2, 3, 4, 5 or 9 to select the TIM peripheral.
   1184            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1185            *   This parameter can be one of the following values:
   1186            *     @arg TIM_OCFast_Enable: TIM output compare fast enable.
   1187            *     @arg TIM_OCFast_Disable: TIM output compare fast disable.
   1188            * @retval None
   1189            */
   1190          void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1191          {
   1192            uint16_t tmpccmr1 = 0;
   1193            
   1194            /* Check the parameters */
   1195            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1196            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1197            
   1198            /* Get the TIMx CCMR1 register value */
   1199            tmpccmr1 = TIMx->CCMR1;
   1200            /* Reset the OC2FE Bit */
   1201            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
   1202            /* Enable or Disable the Output Compare Fast Bit */
   1203            tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
   1204            /* Write to TIMx CCMR1 */
   1205            TIMx->CCMR1 = tmpccmr1;
   1206          }
   1207          
   1208          /**
   1209            * @brief  Configures the TIMx Output Compare 3 Fast feature.
   1210            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
   1211            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1212            *   This parameter can be one of the following values:
   1213            *     @arg TIM_OCFast_Enable: TIM output compare fast enable.
   1214            *     @arg TIM_OCFast_Disable: TIM output compare fast disable.
   1215            * @retval None
   1216            */
   1217          void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1218          {
   1219            uint16_t tmpccmr2 = 0;
   1220            
   1221            /* Check the parameters */
   1222            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1223            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1224            
   1225            /* Get the TIMx CCMR2 register value */
   1226            tmpccmr2 = TIMx->CCMR2;
   1227            /* Reset the OC3FE Bit */
   1228            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
   1229            /* Enable or Disable the Output Compare Fast Bit */
   1230            tmpccmr2 |= TIM_OCFast;
   1231            /* Write to TIMx CCMR2 */
   1232            TIMx->CCMR2 = tmpccmr2;
   1233          }
   1234          
   1235          /**
   1236            * @brief  Configures the TIMx Output Compare 4 Fast feature.
   1237            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
   1238            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1239            *   This parameter can be one of the following values:
   1240            *     @arg TIM_OCFast_Enable: TIM output compare fast enable.
   1241            *     @arg TIM_OCFast_Disable: TIM output compare fast disable.
   1242            * @retval None
   1243            */
   1244          void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1245          {
   1246            uint16_t tmpccmr2 = 0;
   1247            
   1248            /* Check the parameters */
   1249            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1250            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1251            
   1252            /* Get the TIMx CCMR2 register value */
   1253            tmpccmr2 = TIMx->CCMR2;
   1254            /* Reset the OC4FE Bit */
   1255            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
   1256            /* Enable or Disable the Output Compare Fast Bit */
   1257            tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
   1258            /* Write to TIMx CCMR2 */
   1259            TIMx->CCMR2 = tmpccmr2;
   1260          }
   1261          
   1262          /**
   1263            * @brief  Clears or safeguards the OCREF1 signal on an external event
   1264            * @param  TIMx: where x can be 2, 3, 4, 5, 9, 10 or 11 to select the TIM peripheral.
   1265            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1266            *   This parameter can be one of the following values:
   1267            *     @arg TIM_OCClear_Enable: TIM Output clear enable.
   1268            *     @arg TIM_OCClear_Disable: TIM Output clear disable.
   1269            * @retval None
   1270            */
   1271          void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1272          {
   1273            uint16_t tmpccmr1 = 0;
   1274            
   1275            /* Check the parameters */
   1276            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1277            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1278            
   1279            tmpccmr1 = TIMx->CCMR1;
   1280            /* Reset the OC1CE Bit */
   1281            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
   1282            /* Enable or Disable the Output Compare Clear Bit */
   1283            tmpccmr1 |= TIM_OCClear;
   1284            /* Write to TIMx CCMR1 register */
   1285            TIMx->CCMR1 = tmpccmr1;
   1286          }
   1287          
   1288          /**
   1289            * @brief  Clears or safeguards the OCREF2 signal on an external event
   1290            * @param  TIMx: where x can be 2, 3, 4, 5 or 9 to select the TIM peripheral.
   1291            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1292          
   1293            *   This parameter can be one of the following values:
   1294            *     @arg TIM_OCClear_Enable: TIM Output clear enable.
   1295            *     @arg TIM_OCClear_Disable: TIM Output clear disable .
   1296            * @retval None
   1297            */
   1298          void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1299          {
   1300            uint16_t tmpccmr1 = 0;
   1301            
   1302            /* Check the parameters */
   1303            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1304            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1305            
   1306            tmpccmr1 = TIMx->CCMR1;
   1307            /* Reset the OC2CE Bit */
   1308            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
   1309            /* Enable or Disable the Output Compare Clear Bit */
   1310            tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
   1311            /* Write to TIMx CCMR1 register */
   1312            TIMx->CCMR1 = tmpccmr1;
   1313          }
   1314          
   1315          /**
   1316            * @brief  Clears or safeguards the OCREF3 signal on an external event
   1317            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
   1318            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1319            *   This parameter can be one of the following values:
   1320            *     @arg TIM_OCClear_Enable: TIM Output clear enable.
   1321            *     @arg TIM_OCClear_Disable: TIM Output clear disable.
   1322            * @retval None
   1323            */
   1324          void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1325          {
   1326            uint16_t tmpccmr2 = 0;
   1327            
   1328            /* Check the parameters */
   1329            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1330            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1331            
   1332            tmpccmr2 = TIMx->CCMR2;
   1333            /* Reset the OC3CE Bit */
   1334            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
   1335            /* Enable or Disable the Output Compare Clear Bit */
   1336            tmpccmr2 |= TIM_OCClear;
   1337            /* Write to TIMx CCMR2 register */
   1338            TIMx->CCMR2 = tmpccmr2;
   1339          }
   1340          
   1341          /**
   1342            * @brief  Clears or safeguards the OCREF4 signal on an external event
   1343            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
   1344            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1345            *   This parameter can be one of the following values:
   1346            *     @arg TIM_OCClear_Enable: TIM Output clear enable.
   1347            *     @arg TIM_OCClear_Disable: TIM Output clear disable.
   1348            * @retval None
   1349            */
   1350          void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1351          {
   1352            uint16_t tmpccmr2 = 0;
   1353            
   1354            /* Check the parameters */
   1355            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1356            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1357            
   1358            tmpccmr2 = TIMx->CCMR2;
   1359            /* Reset the OC4CE Bit */
   1360            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
   1361            /* Enable or Disable the Output Compare Clear Bit */
   1362            tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
   1363            /* Write to TIMx CCMR2 register */
   1364            TIMx->CCMR2 = tmpccmr2;
   1365          }
   1366          
   1367          /**
   1368            * @brief  Configures the TIMx channel 1 polarity.
   1369            * @param  TIMx: where x can be 2, 3, 4, 5, 9, 10 or 11 to select the TIM peripheral.
   1370            * @param  TIM_OCPolarity: specifies the OC1 Polarity.
   1371            *   This parameter can be one of the following values:
   1372            *     @arg TIM_OCPolarity_High: Output Compare active high.
   1373            *     @arg TIM_OCPolarity_Low: Output Compare active low.
   1374            * @retval None
   1375            */
   1376          void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1377          {
   1378            uint16_t tmpccer = 0;
   1379            
   1380            /* Check the parameters */
   1381            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1382            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1383            
   1384            tmpccer = TIMx->CCER;
   1385            /* Set or Reset the CC1P Bit */
   1386            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
   1387            tmpccer |= TIM_OCPolarity;
   1388            /* Write to TIMx CCER register */
   1389            TIMx->CCER = tmpccer;
   1390          }
   1391          
   1392          /**
   1393            * @brief  Configures the TIMx channel 2 polarity.
   1394            * @param  TIMx: where x can be 2, 3, 4, 5 or 9 to select the TIM peripheral.
   1395            * @param  TIM_OCPolarity: specifies the OC2 Polarity.
   1396            *   This parameter can be one of the following values:
   1397            *     @arg TIM_OCPolarity_High: Output Compare active high.
   1398            *     @arg TIM_OCPolarity_Low: Output Compare active low.
   1399            * @retval None
   1400            */
   1401          void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1402          {
   1403            uint16_t tmpccer = 0;
   1404            
   1405            /* Check the parameters */
   1406            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1407            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1408            
   1409            tmpccer = TIMx->CCER;
   1410            /* Set or Reset the CC2P Bit */
   1411            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
   1412            tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
   1413            /* Write to TIMx CCER register */
   1414            TIMx->CCER = tmpccer;
   1415          }
   1416          
   1417          /**
   1418            * @brief  Configures the TIMx channel 3 polarity.
   1419            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
   1420            * @param  TIM_OCPolarity: specifies the OC3 Polarity.
   1421            *   This parameter can be one of the following values:
   1422            *     @arg TIM_OCPolarity_High: Output Compare active high.
   1423            *     @arg TIM_OCPolarity_Low: Output Compare active low.
   1424            * @retval None
   1425            */
   1426          void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1427          {
   1428            uint16_t tmpccer = 0;
   1429            
   1430            /* Check the parameters */
   1431            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1432            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1433            
   1434            tmpccer = TIMx->CCER;
   1435            /* Set or Reset the CC3P Bit */
   1436            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
   1437            tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
   1438            /* Write to TIMx CCER register */
   1439            TIMx->CCER = tmpccer;
   1440          }
   1441          
   1442          /**
   1443            * @brief  Configures the TIMx channel 4 polarity.
   1444            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
   1445            * @param  TIM_OCPolarity: specifies the OC4 Polarity.
   1446            *   This parameter can be one of the following values:
   1447            *     @arg TIM_OCPolarity_High: Output Compare active high.
   1448            *     @arg TIM_OCPolarity_Low: Output Compare active low.
   1449            * @retval None
   1450            */
   1451          void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1452          {
   1453            uint16_t tmpccer = 0;
   1454            
   1455            /* Check the parameters */
   1456            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1457            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1458            
   1459            tmpccer = TIMx->CCER;
   1460            /* Set or Reset the CC4P Bit */
   1461            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
   1462            tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
   1463            /* Write to TIMx CCER register */
   1464            TIMx->CCER = tmpccer;
   1465          }
   1466          
   1467          /**
   1468            * @brief  Selects the OCReference Clear source.
   1469            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
   1470            * @param  TIM_OCReferenceClear: specifies the OCReference Clear source.
   1471            *   This parameter can be one of the following values:
   1472            *     @arg TIM_OCReferenceClear_ETRF: The internal OCreference clear input is connected to ETRF.
   1473            *     @arg TIM_OCReferenceClear_OCREFCLR: The internal OCreference clear input is connected to OCREF_CLR input.  
   1474            * @retval None
   1475            */
   1476          void TIM_SelectOCREFClear(TIM_TypeDef* TIMx, uint16_t TIM_OCReferenceClear)
   1477          {
   1478            /* Check the parameters */
   1479            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1480            assert_param(TIM_OCREFERENCECECLEAR_SOURCE(TIM_OCReferenceClear));
   1481          
   1482            /* Set the TIM_OCReferenceClear source */
   1483            TIMx->SMCR &=  (uint16_t)~((uint16_t)TIM_SMCR_OCCS);
   1484            TIMx->SMCR |=  TIM_OCReferenceClear;
   1485          }
   1486          
   1487          /**
   1488            * @brief  Enables or disables the TIM Capture Compare Channel x.
   1489            * @param  TIMx: where x can be 2, 3, 4, 5, 9, 10 or 11 to select the TIM peripheral.
   1490            * @param  TIM_Channel: specifies the TIM Channel.
   1491            *   This parameter can be one of the following values:
   1492            *     @arg TIM_Channel_1: TIM Channel 1.
   1493            *     @arg TIM_Channel_2: TIM Channel 2.
   1494            *     @arg TIM_Channel_3: TIM Channel 3.
   1495            *     @arg TIM_Channel_4: TIM Channel 4.
   1496            * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
   1497            *   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
   1498            * @retval None
   1499            */
   1500          void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
   1501          {
   1502            uint16_t tmp = 0;
   1503          
   1504            /* Check the parameters */
   1505            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
   1506            assert_param(IS_TIM_CCX(TIM_CCx));
   1507          
   1508            tmp = CCER_CCE_SET << TIM_Channel;
   1509          
   1510            /* Reset the CCxE Bit */
   1511            TIMx->CCER &= (uint16_t)~ tmp;
   1512          
   1513            /* Set or reset the CCxE Bit */ 
   1514            TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
   1515          }
   1516          
   1517          /**
   1518            * @}
   1519            */
   1520          
   1521          /** @defgroup TIM_Group3 Input Capture management functions
   1522           *  @brief    Input Capture management functions 
   1523           *
   1524          @verbatim
   1525           ===============================================================================
   1526                         ##### Input Capture management functions #####
   1527           ===============================================================================
   1528             
   1529                    *** TIM Driver: how to use it in Input Capture Mode ***
   1530           ===============================================================================
   1531              [..] To use the Timer in Input Capture mode, the following steps are mandatory:
   1532                   (#) Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) 
   1533                       function.
   1534                   (#) Configure the TIM pins by configuring the corresponding GPIO pins.
   1535                   (#) Configure the Time base unit as described in the first part of this 
   1536                       driver, if needed, else the Timer will run with the default configuration:
   1537                       (++) Autoreload value = 0xFFFF.
   1538                       (++) Prescaler value = 0x0000.
   1539                       (++) Counter mode = Up counting.
   1540                       (++) Clock Division = TIM_CKD_DIV1.
   1541                   (#) Fill the TIM_ICInitStruct with the desired parameters including:
   1542                       (++) TIM Channel: TIM_Channel.
   1543                       (++) TIM Input Capture polarity: TIM_ICPolarity.
   1544                       (++) TIM Input Capture selection: TIM_ICSelection.
   1545                       (++) TIM Input Capture Prescaler: TIM_ICPrescaler.
   1546                       (++) TIM Input CApture filter value: TIM_ICFilter.
   1547                   (#) Call TIM_ICInit(TIMx, &TIM_ICInitStruct) to configure the desired 
   1548                       channel with the corresponding configuration and to measure only 
   1549                       frequency or duty cycle of the input signal,or, Call 
   1550                       TIM_PWMIConfig(TIMx, &TIM_ICInitStruct) to configure the desired 
   1551                       channels with the corresponding configuration and to measure the 
   1552                       frequency and the duty cycle of the input signal.
   1553                   (#) Enable the NVIC or the DMA to read the measured frequency.
   1554                   (#) Enable the corresponding interrupt (or DMA request) to read 
   1555                       the Captured value, using the function TIM_ITConfig(TIMx, TIM_IT_CCx)
   1556                       (or TIM_DMA_Cmd(TIMx, TIM_DMA_CCx)).
   1557                   (#) Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
   1558                   (#) Use TIM_GetCapturex(TIMx); to read the captured value.
   1559              [..]
   1560                  (@) All other functions can be used separately to modify, if needed,
   1561                      a specific feature of the Timer. 
   1562          
   1563          @endverbatim
   1564            * @{
   1565            */
   1566          
   1567          /**
   1568            * @brief  Initializes the TIM peripheral according to the specified
   1569            *         parameters in the TIM_ICInitStruct.
   1570            * @param  TIMx: where x can be 2, 3, 4, 5, 9, 10 or 11 to select the TIM peripheral.
   1571            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
   1572            *         that contains the configuration information for the specified TIM 
   1573            *         peripheral.
   1574            * @retval None
   1575            */
   1576          void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   1577          {
   1578            /* Check the parameters */
   1579            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1580            assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
   1581            assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
   1582            assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
   1583            assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
   1584            
   1585            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   1586            {
   1587              /* TI1 Configuration */
   1588              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1589                         TIM_ICInitStruct->TIM_ICSelection,
   1590                         TIM_ICInitStruct->TIM_ICFilter);
   1591              /* Set the Input Capture Prescaler value */
   1592              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1593            }
   1594            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
   1595            {
   1596              /* TI2 Configuration */
   1597              assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1598              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1599                         TIM_ICInitStruct->TIM_ICSelection,
   1600                         TIM_ICInitStruct->TIM_ICFilter);
   1601              /* Set the Input Capture Prescaler value */
   1602              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1603            }
   1604            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
   1605            {
   1606              /* TI3 Configuration */
   1607              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1608              TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
   1609                         TIM_ICInitStruct->TIM_ICSelection,
   1610                         TIM_ICInitStruct->TIM_ICFilter);
   1611              /* Set the Input Capture Prescaler value */
   1612              TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1613            }
   1614            else
   1615            {
   1616              /* TI4 Configuration */
   1617              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1618              TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1619                         TIM_ICInitStruct->TIM_ICSelection,
   1620                         TIM_ICInitStruct->TIM_ICFilter);
   1621              /* Set the Input Capture Prescaler value */
   1622              TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1623            }
   1624          }
   1625          
   1626          /**
   1627            * @brief  Fills each TIM_ICInitStruct member with its default value.
   1628            * @param  TIM_ICInitStruct : pointer to a TIM_ICInitTypeDef structure which will
   1629            *         be initialized.
   1630            * @retval None
   1631            */
   1632          void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
   1633          {
   1634            /* Set the default configuration */
   1635            TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
   1636            TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
   1637            TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
   1638            TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
   1639            TIM_ICInitStruct->TIM_ICFilter = 0x00;
   1640          }
   1641          
   1642          /**
   1643            * @brief  Configures the TIM peripheral according to the specified
   1644            *         parameters in the TIM_ICInitStruct to measure an external PWM signal.
   1645            * @param  TIMx: where x can be 2, 3, 4, 5 or 9 to select the TIM peripheral.
   1646            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
   1647            *         that contains the configuration information for the specified TIM 
   1648            *         peripheral.
   1649            * @retval None
   1650            */
   1651          void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   1652          {
   1653            uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
   1654            uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
   1655            /* Check the parameters */
   1656            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1657            /* Select the Opposite Input Polarity */
   1658            if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
   1659            {
   1660              icoppositepolarity = TIM_ICPolarity_Falling;
   1661            }
   1662            else
   1663            {
   1664              icoppositepolarity = TIM_ICPolarity_Rising;
   1665            }
   1666            /* Select the Opposite Input */
   1667            if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
   1668            {
   1669              icoppositeselection = TIM_ICSelection_IndirectTI;
   1670            }
   1671            else
   1672            {
   1673              icoppositeselection = TIM_ICSelection_DirectTI;
   1674            }
   1675            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   1676            {
   1677              /* TI1 Configuration */
   1678              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   1679                         TIM_ICInitStruct->TIM_ICFilter);
   1680              /* Set the Input Capture Prescaler value */
   1681              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1682              /* TI2 Configuration */
   1683              TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   1684              /* Set the Input Capture Prescaler value */
   1685              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1686            }
   1687            else
   1688            { 
   1689              /* TI2 Configuration */
   1690              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   1691                         TIM_ICInitStruct->TIM_ICFilter);
   1692              /* Set the Input Capture Prescaler value */
   1693              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1694              /* TI1 Configuration */
   1695              TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   1696              /* Set the Input Capture Prescaler value */
   1697              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1698            }
   1699          }
   1700          
   1701          /**
   1702            * @brief  Gets the TIMx Input Capture 1 value.
   1703            * @param  TIMx: where x can be 2, 3, 4, 5, 9, 10 or 11 to select the TIM peripheral.
   1704            * @retval Capture Compare 1 Register value.
   1705            */
   1706          uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
   1707          {
   1708            /* Check the parameters */
   1709            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1710            
   1711            /* Get the Capture 1 Register value */
   1712            return TIMx->CCR1;
   1713          }
   1714          
   1715          /**
   1716            * @brief  Gets the TIMx Input Capture 2 value.
   1717            * @param  TIMx: where x can be 2, 3, 4, 5 or 9 to select the TIM peripheral.
   1718            * @retval Capture Compare 2 Register value.
   1719            */
   1720          uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
   1721          {
   1722            /* Check the parameters */
   1723            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1724            
   1725            /* Get the Capture 2 Register value */
   1726            return TIMx->CCR2;
   1727          }
   1728          
   1729          /**
   1730            * @brief  Gets the TIMx Input Capture 3 value.
   1731            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
   1732            * @retval Capture Compare 3 Register value.
   1733            */
   1734          uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
   1735          {
   1736            /* Check the parameters */
   1737            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
   1738            
   1739            /* Get the Capture 3 Register value */
   1740            return TIMx->CCR3;
   1741          }
   1742          
   1743          /**
   1744            * @brief  Gets the TIMx Input Capture 4 value.
   1745            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
   1746            * @retval Capture Compare 4 Register value.
   1747            */
   1748          uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
   1749          {
   1750            /* Check the parameters */
   1751            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1752            
   1753            /* Get the Capture 4 Register value */
   1754            return TIMx->CCR4;
   1755          }
   1756          
   1757          /**
   1758            * @brief  Sets the TIMx Input Capture 1 prescaler.
   1759            * @param  TIMx: where x can be 2, 3, 4, 5, 9, 10 or 11 to select the TIM peripheral.
   1760            * @param  TIM_ICPSC: specifies the Input Capture1 prescaler new value.
   1761            *   This parameter can be one of the following values:
   1762            *     @arg TIM_ICPSC_DIV1: no prescaler.
   1763            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events.
   1764            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events.
   1765            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events.
   1766            * @retval None
   1767            */
   1768          void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   1769          {
   1770            /* Check the parameters */
   1771            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1772            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   1773            
   1774            /* Reset the IC1PSC Bits */
   1775            TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
   1776            /* Set the IC1PSC value */
   1777            TIMx->CCMR1 |= TIM_ICPSC;
   1778          }
   1779          
   1780          /**
   1781            * @brief  Sets the TIMx Input Capture 2 prescaler.
   1782            * @param  TIMx: where x can be 2, 3, 4, 5 or 9 to select the TIM peripheral.
   1783            * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.
   1784            *   This parameter can be one of the following values:
   1785            *     @arg TIM_ICPSC_DIV1: no prescaler.
   1786            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events.
   1787            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events.
   1788            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events.
   1789            * @retval None
   1790            */
   1791          void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   1792          {
   1793            /* Check the parameters */
   1794            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1795            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   1796            
   1797            /* Reset the IC2PSC Bits */
   1798            TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
   1799            /* Set the IC2PSC value */
   1800            TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
   1801          }
   1802          
   1803          /**
   1804            * @brief  Sets the TIMx Input Capture 3 prescaler.
   1805            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
   1806            * @param  TIM_ICPSC: specifies the Input Capture3 prescaler new value.
   1807            *   This parameter can be one of the following values:
   1808            *     @arg TIM_ICPSC_DIV1: no prescaler.
   1809            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events.
   1810            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events.
   1811            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events.
   1812            * @retval None
   1813            */
   1814          void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   1815          {
   1816            /* Check the parameters */
   1817            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1818            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   1819            
   1820            /* Reset the IC3PSC Bits */
   1821            TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
   1822            /* Set the IC3PSC value */
   1823            TIMx->CCMR2 |= TIM_ICPSC;
   1824          }
   1825          
   1826          /**
   1827            * @brief  Sets the TIMx Input Capture 4 prescaler.
   1828            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
   1829            * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.
   1830            *   This parameter can be one of the following values:
   1831            *     @arg TIM_ICPSC_DIV1: no prescaler.
   1832            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events.
   1833            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events.
   1834            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events.
   1835            * @retval None
   1836            */
   1837          void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   1838          {  
   1839            /* Check the parameters */
   1840            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1841            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   1842            
   1843            /* Reset the IC4PSC Bits */
   1844            TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
   1845            /* Set the IC4PSC value */
   1846            TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
   1847          }
   1848          
   1849          /**
   1850            * @}
   1851            */
   1852          
   1853          /** @defgroup TIM_Group4 Interrupts DMA and flags management functions
   1854           *  @brief    Interrupts, DMA and flags management functions 
   1855           *
   1856          @verbatim
   1857           ===============================================================================
   1858                    ##### Interrupts, DMA and flags management functions #####
   1859           ===============================================================================
   1860          
   1861          @endverbatim
   1862            * @{
   1863            */
   1864          
   1865          /**
   1866            * @brief  Enables or disables the specified TIM interrupts.
   1867            * @param  TIMx: where x can be 2 to 11 to select the TIMx peripheral.
   1868            * @param  TIM_IT: specifies the TIM interrupts sources to be enabled or disabled.
   1869            *   This parameter can be any combination of the following values:
   1870            *     @arg TIM_IT_Update: TIM update Interrupt source.
   1871            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source.
   1872            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source.
   1873            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source.
   1874            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source.
   1875            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source.
   1876            * @note TIM6 and TIM7 can only generate an update interrupt.  
   1877            * @note TIM_IT_CC2, TIM_IT_CC3, TIM_IT_CC4 and TIM_IT_Trigger can not be used with TIM10 and TIM11.
   1878            * @note TIM_IT_CC3, TIM_IT_CC4 can not be used with TIM9.   
   1879            * @param  NewState: new state of the TIM interrupts.
   1880            *         This parameter can be: ENABLE or DISABLE.
   1881            * @retval None
   1882            */
   1883          void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
   1884          {  
   1885            /* Check the parameters */
   1886            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1887            assert_param(IS_TIM_IT(TIM_IT));
   1888            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1889            
   1890            if (NewState != DISABLE)
   1891            {
   1892              /* Enable the Interrupt sources */
   1893              TIMx->DIER |= TIM_IT;
   1894            }
   1895            else
   1896            {
   1897              /* Disable the Interrupt sources */
   1898              TIMx->DIER &= (uint16_t)~TIM_IT;
   1899            }
   1900          }
   1901          
   1902          /**
   1903            * @brief  Configures the TIMx event to be generate by software.
   1904            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
   1905            * @param  TIM_EventSource: specifies the event source.
   1906            *   This parameter can be one or more of the following values:	   
   1907            *     @arg TIM_EventSource_Update: Timer update Event source.
   1908            *     @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source.
   1909            *     @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source.
   1910            *     @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source.
   1911            *     @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source.
   1912            *     @arg TIM_EventSource_Trigger: Timer Trigger Event source.
   1913            * @note TIM6 and TIM7 can only generate an update event. 
   1914            * @note TIM9 can only generate an update event, Capture Compare 1 event, 
   1915            *     Capture Compare 2 event and TIM_EventSource_Trigger.  
   1916            * @note TIM10 and TIM11 can only generate an update event and Capture Compare 1 event.            
   1917            * @retval None
   1918            */
   1919          void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
   1920          { 
   1921            /* Check the parameters */
   1922            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1923            assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource)); 
   1924            /* Set the event sources */
   1925            TIMx->EGR = TIM_EventSource;
   1926          }
   1927          
   1928          /**
   1929            * @brief  Checks whether the specified TIM flag is set or not.
   1930            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
   1931            * @param  TIM_FLAG: specifies the flag to check.
   1932            *   This parameter can be one of the following values:
   1933            *     @arg TIM_FLAG_Update: TIM update Flag.
   1934            *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag.
   1935            *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag.
   1936            *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag.
   1937            *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag.
   1938            *     @arg TIM_FLAG_Trigger: TIM Trigger Flag.
   1939            *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag.
   1940            *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag.
   1941            *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag.
   1942            *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag.
   1943            *
   1944            * @note TIM6 and TIM7 can have only one update flag.
   1945            * @note TIM9 can have only update flag, TIM_FLAG_CC1, TIM_FLAG_CC2 and TIM_FLAG_Trigger,
   1946            *     TIM_FLAG_CC1OF or TIM_FLAG_CC2OF flags.  
   1947            * @note TIM10 and TIM11 can have only update flag, TIM_FLAG_CC1 or TIM_FLAG_CC1OF flags         
   1948            * @retval The new state of TIM_FLAG (SET or RESET).
   1949            */
   1950          FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   1951          { 
   1952            ITStatus bitstatus = RESET; 
   1953             
   1954            /* Check the parameters */
   1955            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1956            assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
   1957            
   1958            if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
   1959            {
   1960              bitstatus = SET;
   1961            }
   1962            else
   1963            {
   1964              bitstatus = RESET;
   1965            }
   1966            return bitstatus;
   1967          }
   1968          
   1969          /**
   1970            * @brief  Clears the TIMx's pending flags.
   1971            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
   1972            * @param  TIM_FLAG: specifies the flag bit to clear.
   1973            *   This parameter can be any combination of the following values:
   1974            *     @arg TIM_FLAG_Update: TIM update Flag.
   1975            *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag.
   1976            *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag.
   1977            *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag.
   1978            *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag.
   1979            *     @arg TIM_FLAG_Trigger: TIM Trigger Flag.
   1980            *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag.
   1981            *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag.
   1982            *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag.
   1983            *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag.
   1984            * @note TIM6 and TIM7 can have only one update flag. 
   1985            * @note TIM9 can have only update flag, TIM_FLAG_CC1, TIM_FLAG_CC2 and TIM_FLAG_Trigger flags
   1986            *     TIM_FLAG_CC1OF or TIM_FLAG_CC2OF flags.  
   1987            * @note TIM10 and TIM11 can have only update flag, TIM_FLAG_CC1
   1988            *     or TIM_FLAG_CC1OF flags      
   1989            * @retval None
   1990            */
   1991          void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   1992          {  
   1993            /* Check the parameters */
   1994            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1995            assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
   1996             
   1997            /* Clear the flags */
   1998            TIMx->SR = (uint16_t)~TIM_FLAG;
   1999          }
   2000          
   2001          /**
   2002            * @brief  Checks whether the TIM interrupt has occurred or not.
   2003            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
   2004            * @param  TIM_IT: specifies the TIM interrupt source to check.
   2005            *   This parameter can be one of the following values:
   2006            *     @arg TIM_IT_Update: TIM update Interrupt source.
   2007            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source.
   2008            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source.
   2009            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source.
   2010            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source.
   2011            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source.
   2012            *
   2013            * @note TIM6 and TIM7 can generate only an update interrupt.
   2014            * @note TIM9 can have only update interrupt, TIM_FLAG_CC1 or TIM_FLAG_CC2,
   2015            *     interrupt and TIM_IT_Trigger interrupt.
   2016            * @note TIM10 and TIM11 can have only update interrupt or TIM_FLAG_CC1
   2017            *     interrupt      
   2018            * @retval The new state of the TIM_IT(SET or RESET).
   2019            */
   2020          ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2021          {
   2022            ITStatus bitstatus = RESET;  
   2023            uint16_t itstatus = 0x0, itenable = 0x0;
   2024            
   2025            /* Check the parameters */
   2026            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2027            assert_param(IS_TIM_GET_IT(TIM_IT));
   2028             
   2029            itstatus = TIMx->SR & TIM_IT;
   2030            
   2031            itenable = TIMx->DIER & TIM_IT;
   2032            if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
   2033            {
   2034              bitstatus = SET;
   2035            }
   2036            else
   2037            {
   2038              bitstatus = RESET;
   2039            }
   2040            return bitstatus;
   2041          }
   2042          
   2043          /**
   2044            * @brief  Clears the TIMx's interrupt pending bits.
   2045            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
   2046            * @param  TIM_IT: specifies the pending bit to clear.
   2047            *   This parameter can be any combination of the following values:
   2048            *     @arg TIM_IT_Update: TIM update Interrupt source.
   2049            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source.
   2050            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source.
   2051            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source.
   2052            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source.
   2053            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source.
   2054            * @note
   2055            * @note TIM6 and TIM7 can generate only an update interrupt.
   2056            * @note TIM9 can have only update interrupt, TIM_IT_CC1 or TIM_IT_CC2,
   2057            *     and TIM_IT_Trigger interrupt.  
   2058            * @note TIM10 and TIM11 can have only update interrupt or TIM_IT_CC1
   2059            *     interrupt        
   2060            * @retval None
   2061            */
   2062          void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2063          {
   2064            /* Check the parameters */
   2065            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2066            assert_param(IS_TIM_IT(TIM_IT));
   2067             
   2068            /* Clear the IT pending Bit */
   2069            TIMx->SR = (uint16_t)~TIM_IT;
   2070          }
   2071          
   2072          /**
   2073            * @brief  Configures the TIMx's DMA interface.
   2074            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
   2075            * @param  TIM_DMABase: DMA Base address.
   2076            *   This parameter can be one of the following values:
   2077            *     @arg TIM_DMABase_CR1: TIM CR1 register as TIM DMA Base.
   2078            *     @arg TIM_DMABase_CR2: TIM CR2 register as TIM DMA Base.
   2079            *     @arg TIM_DMABase_SMCR: TIM SMCR register as TIM DMA Base.
   2080            *     @arg TIM_DMABase_DIER: TIM DIER register as TIM DMA Base.
   2081            *     @arg TIM_DMABase_SR: TIM SR register as TIM DMA Base.
   2082            *     @arg TIM_DMABase_EGR: TIM EGR register as TIM DMA Base.
   2083            *     @arg TIM_DMABase_CCMR1: TIM CCMR1 register as TIM DMA Base.
   2084            *     @arg TIM_DMABase_CCMR2: TIM CCMR2 register as TIM DMA Base.
   2085            *     @arg TIM_DMABase_CCER: TIM CCER register as TIM DMA Base.
   2086            *     @arg TIM_DMABase_CNT: TIM CNT register as TIM DMA Base.
   2087            *     @arg TIM_DMABase_PSC: TIM PSC register as TIM DMA Base.
   2088            *     @arg TIM_DMABase_ARR: TIM ARR register as TIM DMA Base.
   2089            *     @arg TIM_DMABase_CCR1: TIM CCR1 register as TIM DMA Base.
   2090            *     @arg TIM_DMABase_CCR2: TIM CCR2 register as TIM DMA Base.
   2091            *     @arg TIM_DMABase_CCR3: TIM CCR3 register as TIM DMA Base.
   2092            *     @arg TIM_DMABase_CCR4: TIM CCR4 register as TIM DMA Base.
   2093            *     @arg TIM_DMABase_DCR: TIM DCR register as TIM DMA Base.
   2094            *     @arg TIM_DMABase_OR: TIM OR register as TIM DMA Base.
   2095            * @param  TIM_DMABurstLength: DMA Burst length.
   2096            *   This parameter can be one value between:
   2097            *   TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
   2098            * @retval None
   2099            */
   2100          void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
   2101          {
   2102            /* Check the parameters */
   2103            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2104            assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
   2105            assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
   2106            /* Set the DMA Base and the DMA Burst Length */
   2107            TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
   2108          }
   2109          
   2110          /**
   2111            * @brief  Enables or disables the TIMx's DMA Requests.
   2112            * @param  TIMx: where x can be 2, 3, 4, 5, 6 or 7 to select the TIM peripheral. 
   2113            * @param  TIM_DMASource: specifies the DMA Request sources.
   2114            *   This parameter can be any combination of the following values:
   2115            *     @arg TIM_DMA_Update: TIM update Interrupt source.
   2116            *     @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source.
   2117            *     @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source.
   2118            *     @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source.
   2119            *     @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source.
   2120            *     @arg TIM_DMA_Trigger: TIM Trigger DMA source.
   2121            * @param  NewState: new state of the DMA Request sources.
   2122            *   This parameter can be: ENABLE or DISABLE.
   2123            * @retval None
   2124            */
   2125          void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
   2126          { 
   2127            /* Check the parameters */
   2128            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   2129            assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
   2130            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2131            
   2132            if (NewState != DISABLE)
   2133            {
   2134              /* Enable the DMA sources */
   2135              TIMx->DIER |= TIM_DMASource; 
   2136            }
   2137            else
   2138            {
   2139              /* Disable the DMA sources */
   2140              TIMx->DIER &= (uint16_t)~TIM_DMASource;
   2141            }
   2142          }
   2143          
   2144          /**
   2145            * @brief  Selects the TIMx peripheral Capture Compare DMA source.
   2146            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
   2147            * @param  NewState: new state of the Capture Compare DMA source
   2148            *   This parameter can be: ENABLE or DISABLE.
   2149            * @retval None
   2150            */
   2151          void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
   2152          {
   2153            /* Check the parameters */
   2154            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2155            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2156            
   2157            if (NewState != DISABLE)
   2158            {
   2159              /* Set the CCDS Bit */
   2160              TIMx->CR2 |= TIM_CR2_CCDS;
   2161            }
   2162            else
   2163            {
   2164              /* Reset the CCDS Bit */
   2165              TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
   2166            }
   2167          }
   2168          
   2169          /**
   2170            * @}
   2171            */
   2172          
   2173          /** @defgroup TIM_Group5 Clocks management functions
   2174           *  @brief    Clocks management functions
   2175           *
   2176          @verbatim
   2177           ===============================================================================
   2178                               ##### Clocks management functions #####
   2179           ===============================================================================
   2180          
   2181          @endverbatim
   2182            * @{
   2183            */
   2184          
   2185          /**
   2186            * @brief  Configures the TIMx internal Clock
   2187            * @param  TIMx: where x can be 2, 3, 4, 5 or 9 to select the TIM peripheral.
   2188            * @retval None
   2189            */
   2190          void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
   2191          {
   2192            /* Check the parameters */
   2193            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2194            /* Disable slave mode to clock the prescaler directly with the internal clock */
   2195            TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
   2196          }
   2197          
   2198          /**
   2199            * @brief  Configures the TIMx Internal Trigger as External Clock
   2200            * @param  TIMx: where x can be 2, 3, 4, 5 or 9 to select the TIM peripheral.
   2201            * @param  TIM_ITRSource: Trigger source.
   2202            *   This parameter can be one of the following values:
   2203            * @param  TIM_TS_ITR0: Internal Trigger 0.
   2204            * @param  TIM_TS_ITR1: Internal Trigger 1.
   2205            * @param  TIM_TS_ITR2: Internal Trigger 2.
   2206            * @param  TIM_TS_ITR3: Internal Trigger 3.
   2207            * @retval None
   2208            */
   2209          void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   2210          {
   2211            /* Check the parameters */
   2212            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2213            assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
   2214            /* Select the Internal Trigger */
   2215            TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
   2216            /* Select the External clock mode1 */
   2217            TIMx->SMCR |= TIM_SlaveMode_External1;
   2218          }
   2219          
   2220          /**
   2221            * @brief  Configures the TIMx Trigger as External Clock
   2222            * @param  TIMx: where x can be 2, 3, 4, 5 or 9 to select the TIM peripheral.
   2223            * @param  TIM_TIxExternalCLKSource: Trigger source.
   2224            *   This parameter can be one of the following values:
   2225            *     @arg TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector.
   2226            *     @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1.
   2227            *     @arg TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2.
   2228            * @param  TIM_ICPolarity: specifies the TIx Polarity.
   2229            *   This parameter can be one of the following values:
   2230            *     @arg TIM_ICPolarity_Rising:
   2231            *     @arg TIM_ICPolarity_Falling:
   2232            * @param  ICFilter : specifies the filter value.
   2233            *   This parameter must be a value between 0x0 and 0xF.
   2234            * @retval None
   2235            */
   2236          void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
   2237                                          uint16_t TIM_ICPolarity, uint16_t ICFilter)
   2238          {
   2239            /* Check the parameters */
   2240            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2241            assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
   2242            assert_param(IS_TIM_IC_FILTER(ICFilter));
   2243            
   2244            /* Configure the Timer Input Clock Source */
   2245            if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
   2246            {
   2247              TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   2248            }
   2249            else
   2250            {
   2251              TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   2252            }
   2253            /* Select the Trigger source */
   2254            TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
   2255            /* Select the External clock mode1 */
   2256            TIMx->SMCR |= TIM_SlaveMode_External1;
   2257          }
   2258          
   2259          /**
   2260            * @brief  Configures the External clock Mode1
   2261            * @param  TIMx: where x can be 2, 3, 4, 5 or 9 to select the TIM peripheral.
   2262            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2263            *   This parameter can be one of the following values:
   2264            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2265            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2266            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2267            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2268            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2269            *   This parameter can be one of the following values:
   2270            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2271            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2272            * @param  ExtTRGFilter: External Trigger Filter.
   2273            *   This parameter must be a value between 0x00 and 0x0F
   2274            * @retval None
   2275            */
   2276          void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
   2277                                       uint16_t ExtTRGFilter)
   2278          {
   2279            uint16_t tmpsmcr = 0;
   2280            
   2281            /* Check the parameters */
   2282            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2283            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   2284            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   2285            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   2286            
   2287            /* Configure the ETR Clock source */
   2288            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   2289            
   2290            /* Get the TIMx SMCR register value */
   2291            tmpsmcr = TIMx->SMCR;
   2292            /* Reset the SMS Bits */
   2293            tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
   2294            /* Select the External clock mode1 */
   2295            tmpsmcr |= TIM_SlaveMode_External1;
   2296            /* Select the Trigger selection : ETRF */
   2297            tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
   2298            tmpsmcr |= TIM_TS_ETRF;
   2299            /* Write to TIMx SMCR */
   2300            TIMx->SMCR = tmpsmcr;
   2301          }
   2302          
   2303          /**
   2304            * @brief  Configures the External clock Mode2
   2305            * @param  TIMx: where x can be 2, 3, 4, 5, 9, 10 or 11 to select the TIM peripheral.
   2306            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2307            *   This parameter can be one of the following values:
   2308            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2309            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2310            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2311            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2312            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2313            *   This parameter can be one of the following values:
   2314            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2315            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2316            * @param  ExtTRGFilter: External Trigger Filter.
   2317            *   This parameter must be a value between 0x00 and 0x0F
   2318            * @retval None
   2319            */
   2320          void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
   2321                                       uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   2322          {
   2323            /* Check the parameters */
   2324            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2325            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   2326            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   2327            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   2328            
   2329            /* Configure the ETR Clock source */
   2330            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   2331            /* Enable the External clock mode2 */
   2332            TIMx->SMCR |= TIM_SMCR_ECE;
   2333          }
   2334          
   2335          /**
   2336            * @}
   2337            */
   2338          
   2339          /** @defgroup TIM_Group6 Synchronization management functions
   2340           *  @brief    Synchronization management functions 
   2341           *
   2342          @verbatim
   2343           ===============================================================================
   2344                         ##### Synchronization management functions #####
   2345           ===============================================================================
   2346                  *** TIM Driver: how to use it in synchronization Mode ***
   2347           ===============================================================================
   2348              [..] Case of two/several Timers
   2349                   (#) Configure the Master Timers using the following functions:
   2350                       (++) void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx,
   2351                            uint16_t TIM_TRGOSource).
   2352                       (++) void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx,
   2353                            uint16_t TIM_MasterSlaveMode);  
   2354                   (#) Configure the Slave Timers using the following functions: 
   2355                       (++) void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, 
   2356                            uint16_t TIM_InputTriggerSource);  
   2357                       (++) void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);
   2358              [..] Case of Timers and external trigger(ETR pin)
   2359                   (#) Configure the Etrenal trigger using this function:
   2360                       (++) void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
   2361                            uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);
   2362                   (#) Configure the Slave Timers using the following functions:
   2363                       (++) void TIM_SelectInputTrigger(TIM_TypeDef* TIMx,
   2364                            uint16_t TIM_InputTriggerSource);
   2365                       (++) void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);
   2366          
   2367          @endverbatim
   2368            * @{
   2369            */
   2370          
   2371          /**
   2372            * @brief  Selects the Input Trigger source
   2373            * @param  TIMx: where x can be 2, 3, 4, 5, or 9 to select the TIM peripheral.
   2374            * @param  TIM_InputTriggerSource: The Input Trigger source.
   2375            *   This parameter can be one of the following values:
   2376            *     @arg TIM_TS_ITR0: Internal Trigger 0.
   2377            *     @arg TIM_TS_ITR1: Internal Trigger 1.
   2378            *     @arg TIM_TS_ITR2: Internal Trigger 2.
   2379            *     @arg TIM_TS_ITR3: Internal Trigger 3.
   2380            *     @arg TIM_TS_TI1F_ED: TI1 Edge Detector.
   2381            *     @arg TIM_TS_TI1FP1: Filtered Timer Input 1.
   2382            *     @arg TIM_TS_TI2FP2: Filtered Timer Input 2.
   2383            *     @arg TIM_TS_ETRF: External Trigger input.
   2384            * @retval None
   2385            */
   2386          void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   2387          {
   2388            uint16_t tmpsmcr = 0;
   2389          
   2390            /* Check the parameters */
   2391            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
   2392            assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
   2393          
   2394            /* Get the TIMx SMCR register value */
   2395            tmpsmcr = TIMx->SMCR;
   2396            /* Reset the TS Bits */
   2397            tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
   2398            /* Set the Input Trigger source */
   2399            tmpsmcr |= TIM_InputTriggerSource;
   2400            /* Write to TIMx SMCR */
   2401            TIMx->SMCR = tmpsmcr;
   2402          }
   2403          
   2404          /**
   2405            * @brief  Selects the TIMx Trigger Output Mode.
   2406            * @param  TIMx: where x can be 2, 3, 4, 5, 6, 7 or 9 to select the TIM peripheral.
   2407            * @param  TIM_TRGOSource: specifies the Trigger Output source.
   2408            *   This paramter can be one of the following values:
   2409            *
   2410            *  @param For all TIMx
   2411            *     @arg TIM_TRGOSource_Reset:  The UG bit in the TIM_EGR register is used as the trigger output (TRGO).
   2412            *     @arg TIM_TRGOSource_Enable: The Counter Enable CEN is used as the trigger output (TRGO).
   2413            *     @arg TIM_TRGOSource_Update: The update event is selected as the trigger output (TRGO).
   2414            *
   2415            *  @param For all TIMx except TIM6 and TIM7
   2416            *     @arg TIM_TRGOSource_OC1: The trigger output sends a positive pulse when the CC1IF flag
   2417            *                              is to be set, as soon as a capture or compare match occurs (TRGO).
   2418            *     @arg TIM_TRGOSource_OC1Ref: OC1REF signal is used as the trigger output (TRGO).
   2419          
   2420            *  @param For all TIMx except TIM6, TIM7, TIM10 and TIM11
   2421            *     @arg TIM_TRGOSource_OC2Ref: OC2REF signal is used as the trigger output (TRGO).
   2422          
   2423            *  @param For TIM2, TIM3 and TIM4
   2424            *     @arg TIM_TRGOSource_OC3Ref: OC3REF signal is used as the trigger output (TRGO).
   2425            *     @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output (TRGO).
   2426            *
   2427            * @retval None
   2428            */
   2429          void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
   2430          {
   2431            /* Check the parameters */
   2432            assert_param(IS_TIM_LIST5_PERIPH(TIMx));
   2433            assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
   2434          
   2435            /* Reset the MMS Bits */
   2436            TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
   2437            /* Select the TRGO source */
   2438            TIMx->CR2 |=  TIM_TRGOSource;
   2439          }
   2440          
   2441          /**
   2442            * @brief  Selects the TIMx Slave Mode.
   2443            * @param  TIMx: where x can be 2, 3, 4, 5 or 9 to select the TIM peripheral.
   2444            * @param  TIM_SlaveMode: specifies the Timer Slave Mode.
   2445            *   This paramter can be one of the following values:
   2446            *     @arg TIM_SlaveMode_Reset: Rising edge of the selected trigger signal (TRGI) re-initializes
   2447            *                               the counter and triggers an update of the registers.
   2448            *     @arg TIM_SlaveMode_Gated:     The counter clock is enabled when the trigger signal (TRGI) is high.
   2449            *     @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI.
   2450            *     @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter.
   2451            * @retval None
   2452            */
   2453          void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
   2454          {
   2455            /* Check the parameters */
   2456            assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
   2457            assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
   2458            
   2459            /* Reset the SMS Bits */
   2460            TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
   2461            /* Select the Slave Mode */
   2462            TIMx->SMCR |= TIM_SlaveMode;
   2463          }
   2464          
   2465          /**
   2466            * @brief  Sets or Resets the TIMx Master/Slave Mode.
   2467            * @param  TIMx: where x can be 2, 3, 4, 5 or 9 to select the TIM peripheral.
   2468            * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
   2469            *   This paramter can be one of the following values:
   2470            *     @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer
   2471            *                                      and its slaves (through TRGO).
   2472            *     @arg TIM_MasterSlaveMode_Disable: No action
   2473            * @retval None
   2474            */
   2475          void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
   2476          {
   2477            /* Check the parameters */
   2478            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2479            assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
   2480            
   2481            /* Reset the MSM Bit */
   2482            TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
   2483            
   2484            /* Set or Reset the MSM Bit */
   2485            TIMx->SMCR |= TIM_MasterSlaveMode;
   2486          }
   2487          
   2488          /**
   2489            * @brief  Configures the TIMx External Trigger (ETR).
   2490            * @param  TIMx: where x can be 2, 3, 4, 5, 9, 10 or 11 to select the TIM peripheral.
   2491            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2492            *   This parameter can be one of the following values:
   2493            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2494            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2495            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2496            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2497            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2498            *   This parameter can be one of the following values:
   2499            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2500            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2501            * @param  ExtTRGFilter: External Trigger Filter.
   2502            *   This parameter must be a value between 0x00 and 0x0F
   2503            * @retval None
   2504            */
   2505          void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
   2506                             uint16_t ExtTRGFilter)
   2507          {
   2508            uint16_t tmpsmcr = 0;
   2509            
   2510            /* Check the parameters */
   2511            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2512            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   2513            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   2514            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   2515            
   2516            tmpsmcr = TIMx->SMCR;
   2517            /* Reset the ETR Bits */
   2518            tmpsmcr &= SMCR_ETR_MASK;
   2519            /* Set the Prescaler, the Filter value and the Polarity */
   2520            tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
   2521            /* Write to TIMx SMCR */
   2522            TIMx->SMCR = tmpsmcr;
   2523          }
   2524          
   2525          /**
   2526            * @}
   2527            */
   2528          
   2529          /** @defgroup TIM_Group7 Specific interface management functions
   2530           *  @brief    Specific interface management functions 
   2531           *
   2532          @verbatim
   2533           ===============================================================================
   2534                       ##### Specific interface management functions #####
   2535           ===============================================================================
   2536          
   2537          @endverbatim
   2538            * @{
   2539            */
   2540          
   2541          /**
   2542            * @brief  Configures the TIMx Encoder Interface.
   2543            * @param  TIMx: where x can be  2, 3, 4, 5 or 9 to select the TIM peripheral.
   2544            * @note   TIM9 is supporting Encoder Interface only in STM32L1XX_MDP, STM32L1XX_HD
   2545            *         and STM32L1XX_XL devices.  
   2546            * @param  TIM_EncoderMode: specifies the TIMx Encoder Mode.
   2547            *   This parameter can be one of the following values:
   2548            *     @arg TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level.
   2549            *     @arg TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level.
   2550            *     @arg TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending
   2551            *                                on the level of the other input.
   2552            * @param  TIM_IC1Polarity: specifies the IC1 Polarity.
   2553            *   This parmeter can be one of the following values:
   2554            *     @arg TIM_ICPolarity_Falling: IC Falling edge.
   2555            *     @arg TIM_ICPolarity_Rising: IC Rising edge.
   2556            * @param  TIM_IC2Polarity: specifies the IC2 Polarity
   2557            *   This parmeter can be one of the following values:
   2558            *     @arg TIM_ICPolarity_Falling: IC Falling edge.
   2559            *     @arg TIM_ICPolarity_Rising: IC Rising edge.
   2560            * @retval None
   2561            */
   2562          void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
   2563                                          uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
   2564          {
   2565            uint16_t tmpsmcr = 0;
   2566            uint16_t tmpccmr1 = 0;
   2567            uint16_t tmpccer = 0;
   2568              
   2569            /* Check the parameters */
   2570            assert_param(IS_TIM_LIST7_PERIPH(TIMx));
   2571            assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
   2572            assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
   2573            assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
   2574            
   2575            /* Get the TIMx SMCR register value */
   2576            tmpsmcr = TIMx->SMCR;
   2577            /* Get the TIMx CCMR1 register value */
   2578            tmpccmr1 = TIMx->CCMR1;
   2579            /* Get the TIMx CCER register value */
   2580            tmpccer = TIMx->CCER;
   2581            /* Set the encoder Mode */
   2582            tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
   2583            tmpsmcr |= TIM_EncoderMode;
   2584            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2585            tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
   2586            tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
   2587            /* Set the TI1 and the TI2 Polarities */
   2588            tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
   2589             tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
   2590            /* Write to TIMx SMCR */
   2591            TIMx->SMCR = tmpsmcr;
   2592            /* Write to TIMx CCMR1 */
   2593            TIMx->CCMR1 = tmpccmr1;
   2594            /* Write to TIMx CCER */
   2595            TIMx->CCER = tmpccer;
   2596          }
   2597          
   2598          /**
   2599            * @brief  Enables or disables the TIMx's Hall sensor interface.
   2600            * @param  TIMx: where x can be 2, 3, 4 or 5 to select the TIM peripheral.
   2601            * @param  NewState: new state of the TIMx Hall sensor interface.
   2602            *   This parameter can be: ENABLE or DISABLE.
   2603            * @retval None
   2604            */
   2605          void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
   2606          {
   2607            /* Check the parameters */
   2608            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2609            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2610            
   2611            if (NewState != DISABLE)
   2612            {
   2613              /* Set the TI1S Bit */
   2614              TIMx->CR2 |= TIM_CR2_TI1S;
   2615            }
   2616            else
   2617            {
   2618              /* Reset the TI1S Bit */
   2619              TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
   2620            }
   2621          }
   2622          
   2623          /**
   2624            * @}
   2625            */
   2626          
   2627          /** @defgroup TIM_Group8 Specific remapping management function
   2628           *  @brief   Specific remapping management function
   2629           *
   2630          @verbatim
   2631           ===============================================================================
   2632                         ##### Specific remapping management function #####
   2633           ===============================================================================
   2634          
   2635          @endverbatim
   2636            * @{
   2637            */
   2638          
   2639          /**
   2640            * @brief  Configures the TIM2, TIM3, TIM9, TIM10 and TIM11 Remapping input 
   2641            *         Capabilities.
   2642            * @param  TIMx: where x can be 2, 3, 9, 10 or 11 to select the TIM peripheral.
   2643            * @param  TIM_Remap: specifies the TIM input remapping source.
   2644            *   This parameter can be one of the following values:
   2645            *     @arg TIM2_TIM10_OC: TIM2 ITR1 is connected to TIM10 output compare(default).
   2646            *     @arg TIM2_TIM5_TRGO: TIM2 ITR1 is connected to TIM5 Trigger output.
   2647            *     @arg TIM3_TIM11_OC: TIM3 ITR2 is connected to TIM11 output compare(default).
   2648            *     @arg TIM3_TIM5_TRGO: TIM3 ITR2 is connected to TIM5 Trigger output.
   2649            *     @arg TIM9_GPIO: TIM9 Channel 1 is connected to dedicated Timer pin(default).
   2650            *     @arg TIM9_LSE: TIM9 Channel 1 is connected to LSE clock.
   2651            *     @arg TIM9_TIM3_TRGO: TIM9 ITR1 is connected to TIM3 TRGO.
   2652            *     @arg TIM9_TS_IO: TIM9 ITR1 is connected to Touch Sense IO.
   2653            *     @arg TIM10_GPIO: TIM10 Channel 1 is connected to dedicated Timer pin(default).
   2654            *     @arg TIM10_LSI: TIM10 Channel 1 is connected to LSI clock.
   2655            *     @arg TIM10_LSE: TIM10 Channel 1 is connected to LSE clock.
   2656            *     @arg TIM10_RTC: TIM10 Channel 1 is connected to RTC Output event.
   2657            *     @arg TIM10_RI: TIM10 Channel 1 is connected to Routing Interface (RI).  
   2658            *     @arg TIM10_ETR_LSE: TIM10 ETR input is connected to LSE Clock.
   2659            *     @arg TIM10_ETR_TIM9_TRGO: TIM10 ETR input is connected to TIM9 Trigger Output.
   2660            *     @arg TIM11_GPIO: TIM11 Channel 1 is connected to dedicated Timer pin(default). 
   2661            *     @arg TIM11_MSI: TIM11 Channel 1 is connected to MSI clock.
   2662            *     @arg TIM11_HSE_RTC: TIM11 Channel 1 is connected to HSE_RTC clock.
   2663            *     @arg TIM11_RI: TIM11 Channel 1 is connected to Routing Interface (RI).  
   2664            *     @arg TIM11_ETR_LSE: TIM11 ETR input is connected to LSE Clock.
   2665            *     @arg TIM11_ETR_TIM9_TRGO: TIM11 ETR input is connected to TIM9 Trigger Output.
   2666            * @retval None
   2667            */
   2668          void TIM_RemapConfig(TIM_TypeDef* TIMx, uint32_t TIM_Remap)
   2669          {
   2670            /* Check the parameters */
   2671            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2672            assert_param(IS_TIM_REMAP(TIM_Remap));
   2673          
   2674            /* Set the Timer remapping configuration */
   2675            TIMx->OR &=  (uint16_t)(TIM_Remap >> 16);
   2676            TIMx->OR |=  (uint16_t)TIM_Remap;
   2677          }
   2678          
   2679          /**
   2680            * @}
   2681            */
   2682          
   2683          /**
   2684            * @brief  Configure the TI1 as Input.
   2685            * @param  TIMx: where x can be 2, 3, 4, 9, 10 or 11 to select the TIM peripheral.
   2686            * @param  TIM_ICPolarity : The Input Polarity.
   2687            *   This parameter can be one of the following values:
   2688            *     @arg TIM_ICPolarity_Rising: IC Rising edge.
   2689            *     @arg TIM_ICPolarity_Falling: IC Falling edge.
   2690            * @param  TIM_ICSelection: specifies the input to be used.
   2691            *   This parameter can be one of the following values:
   2692            *     @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   2693            *     @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   2694            *     @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
   2695            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2696            *   This parameter must be a value between 0x00 and 0x0F.
   2697            * @retval None
   2698            */
   2699          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2700                                 uint16_t TIM_ICFilter)
   2701          {
   2702            uint16_t tmpccmr1 = 0, tmpccer = 0;
   2703            
   2704            /* Disable the Channel 1: Reset the CC1E Bit */
   2705            TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
   2706            tmpccmr1 = TIMx->CCMR1;
   2707            tmpccer = TIMx->CCER;
   2708            /* Select the Input and set the filter */
   2709            tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
   2710            tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   2711            /* Select the Polarity and set the CC1E Bit */
   2712            tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
   2713            tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
   2714            /* Write to TIMx CCMR1 and CCER registers */
   2715            TIMx->CCMR1 = tmpccmr1;
   2716            TIMx->CCER = tmpccer;
   2717          }
   2718          
   2719          /**
   2720            * @brief  Configure the TI2 as Input.
   2721            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM peripheral.
   2722            * @param  TIM_ICPolarity : The Input Polarity.
   2723            *   This parameter can be one of the following values:
   2724            *     @arg TIM_ICPolarity_Rising: IC Rising edge.
   2725            *     @arg TIM_ICPolarity_Falling: IC Falling edge.
   2726            * @param  TIM_ICSelection: specifies the input to be used.
   2727            *   This parameter can be one of the following values:
   2728            *     @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   2729            *     @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   2730            *     @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
   2731            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2732            *   This parameter must be a value between 0x00 and 0x0F.
   2733            * @retval None
   2734            */
   2735          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2736                                 uint16_t TIM_ICFilter)
   2737          {
   2738            uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
   2739            
   2740            /* Disable the Channel 2: Reset the CC2E Bit */
   2741            TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
   2742            tmpccmr1 = TIMx->CCMR1;
   2743            tmpccer = TIMx->CCER;
   2744            tmp = (uint16_t)(TIM_ICPolarity << 4);
   2745            /* Select the Input and set the filter */
   2746            tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
   2747            tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
   2748            tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
   2749            /* Select the Polarity and set the CC2E Bit */
   2750            tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
   2751            tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
   2752            /* Write to TIMx CCMR1 and CCER registers */
   2753            TIMx->CCMR1 = tmpccmr1 ;
   2754            TIMx->CCER = tmpccer;
   2755          }
   2756          
   2757          /**
   2758            * @brief  Configure the TI3 as Input.
   2759            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2760            * @param  TIM_ICPolarity : The Input Polarity.
   2761            *   This parameter can be one of the following values:
   2762            *     @arg TIM_ICPolarity_Rising: IC Rising edge.
   2763            *     @arg TIM_ICPolarity_Falling: IC Falling edge.
   2764            * @param  TIM_ICSelection: specifies the input to be used.
   2765            *   This parameter can be one of the following values:
   2766            *     @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   2767            *     @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   2768            *     @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
   2769            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2770            *   This parameter must be a value between 0x00 and 0x0F.
   2771            * @retval None
   2772            */
   2773          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2774                                 uint16_t TIM_ICFilter)
   2775          {
   2776            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   2777            
   2778            /* Disable the Channel 3: Reset the CC3E Bit */
   2779            TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
   2780            tmpccmr2 = TIMx->CCMR2;
   2781            tmpccer = TIMx->CCER;
   2782            tmp = (uint16_t)(TIM_ICPolarity << 8);
   2783            /* Select the Input and set the filter */
   2784            tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
   2785            tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   2786            /* Select the Polarity and set the CC3E Bit */
   2787            tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));
   2788            tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
   2789            /* Write to TIMx CCMR2 and CCER registers */
   2790            TIMx->CCMR2 = tmpccmr2;
   2791            TIMx->CCER = tmpccer;
   2792          }
   2793          
   2794          /**
   2795            * @brief  Configure the TI4 as Input.
   2796            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2797            * @param  TIM_ICPolarity : The Input Polarity.
   2798            *   This parameter can be one of the following values:
   2799            *     @arg TIM_ICPolarity_Rising: IC Rising edge.
   2800            *     @arg TIM_ICPolarity_Falling: IC Falling edge.
   2801            * @param  TIM_ICSelection: specifies the input to be used.
   2802            *   This parameter can be one of the following values:
   2803            *     @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   2804            *     @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   2805            *     @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
   2806            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2807            *   This parameter must be a value between 0x00 and 0x0F.
   2808            * @retval None
   2809            */
   2810          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2811                                 uint16_t TIM_ICFilter)
   2812          {
   2813            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   2814            
   2815            /* Disable the Channel 4: Reset the CC4E Bit */
   2816            TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
   2817            tmpccmr2 = TIMx->CCMR2;
   2818            tmpccer = TIMx->CCER;
   2819            tmp = (uint16_t)(TIM_ICPolarity << 12);
   2820            /* Select the Input and set the filter */
   2821            tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
   2822            tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
   2823            tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
   2824          
   2825            /* Select the Polarity and set the CC4E Bit */
   2826            tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P | TIM_CCER_CC4NP));
   2827            tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
   2828            /* Write to TIMx CCMR2 and CCER registers */
   2829            TIMx->CCMR2 = tmpccmr2;
   2830            TIMx->CCER = tmpccer ;
   2831          }
   2832          
   2833          /**
   2834            * @}
   2835            */
   2836          
   2837          /**
   2838            * @}
   2839            */
   2840          
   2841          /**
   2842            * @}
   2843            */
   2844          
   2845          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   TIM_ARRPreloadConfig
       0   TIM_CCxCmd
       0   TIM_ClearFlag
       0   TIM_ClearITPendingBit
       0   TIM_ClearOC1Ref
       0   TIM_ClearOC2Ref
       0   TIM_ClearOC3Ref
       0   TIM_ClearOC4Ref
       0   TIM_Cmd
       0   TIM_CounterModeConfig
       0   TIM_DMACmd
       0   TIM_DMAConfig
       8   TIM_DeInit
         0   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB1PeriphResetCmd
         0   -> RCC_APB2PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       0   TIM_ETRClockMode1Config
       0   TIM_ETRClockMode2Config
       0   TIM_ETRConfig
      16   TIM_EncoderInterfaceConfig
       0   TIM_ForcedOC1Config
       0   TIM_ForcedOC2Config
       0   TIM_ForcedOC3Config
       0   TIM_ForcedOC4Config
       0   TIM_GenerateEvent
       0   TIM_GetCapture1
       0   TIM_GetCapture2
       0   TIM_GetCapture3
       0   TIM_GetCapture4
       0   TIM_GetCounter
       0   TIM_GetFlagStatus
       0   TIM_GetITStatus
       0   TIM_GetPrescaler
      16   TIM_ICInit
       0   TIM_ICStructInit
       0   TIM_ITConfig
       0   TIM_ITRxExternalClockConfig
       0   TIM_InternalClockConfig
       0   TIM_OC1FastConfig
       0   TIM_OC1Init
       0   TIM_OC1PolarityConfig
       0   TIM_OC1PreloadConfig
       0   TIM_OC2FastConfig
       8   TIM_OC2Init
       0   TIM_OC2PolarityConfig
       0   TIM_OC2PreloadConfig
       0   TIM_OC3FastConfig
       8   TIM_OC3Init
       0   TIM_OC3PolarityConfig
       0   TIM_OC3PreloadConfig
       0   TIM_OC4FastConfig
       8   TIM_OC4Init
       0   TIM_OC4PolarityConfig
       0   TIM_OC4PreloadConfig
       0   TIM_OCStructInit
      24   TIM_PWMIConfig
       0   TIM_PrescalerConfig
       0   TIM_RemapConfig
       0   TIM_SelectCCDMA
       0   TIM_SelectHallSensor
       0   TIM_SelectInputTrigger
       0   TIM_SelectMasterSlaveMode
       0   TIM_SelectOCREFClear
       8   TIM_SelectOCxM
       0   TIM_SelectOnePulseMode
       0   TIM_SelectOutputTrigger
       0   TIM_SelectSlaveMode
       0   TIM_SetAutoreload
       0   TIM_SetClockDivision
       0   TIM_SetCompare1
       0   TIM_SetCompare2
       0   TIM_SetCompare3
       0   TIM_SetCompare4
       0   TIM_SetCounter
       0   TIM_SetIC1Prescaler
       0   TIM_SetIC2Prescaler
       0   TIM_SetIC3Prescaler
       0   TIM_SetIC4Prescaler
      12   TIM_TIxExternalClockConfig
       0   TIM_TimeBaseInit
       0   TIM_TimeBaseStructInit
       0   TIM_UpdateDisableConfig
       0   TIM_UpdateRequestConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
      20  TIM_ARRPreloadConfig
      28  TIM_CCxCmd
       6  TIM_ClearFlag
       6  TIM_ClearITPendingBit
      14  TIM_ClearOC1Ref
      14  TIM_ClearOC2Ref
      14  TIM_ClearOC3Ref
      14  TIM_ClearOC4Ref
      20  TIM_Cmd
      14  TIM_CounterModeConfig
      16  TIM_DMACmd
       8  TIM_DMAConfig
     204  TIM_DeInit
      30  TIM_ETRClockMode1Config
      30  TIM_ETRClockMode2Config
      22  TIM_ETRConfig
      50  TIM_EncoderInterfaceConfig
      14  TIM_ForcedOC1Config
      16  TIM_ForcedOC2Config
      14  TIM_ForcedOC3Config
      16  TIM_ForcedOC4Config
       4  TIM_GenerateEvent
       4  TIM_GetCapture1
       4  TIM_GetCapture2
       4  TIM_GetCapture3
       4  TIM_GetCapture4
       4  TIM_GetCounter
      14  TIM_GetFlagStatus
      20  TIM_GetITStatus
       4  TIM_GetPrescaler
     284  TIM_ICInit
      18  TIM_ICStructInit
      16  TIM_ITConfig
      22  TIM_ITRxExternalClockConfig
      12  TIM_InternalClockConfig
      14  TIM_OC1FastConfig
      64  TIM_OC1Init
      14  TIM_OC1PolarityConfig
      14  TIM_OC1PreloadConfig
      16  TIM_OC2FastConfig
      56  TIM_OC2Init
      16  TIM_OC2PolarityConfig
      16  TIM_OC2PreloadConfig
      14  TIM_OC3FastConfig
      54  TIM_OC3Init
      16  TIM_OC3PolarityConfig
      14  TIM_OC3PreloadConfig
      16  TIM_OC4FastConfig
      56  TIM_OC4Init
      16  TIM_OC4PolarityConfig
      16  TIM_OC4PreloadConfig
      12  TIM_OCStructInit
     320  TIM_PWMIConfig
       6  TIM_PrescalerConfig
      24  TIM_RemapConfig
      20  TIM_SelectCCDMA
      20  TIM_SelectHallSensor
      14  TIM_SelectInputTrigger
      18  TIM_SelectMasterSlaveMode
      18  TIM_SelectOCREFClear
      76  TIM_SelectOCxM
      18  TIM_SelectOnePulseMode
      18  TIM_SelectOutputTrigger
      18  TIM_SelectSlaveMode
       4  TIM_SetAutoreload
      18  TIM_SetClockDivision
       4  TIM_SetCompare1
       4  TIM_SetCompare2
       4  TIM_SetCompare3
       4  TIM_SetCompare4
       4  TIM_SetCounter
      18  TIM_SetIC1Prescaler
      20  TIM_SetIC2Prescaler
      18  TIM_SetIC3Prescaler
      20  TIM_SetIC4Prescaler
     118  TIM_TIxExternalClockConfig
      74  TIM_TimeBaseInit
      16  TIM_TimeBaseStructInit
      20  TIM_UpdateDisableConfig
      20  TIM_UpdateRequestConfig

 
 2 376 bytes in section .text
 
 2 376 bytes of CODE memory

Errors: none
Warnings: none
