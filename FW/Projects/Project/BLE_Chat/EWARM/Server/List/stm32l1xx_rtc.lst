###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.60.1.5097/W32 for ARM      31/Oct/2014  21:00:47 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\FredZhou\Documents\Origin\Projects\platform\STM #
#                    32L1XX\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1x #
#                    x_rtc.c                                                  #
#    Command line =  C:\Users\FredZhou\Documents\Origin\Projects\platform\STM #
#                    32L1XX\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1x #
#                    x_rtc.c -D USE_STDPERIPH_DRIVER -D STM32L1XX_MD -D       #
#                    SYSCLK_FREQ_HSI_32MHz -D ENABLE_USB -D                   #
#                    ENABLE_USB_PRINTF -D DEBUG -D SERVER -D ACCEL_TEST -lcN  #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Server\List\ --diag_suppress Pa050 -o         #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Server\Obj\ --debug --endian=little           #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.5\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\inc\ -I "C:\Users\FredZhou\Documents\Origi #
#                    n\Projects\Project\BLE_Chat\EWARM\..\..\..\Bluetooth     #
#                    LE\SimpleBlueNRG_HCI\" -I "C:\Users\FredZhou\Documents\O #
#                    rigin\Projects\Project\BLE_Chat\EWARM\..\..\..\Bluetooth #
#                     LE\SimpleBlueNRG_HCI\includes\" -I                      #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\ -I               #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\ -I     #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\CMSIS\C #
#                    M3\DeviceSupport\ST\STM32L1xx\ -I                        #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32_U #
#                    SB-FS-Device_Driver\inc\ -I                              #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32L1 #
#                    xx_StdPeriph_Driver\inc\ -I                              #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\I2C\inc #
#                    \ -I C:\Users\FredZhou\Documents\Origin\Projects\Project #
#                    \BLE_Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\LI #
#                    S3DH\inc\ -I C:\Users\FredZhou\Documents\Origin\Projects #
#                    \Project\BLE_Chat\EWARM\..\..\..\platform\STM32L1XX\Libr #
#                    aries\STLM75\inc\ -I C:\Users\FredZhou\Documents\Origin\ #
#                    Projects\Project\BLE_Chat\EWARM\..\..\..\platform\STM32L #
#                    1XX\Libraries\HTS221\inc\ -I                             #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\LPS25H\ #
#                    inc\ -I C:\Users\FredZhou\Documents\Origin\Projects\Proj #
#                    ect\BLE_Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries #
#                    \SDK_Eval_STM32L\inc\ -Ohs --use_c++_inline -I           #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Server\List\stm32l1xx_rtc.lst                 #
#    Object file  =  C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Server\Obj\stm32l1xx_rtc.o                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\FredZhou\Documents\Origin\Projects\platform\STM32L1XX\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_rtc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_rtc.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    31-January-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Real-Time Clock (RTC) peripheral:
      9            *           + Initialization
     10            *           + Calendar (Time and Date) configuration
     11            *           + Alarms (Alarm A and Alarm B) configuration
     12            *           + WakeUp Timer configuration
     13            *           + Daylight Saving configuration
     14            *           + Output pin Configuration
     15            *           + Coarse digital Calibration configuration
     16            *           + Smooth digital Calibration configuration
     17            *           + TimeStamp configuration
     18            *           + Tampers configuration
     19            *           + Backup Data Registers configuration
     20            *           + Output Type Config configuration
     21            *           + Shift control synchronisation  
     22            *           + Interrupts and flags management       
     23            *                     
     24           @verbatim
     25          
     26           ===============================================================================
     27                                  ##### RTC Domain Reset #####
     28           ===============================================================================
     29              [..] After power-on reset, the RTC domain (RTC clock source configuration,
     30                   RTC registers and RTC Backup data registers) is reset. You can also
     31                   reset this domain by software using the RCC_RTCResetCmd() function.
     32          
     33                              ##### RTC Operating Condition #####
     34           ===============================================================================
     35              [..] As long as the supply voltage remains in the operating range, 
     36                   the RTC never stops, regardless of the device status (Run mode, 
     37                   low power modes or under reset).
     38          
     39                                 ##### RTC Domain Access #####
     40           ===============================================================================
     41              [..] After reset, the RTC domain (RTC clock source configuration,
     42                   RTC registers and RTC Backup data registers) are protected against 
     43                   possible stray write accesses. 
     44              [..] To enable access to the RTC Domain and RTC registers, proceed as follows:
     45                   (+) Enable the Power Controller (PWR) APB1 interface clock using the
     46                       RCC_APB1PeriphClockCmd() function.
     47                   (+) Enable access to RTC domain using the PWR_RTCAccessCmd() function.
     48                   (+) Select the RTC clock source using the RCC_RTCCLKConfig() function.
     49                   (+) Enable RTC Clock using the RCC_RTCCLKCmd() function.
     50          
     51                               ##### How to use this driver #####
     52           ===============================================================================
     53              [..]
     54                  (+) Enable the RTC domain access (see description in the section above)
     55                  (+) Configure the RTC Prescaler (Asynchronous and Synchronous) and
     56                      RTC hour format using the RTC_Init() function.
     57           ***Time and Date configuration ***
     58           ==================================
     59              [..]
     60                  (+) To configure the RTC Calendar (Time and Date) use the RTC_SetTime()
     61                      and RTC_SetDate() functions.
     62                  (+) To read the RTC Calendar, use the RTC_GetTime() and RTC_GetDate()
     63                      functions.
     64                  (+) To read the RTC subsecond, use the RTC_GetSubSecond() function.
     65                  (+) Use the RTC_DayLightSavingConfig() function to add or sub one
     66                      hour to the RTC Calendar.    
     67          
     68           ***Alarm configuration ***
     69           ==========================
     70              [..]
     71                  (+) To configure the RTC Alarm use the RTC_SetAlarm() function.
     72                  (+) Enable the selected RTC Alarm using the RTC_AlarmCmd() function
     73                  (+) To read the RTC Alarm, use the RTC_GetAlarm() function.
     74                  (+) To read the RTC alarm SubSecond, use the RTC_GetAlarmSubSecond() function.
     75          
     76           ***RTC Wakeup configuration ***
     77           ===============================
     78              [..]
     79                  (+) Configure the RTC Wakeup Clock source use the RTC_WakeUpClockConfig()
     80                      function.
     81                  (+) Configure the RTC WakeUp Counter using the RTC_SetWakeUpCounter() 
     82                      function.
     83                  (+) Enable the RTC WakeUp using the RTC_WakeUpCmd() function  
     84                  (+) To read the RTC WakeUp Counter register, use the RTC_GetWakeUpCounter() 
     85                      function.
     86          
     87           ***Outputs configuration ***
     88           ============================
     89              [..] The RTC has 2 different outputs:
     90                  (+) AFO_ALARM: this output is used to manage the RTC Alarm A, Alarm B
     91                      and WaKeUp signals.
     92                      To output the selected RTC signal on RTC_AF1 pin, use the 
     93                      RTC_OutputConfig() function.
     94                  (+) AFO_CALIB: this output is 512Hz signal or 1Hz.
     95                      To output the RTC Clock on RTC_AF1 pin, use the RTC_CalibOutputCmd()
     96                      function.
     97          
     98           ***Smooth digital Calibration configuration ***
     99           ===============================================
    100              [..]
    101                  (+) Configure the RTC Original Digital Calibration Value and the corresponding
    102                      calibration cycle period (32s,16s and 8s) using the RTC_SmoothCalibConfig() 
    103                      function.
    104          
    105           ***Coarse digital Calibration configuration ***
    106           ===============================================
    107              [..]
    108                  (+) Configure the RTC Coarse Calibration Value and the corresponding
    109                      sign using the RTC_CoarseCalibConfig() function.
    110                  (+) Enable the RTC Coarse Calibration using the RTC_CoarseCalibCmd() 
    111                      function.
    112          
    113           ***TimeStamp configuration ***
    114           ==============================
    115              [..]
    116                  (+) Configure the RTC_AF1 trigger and enables the RTC TimeStamp 
    117                      using the RTC_TimeStampCmd() function.
    118                  (+) To read the RTC TimeStamp Time and Date register, use the 
    119                      RTC_GetTimeStamp() function.
    120                  (+) To read the RTC TimeStamp SubSecond register, use the 
    121                      RTC_GetTimeStampSubSecond() function.
    122          
    123           ***Tamper configuration ***
    124           ===========================
    125              [..]
    126                  (+) Configure the Tamper filter count using RTC_TamperFilterConfig()
    127                      function. 
    128                  (+) Configure the RTC Tamper trigger Edge or Level according to the Tamper 
    129                      filter (if equal to 0 Edge else Level) value using the RTC_TamperConfig() 
    130                      function.
    131                  (+) Configure the Tamper sampling frequency using RTC_TamperSamplingFreqConfig()
    132                      function.
    133                  (+) Configure the Tamper precharge or discharge duration using 
    134                      RTC_TamperPinsPrechargeDuration() function.
    135                  (+) Enable the Tamper Pull-UP using RTC_TamperPullUpDisableCmd() function.
    136                  (+) Enable the RTC Tamper using the RTC_TamperCmd() function.
    137                  (+) Enable the Time stamp on Tamper detection event using  
    138                      RTC_TSOnTamperDetecCmd() function.     
    139          
    140           ***Backup Data Registers configuration ***
    141           ==========================================
    142              [..]
    143                  (+) To write to the RTC Backup Data registers, use the RTC_WriteBackupRegister()
    144                      function.  
    145                  (+) To read the RTC Backup Data registers, use the RTC_ReadBackupRegister()
    146                      function.  
    147          
    148                                 ##### RTC and low power modes #####
    149           ===============================================================================
    150              [..] The MCU can be woken up from a low power mode by an RTC alternate 
    151                   function.
    152              [..] The RTC alternate functions are the RTC alarms (Alarm A and Alarm B), 
    153                   RTC wakeup, RTC tamper event detection and RTC time stamp event detection.
    154                   These RTC alternate functions can wake up the system from the Stop 
    155                   and Standby lowpower modes.
    156                   The system can also wake up from low power modes without depending 
    157                   on an external interrupt (Auto-wakeup mode), by using the RTC alarm 
    158                   or the RTC wakeup events.
    159              [..] The RTC provides a programmable time base for waking up from the 
    160                   Stop or Standby mode at regular intervals.
    161                   Wakeup from STOP and Standby modes is possible only when the RTC 
    162                   clock source is LSE or LSI.
    163          
    164                         ##### Selection of RTC_AF1 alternate functions #####
    165           ===============================================================================
    166              [..] The RTC_AF1 pin (PC13) can be used for the following purposes:
    167                   (+) Wakeup pin 2 (WKUP2) using the PWR_WakeUpPinCmd() function.
    168                   (+) AFO_ALARM output.
    169                   (+) AFO_CALIB output.
    170                   (+) AFI_TAMPER.
    171                   (+) AFI_TIMESTAMP.
    172          
    173             +------------------------------------------------------------------------------------------+
    174             |     Pin         |AFO_ALARM |AFO_CALIB |AFI_TAMPER |AFI_TIMESTAMP | WKUP2  |ALARMOUTTYPE  |
    175             |  configuration  | ENABLED  | ENABLED  |  ENABLED  |   ENABLED    |ENABLED |  AFO_ALARM   |
    176             |  and function   |          |          |           |              |        |Configuration |
    177             |-----------------|----------|----------|-----------|--------------|--------|--------------|
    178             |   Alarm out     |          |          |           |              | Don't  |              |
    179             |   output OD     |     1    |    0     |Don't care | Don't care   | care   |      0       |
    180             |-----------------|----------|----------|-----------|--------------|--------|--------------|
    181             |   Alarm out     |          |          |           |              | Don't  |              |
    182             |   output PP     |     1    |    0     |Don't care | Don't care   | care   |      1       |
    183             |-----------------|----------|----------|-----------|--------------|--------|--------------|
    184             | Calibration out |          |          |           |              | Don't  |              |
    185             |   output PP     |     0    |    1     |Don't care | Don't care   | care   |  Don't care  |
    186             |-----------------|----------|----------|-----------|--------------|--------|--------------|
    187             |  TAMPER input   |          |          |           |              | Don't  |              |
    188             |   floating      |     0    |    0     |     1     |      0       | care   |  Don't care  |
    189             |-----------------|----------|----------|-----------|--------------|--------|--------------|
    190             |  TIMESTAMP and  |          |          |           |              | Don't  |              |
    191             |  TAMPER input   |     0    |    0     |     1     |      1       | care   |  Don't care  |
    192             |   floating      |          |          |           |              |        |              |
    193             |-----------------|----------|----------|-----------|--------------|--------|--------------|
    194             | TIMESTAMP input |          |          |           |              | Don't  |              |
    195             |    floating     |     0    |    0     |     0     |      1       | care   |  Don't care  |
    196             |-----------------|----------|----------|-----------|--------------|--------|--------------|
    197             |  Wakeup Pin 2   |     0    |    0     |     0     |      0       |   1    |  Don't care  |
    198             |-----------------|----------|----------|-----------|--------------|--------|--------------|
    199             |  Standard GPIO  |     0    |    0     |     0     |      0       |   0    |  Don't care  |
    200             +------------------------------------------------------------------------------------------+
    201          
    202           @endverbatim
    203            
    204            ******************************************************************************
    205            * @attention
    206            *
    207            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
    208            *
    209            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    210            * You may not use this file except in compliance with the License.
    211            * You may obtain a copy of the License at:
    212            *
    213            *        http://www.st.com/software_license_agreement_liberty_v2
    214            *
    215            * Unless required by applicable law or agreed to in writing, software 
    216            * distributed under the License is distributed on an "AS IS" BASIS, 
    217            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    218            * See the License for the specific language governing permissions and
    219            * limitations under the License.
    220            *
    221            ******************************************************************************
    222            */
    223          
    224          /* Includes ------------------------------------------------------------------*/
    225          #include "stm32l1xx_rtc.h"
    226          #include "stm32l1xx_rcc.h"
    227          
    228          /** @addtogroup STM32L1xx_StdPeriph_Driver
    229            * @{
    230            */
    231          
    232          /** @defgroup RTC 
    233            * @brief RTC driver modules
    234            * @{
    235            */
    236          
    237          /* Private typedef -----------------------------------------------------------*/
    238          /* Private define ------------------------------------------------------------*/
    239          
    240          /* Masks Definition */
    241          #define RTC_TR_RESERVED_MASK    ((uint32_t)0x007F7F7F)
    242          #define RTC_DR_RESERVED_MASK    ((uint32_t)0x00FFFF3F) 
    243          #define RTC_INIT_MASK           ((uint32_t)0xFFFFFFFF)  
    244          #define RTC_RSF_MASK            ((uint32_t)0xFFFFFF5F)
    245          #define RTC_FLAGS_MASK          ((uint32_t)(RTC_FLAG_TSOVF | RTC_FLAG_TSF | RTC_FLAG_WUTF | \
    246                                                      RTC_FLAG_ALRBF | RTC_FLAG_ALRAF | RTC_FLAG_INITF | \
    247                                                      RTC_FLAG_RSF | RTC_FLAG_INITS | RTC_FLAG_WUTWF | \
    248                                                      RTC_FLAG_ALRBWF | RTC_FLAG_ALRAWF | RTC_FLAG_TAMP1F | \
    249                                                      RTC_FLAG_TAMP2F | RTC_FLAG_TAMP3F | RTC_FLAG_RECALPF | \
    250                                                      RTC_FLAG_SHPF))
    251          
    252          #define INITMODE_TIMEOUT         ((uint32_t) 0x00002000)
    253          #define SYNCHRO_TIMEOUT          ((uint32_t) 0x00008000)
    254          #define RECALPF_TIMEOUT          ((uint32_t) 0x00001000)
    255          #define SHPF_TIMEOUT             ((uint32_t) 0x00002000)
    256          
    257          /* Private macro -------------------------------------------------------------*/
    258          /* Private variables ---------------------------------------------------------*/
    259          /* Private function prototypes -----------------------------------------------*/
    260          static uint8_t RTC_ByteToBcd2(uint8_t Value);
    261          static uint8_t RTC_Bcd2ToByte(uint8_t Value);
    262          
    263          /* Private functions ---------------------------------------------------------*/
    264          
    265          /** @defgroup RTC_Private_Functions
    266            * @{
    267            */ 
    268          
    269          /** @defgroup RTC_Group1 Initialization and Configuration functions
    270           *  @brief   Initialization and Configuration functions 
    271           *
    272          @verbatim
    273           ===============================================================================
    274                      ##### Initialization and Configuration functions #####
    275           ===============================================================================
    276              [..] This section provide functions allowing to initialize and configure the 
    277                   RTC Prescaler (Synchronous and Asynchronous), RTC Hour format, disable 
    278                   RTC registers Write protection, enter and exit the RTC initialization mode, 
    279                   RTC registers synchronization check and reference clock detection enable.
    280                   (#) The RTC Prescaler is programmed to generate the RTC 1Hz time base. 
    281                       It is split into 2 programmable prescalers to minimize power consumption.
    282                       (++) A 7-bit asynchronous prescaler and A 13-bit synchronous prescaler.
    283                       (++) When both prescalers are used, it is recommended to configure the 
    284                           asynchronous prescaler to a high value to minimize consumption.
    285                   (#) All RTC registers are Write protected. Writing to the RTC registers
    286                       is enabled by writing a key into the Write Protection register, RTC_WPR.
    287                   (#) To Configure the RTC Calendar, user application should enter 
    288                       initialization mode. In this mode, the calendar counter is stopped 
    289                       and its value can be updated. When the initialization sequence is 
    290                       complete, the calendar restarts counting after 4 RTCCLK cycles.
    291                   (#) To read the calendar through the shadow registers after Calendar 
    292                       initialization, calendar update or after wakeup from low power modes 
    293                       the software must first clear the RSF flag. The software must then 
    294                       wait until it is set again before reading the calendar, which means 
    295                       that the calendar registers have been correctly copied into the 
    296                       RTC_TR and RTC_DR shadow registers.The RTC_WaitForSynchro() function 
    297                       implements the above software sequence (RSF clear and RSF check).
    298          
    299          @endverbatim
    300            * @{
    301            */
    302          
    303          /**
    304            * @brief  Deinitializes the RTC registers to their default reset values.
    305            * @note   This function doesn't reset the RTC Clock source and RTC Backup Data
    306            *         registers.       
    307            * @param  None
    308            * @retval An ErrorStatus enumeration value:
    309            *          - SUCCESS: RTC registers are deinitialized
    310            *          - ERROR: RTC registers are not deinitialized
    311            */
    312          ErrorStatus RTC_DeInit(void)
    313          {
    314            __IO uint32_t wutcounter = 0x00;
    315            uint32_t wutwfstatus = 0x00;
    316            ErrorStatus status = ERROR;
    317            
    318            /* Disable the write protection for RTC registers */
    319            RTC->WPR = 0xCA;
    320            RTC->WPR = 0x53;
    321          
    322            /* Set Initialization mode */
    323            if (RTC_EnterInitMode() == ERROR)
    324            {
    325              status = ERROR;
    326            }  
    327            else
    328            {
    329              /* Reset TR, DR and CR registers */
    330              RTC->TR = (uint32_t)0x00000000;
    331              RTC->DR = (uint32_t)0x00002101;
    332              
    333              /* Reset All CR bits except CR[2:0] */
    334              RTC->CR &= (uint32_t)0x00000007;
    335            
    336              /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    337              do
    338              {
    339                wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
    340                wutcounter++;  
    341              } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
    342              
    343              if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
    344              {
    345                status = ERROR;
    346              }
    347              else
    348              {
    349                /* Reset all RTC CR register bits */
    350                RTC->CR        &= (uint32_t)0x00000000;
    351                RTC->WUTR      = (uint32_t)0x0000FFFF;
    352                RTC->PRER      = (uint32_t)0x007F00FF;
    353                RTC->CALIBR    = (uint32_t)0x00000000;
    354                RTC->ALRMAR    = (uint32_t)0x00000000;
    355                RTC->ALRMBR    = (uint32_t)0x00000000;
    356                RTC->SHIFTR    = (uint32_t)0x00000000;
    357                RTC->CALR       = (uint32_t)0x00000000;
    358                RTC->ALRMASSR  = (uint32_t)0x00000000;
    359                RTC->ALRMBSSR  = (uint32_t)0x00000000;
    360          
    361                /* Reset ISR register and exit initialization mode */
    362                RTC->ISR = (uint32_t)0x00000000;
    363                
    364                /* Reset Tamper and alternate functions configuration register */
    365                RTC->TAFCR = 0x00000000;
    366                
    367                /* Wait till the RTC RSF flag is set */
    368                if (RTC_WaitForSynchro() == ERROR)
    369                {
    370                  status = ERROR;
    371                }
    372                else
    373                {
    374                  status = SUCCESS;
    375                }
    376              }
    377            }
    378            
    379            /* Enable the write protection for RTC registers */
    380            RTC->WPR = 0xFF;  
    381            
    382            return status;
    383          }
    384          
    385          /**
    386            * @brief  Initializes the RTC registers according to the specified parameters 
    387            *         in RTC_InitStruct.
    388            * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure that contains 
    389            *         the configuration information for the RTC peripheral.
    390            * @note   The RTC Prescaler register is write protected and can be written in 
    391            *         initialization mode only.  
    392            * @retval An ErrorStatus enumeration value:
    393            *          - SUCCESS: RTC registers are initialized
    394            *          - ERROR: RTC registers are not initialized  
    395            */
    396          ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
    397          {
    398            ErrorStatus status = ERROR;
    399            
    400            /* Check the parameters */
    401            assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
    402            assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
    403            assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
    404          
    405            /* Disable the write protection for RTC registers */
    406            RTC->WPR = 0xCA;
    407            RTC->WPR = 0x53;
    408          
    409            /* Set Initialization mode */
    410            if (RTC_EnterInitMode() == ERROR)
    411            {
    412              status = ERROR;
    413            } 
    414            else
    415            {
    416              /* Clear RTC CR FMT Bit */
    417              RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
    418              /* Set RTC_CR register */
    419              RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
    420            
    421              /* Configure the RTC PRER */
    422              RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
    423              RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
    424          
    425              /* Exit Initialization mode */
    426              RTC_ExitInitMode();
    427          
    428              status = SUCCESS;    
    429            }
    430            /* Enable the write protection for RTC registers */
    431            RTC->WPR = 0xFF; 
    432            
    433            return status;
    434          }
    435          
    436          /**
    437            * @brief  Fills each RTC_InitStruct member with its default value.
    438            * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure which will be 
    439            *         initialized.
    440            * @retval None
    441            */
    442          void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
    443          {
    444            /* Initialize the RTC_HourFormat member */
    445            RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
    446              
    447            /* Initialize the RTC_AsynchPrediv member */
    448            RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
    449          
    450            /* Initialize the RTC_SynchPrediv member */
    451            RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
    452          }
    453          
    454          /**
    455            * @brief  Enables or disables the RTC registers write protection.
    456            * @note   All the RTC registers are write protected except for RTC_ISR[13:8], 
    457            *         RTC_TAFCR and RTC_BKPxR.
    458            * @note   Writing a wrong key reactivates the write protection.
    459            * @note   The protection mechanism is not affected by system reset.  
    460            * @param  NewState: new state of the write protection.
    461            *   This parameter can be: ENABLE or DISABLE.
    462            * @retval None
    463            */
    464          void RTC_WriteProtectionCmd(FunctionalState NewState)
    465          {
    466            /* Check the parameters */
    467            assert_param(IS_FUNCTIONAL_STATE(NewState));
    468              
    469            if (NewState != DISABLE)
    470            {
    471              /* Enable the write protection for RTC registers */
    472              RTC->WPR = 0xFF;   
    473            }
    474            else
    475            {
    476              /* Disable the write protection for RTC registers */
    477              RTC->WPR = 0xCA;
    478              RTC->WPR = 0x53;    
    479            }
    480          }
    481          
    482          /**
    483            * @brief  Enters the RTC Initialization mode.
    484            * @note   The RTC Initialization mode is write protected, use the 
    485            *         RTC_WriteProtectionCmd(DISABLE) before calling this function.    
    486            * @param  None
    487            * @retval An ErrorStatus enumeration value:
    488            *          - SUCCESS: RTC is in Init mode
    489            *          - ERROR: RTC is not in Init mode  
    490            */
    491          ErrorStatus RTC_EnterInitMode(void)
    492          {
    493            __IO uint32_t initcounter = 0x00;
    494            ErrorStatus status = ERROR;
    495            uint32_t initstatus = 0x00;
    496               
    497            /* Check if the Initialization mode is set */
    498            if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
    499            {
    500              /* Set the Initialization mode */
    501              RTC->ISR = (uint32_t)RTC_INIT_MASK;
    502              
    503              /* Wait till RTC is in INIT state and if Time out is reached exit */
    504              do
    505              {
    506                initstatus = RTC->ISR & RTC_ISR_INITF;
    507                initcounter++;  
    508              } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
    509              
    510              if ((RTC->ISR & RTC_ISR_INITF) != RESET)
    511              {
    512                status = SUCCESS;
    513              }
    514              else
    515              {
    516                status = ERROR;
    517              }        
    518            }
    519            else
    520            {
    521              status = SUCCESS;  
    522            } 
    523              
    524            return (status);  
    525          }
    526          
    527          /**
    528            * @brief  Exits the RTC Initialization mode.
    529            * @note   When the initialization sequence is complete, the calendar restarts 
    530            *         counting after 4 RTCCLK cycles.  
    531            * @note   The RTC Initialization mode is write protected, use the 
    532            *         RTC_WriteProtectionCmd(DISABLE) before calling this function.      
    533            * @param  None
    534            * @retval None
    535            */
    536          void RTC_ExitInitMode(void)
    537          {
    538            /* Exit Initialization mode */
    539            RTC->ISR &= (uint32_t)~RTC_ISR_INIT;
    540          }
    541          
    542          /**
    543            * @brief  Waits until the RTC Time and Date registers (RTC_TR and RTC_DR) are 
    544            *         synchronized with RTC APB clock.
    545            * @note   The RTC Resynchronization mode is write protected, use the 
    546            *         RTC_WriteProtectionCmd(DISABLE) before calling this function. 
    547            * @note   To read the calendar through the shadow registers after Calendar 
    548            *         initialization, calendar update or after wakeup from low power modes 
    549            *         the software must first clear the RSF flag. 
    550            *         The software must then wait until it is set again before reading 
    551            *         the calendar, which means that the calendar registers have been 
    552            *         correctly copied into the RTC_TR and RTC_DR shadow registers.   
    553            * @param  None
    554            * @retval An ErrorStatus enumeration value:
    555            *          - SUCCESS: RTC registers are synchronised
    556            *          - ERROR: RTC registers are not synchronised
    557            */
    558          ErrorStatus RTC_WaitForSynchro(void)
    559          {
    560            __IO uint32_t synchrocounter = 0;
    561            ErrorStatus status = ERROR;
    562            uint32_t synchrostatus = 0x00;
    563          
    564            /* Disable the write protection for RTC registers */
    565            RTC->WPR = 0xCA;
    566            RTC->WPR = 0x53;
    567              
    568            /* Clear RSF flag */
    569            RTC->ISR &= (uint32_t)RTC_RSF_MASK;
    570              
    571            /* Wait the registers to be synchronised */
    572            do
    573            {
    574              synchrostatus = RTC->ISR & RTC_ISR_RSF;
    575              synchrocounter++;  
    576            } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
    577              
    578            if ((RTC->ISR & RTC_ISR_RSF) != RESET)
    579            {
    580              status = SUCCESS;
    581            }
    582            else
    583            {
    584              status = ERROR;
    585            }
    586          
    587            /* Enable the write protection for RTC registers */
    588            RTC->WPR = 0xFF;
    589              
    590            return (status);
    591          }
    592          
    593          /**
    594            * @brief  Enables or disables the RTC reference clock detection.
    595            * @param  NewState: new state of the RTC reference clock.
    596            *   This parameter can be: ENABLE or DISABLE.
    597            * @retval An ErrorStatus enumeration value:
    598            *          - SUCCESS: RTC reference clock detection is enabled
    599            *          - ERROR: RTC reference clock detection is disabled  
    600            */
    601          ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
    602          {
    603            ErrorStatus status = ERROR;
    604          
    605            /* Check the parameters */
    606            assert_param(IS_FUNCTIONAL_STATE(NewState));
    607          
    608            /* Disable the write protection for RTC registers */
    609            RTC->WPR = 0xCA;
    610            RTC->WPR = 0x53;
    611          
    612            /* Set Initialization mode */
    613            if (RTC_EnterInitMode() == ERROR)
    614            {
    615              status = ERROR;
    616            }
    617            else
    618            {
    619              if (NewState != DISABLE)
    620              {
    621                /* Enable the RTC reference clock detection */
    622                RTC->CR |= RTC_CR_REFCKON;   
    623              }
    624              else
    625              {
    626                /* Disable the RTC reference clock detection */
    627                RTC->CR &= ~RTC_CR_REFCKON;    
    628              }
    629              /* Exit Initialization mode */
    630              RTC_ExitInitMode();
    631          
    632              status = SUCCESS;
    633            }
    634          
    635            /* Enable the write protection for RTC registers */
    636            RTC->WPR = 0xFF;
    637          
    638            return status;
    639          }
    640          
    641          /**
    642            * @brief  Enables or Disables the Bypass Shadow feature.
    643            * @note   When the Bypass Shadow is enabled the calendar value are taken 
    644            *         directly from the Calendar counter.
    645            * @param  NewState: new state of the Bypass Shadow feature.
    646            *         This parameter can be: ENABLE or DISABLE.
    647            * @retval None
    648          */
    649          void RTC_BypassShadowCmd(FunctionalState NewState)
    650          {
    651            /* Check the parameters */
    652            assert_param(IS_FUNCTIONAL_STATE(NewState));
    653          
    654            /* Disable the write protection for RTC registers */
    655            RTC->WPR = 0xCA;
    656            RTC->WPR = 0x53;
    657            
    658            if (NewState != DISABLE)
    659            {
    660              /* Set the BYPSHAD bit */
    661              RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
    662            }
    663            else
    664            {
    665              /* Reset the BYPSHAD bit */
    666              RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
    667            }
    668          
    669            /* Enable the write protection for RTC registers */
    670            RTC->WPR = 0xFF;
    671          }
    672          
    673          /**
    674            * @}
    675            */
    676          
    677          /** @defgroup RTC_Group2 Time and Date configuration functions
    678           *  @brief   Time and Date configuration functions 
    679           *
    680          @verbatim
    681           ===============================================================================
    682                         ##### Time and Date configuration functions #####
    683           ===============================================================================
    684              [..] This section provide functions allowing to program and read the RTC 
    685                   Calendar (Time and Date).
    686          
    687          @endverbatim
    688            * @{
    689            */
    690          
    691          /**
    692            * @brief  Set the RTC current time.
    693            * @param  RTC_Format: specifies the format of the entered parameters.
    694            *   This parameter can be  one of the following values:
    695            *     @arg RTC_Format_BIN:  Binary data format.
    696            *     @arg RTC_Format_BCD:  BCD data format.
    697            * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that contains 
    698            *                        the time configuration information for the RTC.
    699            * @retval An ErrorStatus enumeration value:
    700            *          - SUCCESS: RTC Time register is configured
    701            *          - ERROR: RTC Time register is not configured
    702            */
    703          ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
    704          {
    705            uint32_t tmpreg = 0;
    706            ErrorStatus status = ERROR;
    707              
    708            /* Check the parameters */
    709            assert_param(IS_RTC_FORMAT(RTC_Format));
    710            
    711            if (RTC_Format == RTC_Format_BIN)
    712            {
    713              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
    714              {
    715                assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
    716                assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
    717              } 
    718              else
    719              {
    720                RTC_TimeStruct->RTC_H12 = 0x00;
    721                assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
    722              }
    723              assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
    724              assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
    725            }
    726            else
    727            {
    728              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
    729              {
    730                tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
    731                assert_param(IS_RTC_HOUR12(tmpreg));
    732                assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
    733              } 
    734              else
    735              {
    736                RTC_TimeStruct->RTC_H12 = 0x00;
    737                assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
    738              }
    739              assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
    740              assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
    741            }
    742            
    743            /* Check the input parameters format */
    744            if (RTC_Format != RTC_Format_BIN)
    745            {
    746              tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
    747                       ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
    748                       ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
    749                       ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
    750            }  
    751            else
    752            {
    753              tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
    754                             ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
    755                             ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
    756                             (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
    757            }  
    758          
    759            /* Disable the write protection for RTC registers */
    760            RTC->WPR = 0xCA;
    761            RTC->WPR = 0x53;
    762          
    763            /* Set Initialization mode */
    764            if (RTC_EnterInitMode() == ERROR)
    765            {
    766              status = ERROR;
    767            } 
    768            else
    769            {
    770              /* Set the RTC_TR register */
    771              RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
    772          
    773              /* Exit Initialization mode */
    774              RTC_ExitInitMode(); 
    775          
    776              /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    777              if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
    778              {
    779                if (RTC_WaitForSynchro() == ERROR)
    780                {
    781                  status = ERROR;
    782                }
    783                else
    784                {
    785                  status = SUCCESS;
    786                }
    787              }
    788              else
    789              {
    790                status = SUCCESS;
    791              }
    792            
    793            }
    794            /* Enable the write protection for RTC registers */
    795            RTC->WPR = 0xFF;
    796              
    797            return status;
    798          }
    799          
    800          /**
    801            * @brief  Fills each RTC_TimeStruct member with its default value
    802            *         (Time = 00h:00min:00sec).
    803            * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure which will be 
    804            *         initialized.
    805            * @retval None
    806            */
    807          void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
    808          {
    809            /* Time = 00h:00min:00sec */
    810            RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
    811            RTC_TimeStruct->RTC_Hours = 0;
    812            RTC_TimeStruct->RTC_Minutes = 0;
    813            RTC_TimeStruct->RTC_Seconds = 0; 
    814          }
    815          
    816          /**
    817            * @brief  Get the RTC current Time.
    818            * @param  RTC_Format: specifies the format of the returned parameters.
    819            *   This parameter can be  one of the following values:
    820            *     @arg RTC_Format_BIN:  Binary data format.
    821            *     @arg RTC_Format_BCD:  BCD data format.
    822            * @param RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
    823            *                        contain the returned current time configuration.
    824            * @retval None
    825            */
    826          void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
    827          {
    828            uint32_t tmpreg = 0;
    829          
    830            /* Check the parameters */
    831            assert_param(IS_RTC_FORMAT(RTC_Format));
    832          
    833            /* Get the RTC_TR register */
    834            tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
    835            
    836            /* Fill the structure fields with the read parameters */
    837            RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
    838            RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
    839            RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
    840            RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
    841          
    842            /* Check the input parameters format */
    843            if (RTC_Format == RTC_Format_BIN)
    844            {
    845              /* Convert the structure parameters to Binary format */
    846              RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
    847              RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
    848              RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
    849            }
    850          }
    851          
    852          /**
    853            * @brief  Gets the RTC current Calendar Subseconds value.
    854            * @param  None
    855            * @retval RTC current Calendar Subseconds value.
    856            */
    857          uint32_t RTC_GetSubSecond(void)
    858          {
    859            uint32_t tmpreg = 0;
    860            
    861            /* Get subseconds values from the correspondent registers*/
    862            tmpreg = (uint32_t)(RTC->SSR);
    863            
    864            /* Read DR register to unfroze calendar registers */
    865            (void) (RTC->DR);
    866            
    867            return (tmpreg);
    868          }
    869          
    870          /**
    871            * @brief  Set the RTC current date.
    872            * @param  RTC_Format: specifies the format of the entered parameters.
    873            *   This parameter can be  one of the following values:
    874            *     @arg RTC_Format_BIN:  Binary data format.
    875            *     @arg RTC_Format_BCD:  BCD data format.
    876            * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure that contains 
    877            *                         the date configuration information for the RTC.
    878            * @retval An ErrorStatus enumeration value:
    879            *          - SUCCESS: RTC Date register is configured
    880            *          - ERROR: RTC Date register is not configured
    881            */
    882          ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
    883          {
    884            uint32_t tmpreg = 0;
    885            ErrorStatus status = ERROR;
    886            
    887            /* Check the parameters */
    888            assert_param(IS_RTC_FORMAT(RTC_Format));
    889          
    890            if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
    891            {
    892              RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
    893            }  
    894            if (RTC_Format == RTC_Format_BIN)
    895            {
    896              assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
    897              assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
    898              assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
    899            }
    900            else
    901            {
    902              assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
    903              tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
    904              assert_param(IS_RTC_MONTH(tmpreg));
    905              tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
    906              assert_param(IS_RTC_DATE(tmpreg));
    907            }
    908            assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
    909          
    910            /* Check the input parameters format */
    911            if (RTC_Format != RTC_Format_BIN)
    912            {
    913              tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
    914                        (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
    915                        ((uint32_t)RTC_DateStruct->RTC_Date) | \
    916                        (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
    917            }  
    918            else
    919            {
    920              tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
    921                        ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
    922                        ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
    923                        ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
    924            }
    925          
    926            /* Disable the write protection for RTC registers */
    927            RTC->WPR = 0xCA;
    928            RTC->WPR = 0x53;
    929          
    930            /* Set Initialization mode */
    931            if (RTC_EnterInitMode() == ERROR)
    932            {
    933              status = ERROR;
    934            } 
    935            else
    936            {
    937              /* Set the RTC_DR register */
    938              RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
    939          
    940              /* Exit Initialization mode */
    941              RTC_ExitInitMode(); 
    942          
    943              /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    944              if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
    945              {
    946                if (RTC_WaitForSynchro() == ERROR)
    947                {
    948                  status = ERROR;
    949                }
    950                else
    951                {
    952                  status = SUCCESS;
    953                }
    954              }
    955              else
    956              {
    957                status = SUCCESS;
    958              }
    959            }
    960            /* Enable the write protection for RTC registers */
    961            RTC->WPR = 0xFF;
    962            
    963            return status;
    964          }
    965          
    966          /**
    967            * @brief  Fills each RTC_DateStruct member with its default value
    968            *         (Monday, January 01 xx00).
    969            * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure which will be 
    970            *         initialized.
    971            * @retval None
    972            */
    973          void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
    974          {
    975            /* Monday, January 01 xx00 */
    976            RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
    977            RTC_DateStruct->RTC_Date = 1;
    978            RTC_DateStruct->RTC_Month = RTC_Month_January;
    979            RTC_DateStruct->RTC_Year = 0;
    980          }
    981          
    982          /**
    983            * @brief  Get the RTC current date.
    984            * @param  RTC_Format: specifies the format of the returned parameters.
    985            *   This parameter can be one of the following values:
    986            *     @arg RTC_Format_BIN: Binary data format.
    987            *     @arg RTC_Format_BCD: BCD data format.
    988            * @param RTC_DateStruct: pointer to a RTC_DateTypeDef structure that will 
    989            *                        contain the returned current date configuration.
    990            * @retval None
    991            */
    992          void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
    993          {
    994            uint32_t tmpreg = 0;
    995          
    996            /* Check the parameters */
    997            assert_param(IS_RTC_FORMAT(RTC_Format));
    998            
    999            /* Get the RTC_TR register */
   1000            tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
   1001          
   1002            /* Fill the structure fields with the read parameters */
   1003            RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
   1004            RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
   1005            RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
   1006            RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);  
   1007          
   1008            /* Check the input parameters format */
   1009            if (RTC_Format == RTC_Format_BIN)
   1010            {
   1011              /* Convert the structure parameters to Binary format */
   1012              RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
   1013              RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
   1014              RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);   
   1015            }
   1016          }
   1017          
   1018          /**
   1019            * @}
   1020            */
   1021          
   1022          /** @defgroup RTC_Group3 Alarms configuration functions
   1023           *  @brief   Alarms (Alarm A and Alarm B) configuration functions 
   1024           *
   1025          @verbatim
   1026           ===============================================================================
   1027                   ##### Alarms (Alarm A and Alarm B) configuration functions #####
   1028           ===============================================================================
   1029              [..] This section provide functions allowing to program and read the RTC 
   1030                   Alarms.
   1031          
   1032          @endverbatim
   1033            * @{
   1034            */
   1035          
   1036          /**
   1037            * @brief  Set the specified RTC Alarm.
   1038            * @note   The Alarm register can only be written when the corresponding Alarm
   1039            *         is disabled (Use the RTC_AlarmCmd(DISABLE)).    
   1040            * @param  RTC_Format: specifies the format of the returned parameters.
   1041            *   This parameter can be one of the following values:
   1042            *     @arg RTC_Format_BIN: Binary data format.
   1043            *     @arg RTC_Format_BCD: BCD data format.
   1044            * @param  RTC_Alarm: specifies the alarm to be configured.
   1045            *   This parameter can be one of the following values:
   1046            *     @arg RTC_Alarm_A: to select Alarm A.
   1047            *     @arg RTC_Alarm_B: to select Alarm B.
   1048            * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
   1049            *                          contains the alarm configuration parameters.
   1050            * @retval None
   1051            */
   1052          void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
   1053          {
   1054            uint32_t tmpreg = 0;
   1055            
   1056            /* Check the parameters */
   1057            assert_param(IS_RTC_FORMAT(RTC_Format));
   1058            assert_param(IS_RTC_ALARM(RTC_Alarm));
   1059            assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
   1060            assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
   1061          
   1062            if (RTC_Format == RTC_Format_BIN)
   1063            {
   1064              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   1065              {
   1066                assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   1067                assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
   1068              } 
   1069              else
   1070              {
   1071                RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
   1072                assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   1073              }
   1074              assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
   1075              assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
   1076              
   1077              if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
   1078              {
   1079                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   1080              }
   1081              else
   1082              {
   1083                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   1084              }
   1085            }
   1086            else
   1087            {
   1088              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   1089              {
   1090                tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
   1091                assert_param(IS_RTC_HOUR12(tmpreg));
   1092                assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
   1093              } 
   1094              else
   1095              {
   1096                RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
   1097                assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
   1098              }
   1099              
   1100              assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
   1101              assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
   1102              
   1103              if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
   1104              {
   1105                tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   1106                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
   1107              }
   1108              else
   1109              {
   1110                tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   1111                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
   1112              }    
   1113            }
   1114          
   1115            /* Check the input parameters format */
   1116            if (RTC_Format != RTC_Format_BIN)
   1117            {
   1118              tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
   1119                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
   1120                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
   1121                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
   1122                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
   1123                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
   1124                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
   1125            }  
   1126            else
   1127            {
   1128              tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
   1129                        ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
   1130                        ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
   1131                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
   1132                        ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
   1133                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
   1134                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
   1135            } 
   1136          
   1137            /* Disable the write protection for RTC registers */
   1138            RTC->WPR = 0xCA;
   1139            RTC->WPR = 0x53;
   1140          
   1141            /* Configure the Alarm register */
   1142            if (RTC_Alarm == RTC_Alarm_A)
   1143            {
   1144              RTC->ALRMAR = (uint32_t)tmpreg;
   1145            }
   1146            else
   1147            {
   1148              RTC->ALRMBR = (uint32_t)tmpreg;
   1149            }
   1150          
   1151            /* Enable the write protection for RTC registers */
   1152            RTC->WPR = 0xFF;   
   1153          }
   1154          
   1155          /**
   1156            * @brief  Fills each RTC_AlarmStruct member with its default value
   1157            *         (Time = 00h:00mn:00sec / Date = 1st day of the month/Mask =
   1158            *         all fields are masked).
   1159            * @param  RTC_AlarmStruct: pointer to a @ref RTC_AlarmTypeDef structure which
   1160            *         will be initialized.
   1161            * @retval None
   1162            */
   1163          void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
   1164          {
   1165            /* Alarm Time Settings : Time = 00h:00mn:00sec */
   1166            RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
   1167            RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
   1168            RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
   1169            RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
   1170          
   1171            /* Alarm Date Settings : Date = 1st day of the month */
   1172            RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
   1173            RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
   1174          
   1175            /* Alarm Masks Settings : Mask =  all fields are not masked */
   1176            RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
   1177          }
   1178          
   1179          /**
   1180            * @brief  Get the RTC Alarm value and masks.
   1181            * @param  RTC_Format: specifies the format of the output parameters.
   1182            *   This parameter can be one of the following values:
   1183            *     @arg RTC_Format_BIN: Binary data format.
   1184            *     @arg RTC_Format_BCD: BCD data format.
   1185            * @param  RTC_Alarm: specifies the alarm to be read.
   1186            *   This parameter can be one of the following values:
   1187            *     @arg RTC_Alarm_A: to select Alarm A.
   1188            *     @arg RTC_Alarm_B: to select Alarm B.
   1189            * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
   1190            *                          contains the output alarm configuration values.     
   1191            * @retval None
   1192            */
   1193          void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
   1194          {
   1195            uint32_t tmpreg = 0;
   1196          
   1197            /* Check the parameters */
   1198            assert_param(IS_RTC_FORMAT(RTC_Format));
   1199            assert_param(IS_RTC_ALARM(RTC_Alarm)); 
   1200          
   1201            /* Get the RTC_ALRMxR register */
   1202            if (RTC_Alarm == RTC_Alarm_A)
   1203            {
   1204              tmpreg = (uint32_t)(RTC->ALRMAR);
   1205            }
   1206            else
   1207            {
   1208              tmpreg = (uint32_t)(RTC->ALRMBR);
   1209            }
   1210          
   1211            /* Fill the structure with the read parameters */
   1212            RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
   1213                                                               RTC_ALRMAR_HU)) >> 16);
   1214            RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
   1215                                                               RTC_ALRMAR_MNU)) >> 8);
   1216            RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
   1217                                                               RTC_ALRMAR_SU));
   1218            RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
   1219            RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
   1220            RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
   1221            RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
   1222          
   1223            if (RTC_Format == RTC_Format_BIN)
   1224            {
   1225              RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
   1226                                                                  RTC_AlarmTime.RTC_Hours);
   1227              RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
   1228                                                                  RTC_AlarmTime.RTC_Minutes);
   1229              RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
   1230                                                                  RTC_AlarmTime.RTC_Seconds);
   1231              RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   1232            }  
   1233          }
   1234          
   1235          /**
   1236            * @brief  Enables or disables the specified RTC Alarm.
   1237            * @param  RTC_Alarm: specifies the alarm to be configured.
   1238            *   This parameter can be any combination of the following values:
   1239            *     @arg RTC_Alarm_A: to select Alarm A.
   1240            *     @arg RTC_Alarm_B: to select Alarm B.
   1241            * @param  NewState: new state of the specified alarm.
   1242            *   This parameter can be: ENABLE or DISABLE.
   1243            * @retval An ErrorStatus enumeration value:
   1244            *          - SUCCESS: RTC Alarm is enabled/disabled
   1245            *          - ERROR: RTC Alarm is not enabled/disabled  
   1246            */
   1247          ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
   1248          {
   1249            __IO uint32_t alarmcounter = 0x00;
   1250            uint32_t alarmstatus = 0x00;
   1251            ErrorStatus status = ERROR;
   1252              
   1253            /* Check the parameters */
   1254            assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
   1255            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1256          
   1257            /* Disable the write protection for RTC registers */
   1258            RTC->WPR = 0xCA;
   1259            RTC->WPR = 0x53;
   1260          
   1261            /* Configure the Alarm state */
   1262            if (NewState != DISABLE)
   1263            {
   1264              RTC->CR |= (uint32_t)RTC_Alarm;
   1265          
   1266              status = SUCCESS;    
   1267            }
   1268            else
   1269            { 
   1270              /* Disable the Alarm in RTC_CR register */
   1271              RTC->CR &= (uint32_t)~RTC_Alarm;
   1272             
   1273              /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
   1274              do
   1275              {
   1276                alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
   1277                alarmcounter++;  
   1278              } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
   1279              
   1280              if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
   1281              {
   1282                status = ERROR;
   1283              } 
   1284              else
   1285              {
   1286                status = SUCCESS;
   1287              }        
   1288            } 
   1289          
   1290            /* Enable the write protection for RTC registers */
   1291            RTC->WPR = 0xFF;
   1292            
   1293            return status;
   1294          }
   1295          
   1296          /**
   1297            * @brief  Configure the RTC AlarmA/B Subseconds value and mask.*
   1298            * @note   This function is performed only when the Alarm is disabled. 
   1299            * @param  RTC_Alarm: specifies the alarm to be configured.
   1300            *   This parameter can be one of the following values:
   1301            *     @arg RTC_Alarm_A: to select Alarm A.
   1302            *     @arg RTC_Alarm_B: to select Alarm B.
   1303            * @param  RTC_AlarmSubSecondValue: specifies the Subseconds value.
   1304            *   This parameter can be a value from 0 to 0x00007FFF.
   1305            * @param  RTC_AlarmSubSecondMask:  specifies the Subseconds Mask.
   1306            *   This parameter can be any combination of the following values:
   1307            *     @arg RTC_AlarmSubSecondMask_All: All Alarm SS fields are masked.
   1308            *                                      There is no comparison on sub seconds for Alarm.
   1309            *     @arg RTC_AlarmSubSecondMask_SS14_1: SS[14:1] are don't care in Alarm comparison.
   1310            *                                         Only SS[0] is compared
   1311            *     @arg RTC_AlarmSubSecondMask_SS14_2: SS[14:2] are don't care in Alarm comparison.
   1312            *                                          Only SS[1:0] are compared
   1313            *     @arg RTC_AlarmSubSecondMask_SS14_3: SS[14:3] are don't care in Alarm comparison.
   1314            *                                          Only SS[2:0] are compared
   1315            *     @arg RTC_AlarmSubSecondMask_SS14_4: SS[14:4] are don't care in Alarm comparison.
   1316            *                                          Only SS[3:0] are compared
   1317            *     @arg RTC_AlarmSubSecondMask_SS14_5: SS[14:5] are don't care in Alarm comparison.
   1318            *                                          Only SS[4:0] are compared.
   1319            *     @arg RTC_AlarmSubSecondMask_SS14_6: SS[14:6] are don't care in Alarm comparison.
   1320            *                                          Only SS[5:0] are compared.
   1321            *     @arg RTC_AlarmSubSecondMask_SS14_7: SS[14:7] are don't care in Alarm comparison.
   1322            *                                          Only SS[6:0] are compared.
   1323            *     @arg RTC_AlarmSubSecondMask_SS14_8: SS[14:8] are don't care in Alarm comparison.
   1324            *                                          Only SS[7:0] are compared.
   1325            *     @arg RTC_AlarmSubSecondMask_SS14_9: SS[14:9] are don't care in Alarm comparison.
   1326            *                                          Only SS[8:0] are compared.
   1327            *     @arg RTC_AlarmSubSecondMask_SS14_10: SS[14:10] are don't care in Alarm comparison.
   1328            *                                          Only SS[9:0] are compared.
   1329            *     @arg RTC_AlarmSubSecondMask_SS14_11: SS[14:11] are don't care in Alarm comparison.
   1330            *                                          Only SS[10:0] are compared.
   1331            *     @arg RTC_AlarmSubSecondMask_SS14_12: SS[14:12] are don't care in Alarm comparison.
   1332            *                                          Only SS[11:0] are compared.
   1333            *     @arg RTC_AlarmSubSecondMask_SS14_13: SS[14:13] are don't care in Alarm comparison.
   1334            *                                          Only SS[12:0] are compared.
   1335            *     @arg RTC_AlarmSubSecondMask_SS14: SS[14] is don't care in Alarm comparison.
   1336            *                                          Only SS[13:0] are compared.
   1337            *     @arg RTC_AlarmSubSecondMask_None: SS[14:0] are compared and must match
   1338            *                                          to activate alarm.
   1339            * @retval None
   1340            */
   1341          void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
   1342          {
   1343            uint32_t tmpreg = 0;
   1344          
   1345            /* Check the parameters */
   1346            assert_param(IS_RTC_ALARM(RTC_Alarm));
   1347            assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
   1348            assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
   1349            
   1350            /* Disable the write protection for RTC registers */
   1351            RTC->WPR = 0xCA;
   1352            RTC->WPR = 0x53;
   1353            
   1354            /* Configure the Alarm A or Alarm B SubSecond registers */
   1355            tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
   1356            
   1357            if (RTC_Alarm == RTC_Alarm_A)
   1358            {
   1359              /* Configure the AlarmA SubSecond register */
   1360              RTC->ALRMASSR = tmpreg;
   1361            }
   1362            else
   1363            {
   1364              /* Configure the Alarm B SubSecond register */
   1365              RTC->ALRMBSSR = tmpreg;
   1366            }
   1367          
   1368            /* Enable the write protection for RTC registers */
   1369            RTC->WPR = 0xFF;
   1370          
   1371          }
   1372          
   1373          /**
   1374            * @brief  Gets the RTC Alarm Subseconds value.
   1375            * @param  RTC_Alarm: specifies the alarm to be read.
   1376            *   This parameter can be one of the following values:
   1377            *     @arg RTC_Alarm_A: to select Alarm A.
   1378            *     @arg RTC_Alarm_B: to select Alarm B.
   1379            * @param  None
   1380            * @retval RTC Alarm Subseconds value.
   1381            */
   1382          uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
   1383          {
   1384            uint32_t tmpreg = 0;
   1385            
   1386            /* Get the RTC_ALRMxR register */
   1387            if (RTC_Alarm == RTC_Alarm_A)
   1388            {
   1389              tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
   1390            }
   1391            else
   1392            {
   1393              tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
   1394            } 
   1395            
   1396            return (tmpreg);
   1397          }
   1398          
   1399          /**
   1400            * @}
   1401            */
   1402          
   1403          /** @defgroup RTC_Group4 WakeUp Timer configuration functions
   1404           *  @brief   WakeUp Timer configuration functions 
   1405           *
   1406          @verbatim
   1407           ===============================================================================
   1408                         ##### WakeUp Timer configuration functions #####
   1409           ===============================================================================
   1410              [..] This section provide functions allowing to program and read the RTC WakeUp.
   1411          
   1412          @endverbatim
   1413            * @{
   1414            */
   1415          
   1416          /**
   1417            * @brief  Configures the RTC Wakeup clock source.
   1418            * @note   The WakeUp Clock source can only be changed when the RTC WakeUp
   1419            *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).
   1420            * @param  RTC_WakeUpClock: Wakeup Clock source.
   1421            *   This parameter can be one of the following values:
   1422            *            @arg RTC_WakeUpClock_RTCCLK_Div16: RTC Wakeup Counter Clock = RTCCLK/16.
   1423            *            @arg RTC_WakeUpClock_RTCCLK_Div8: RTC Wakeup Counter Clock = RTCCLK/8.
   1424            *            @arg RTC_WakeUpClock_RTCCLK_Div4: RTC Wakeup Counter Clock = RTCCLK/4.
   1425            *            @arg RTC_WakeUpClock_RTCCLK_Div2: RTC Wakeup Counter Clock = RTCCLK/2.
   1426            *            @arg RTC_WakeUpClock_CK_SPRE_16bits: RTC Wakeup Counter Clock = CK_SPRE.
   1427            *            @arg RTC_WakeUpClock_CK_SPRE_17bits: RTC Wakeup Counter Clock = CK_SPRE.
   1428            * @retval None
   1429            */
   1430          void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
   1431          {
   1432            /* Check the parameters */
   1433            assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
   1434          
   1435            /* Disable the write protection for RTC registers */
   1436            RTC->WPR = 0xCA;
   1437            RTC->WPR = 0x53;
   1438          
   1439            /* Clear the Wakeup Timer clock source bits in CR register */
   1440            RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
   1441          
   1442            /* Configure the clock source */
   1443            RTC->CR |= (uint32_t)RTC_WakeUpClock;
   1444            
   1445            /* Enable the write protection for RTC registers */
   1446            RTC->WPR = 0xFF;
   1447          }
   1448          
   1449          /**
   1450            * @brief  Configures the RTC Wakeup counter.
   1451            * @note   The RTC WakeUp counter can only be written when the RTC WakeUp.
   1452            *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).
   1453            * @param  RTC_WakeUpCounter: specifies the WakeUp counter.
   1454            *   This parameter can be a value from 0x0000 to 0xFFFF. 
   1455            * @retval None
   1456            */
   1457          void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
   1458          {
   1459            /* Check the parameters */
   1460            assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
   1461            
   1462            /* Disable the write protection for RTC registers */
   1463            RTC->WPR = 0xCA;
   1464            RTC->WPR = 0x53;
   1465            
   1466            /* Configure the Wakeup Timer counter */
   1467            RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
   1468            
   1469            /* Enable the write protection for RTC registers */
   1470            RTC->WPR = 0xFF;
   1471          }
   1472          
   1473          /**
   1474            * @brief  Returns the RTC WakeUp timer counter value.
   1475            * @param  None
   1476            * @retval The RTC WakeUp Counter value.
   1477            */
   1478          uint32_t RTC_GetWakeUpCounter(void)
   1479          {
   1480            /* Get the counter value */
   1481            return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
   1482          }
   1483          
   1484          /**
   1485            * @brief  Enables or Disables the RTC WakeUp timer.
   1486            * @param  NewState: new state of the WakeUp timer.
   1487            *   This parameter can be: ENABLE or DISABLE.
   1488            * @retval None
   1489            */
   1490          ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
   1491          {
   1492            __IO uint32_t wutcounter = 0x00;
   1493            uint32_t wutwfstatus = 0x00;
   1494            ErrorStatus status = ERROR;
   1495            
   1496            /* Check the parameters */
   1497            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1498          
   1499            /* Disable the write protection for RTC registers */
   1500            RTC->WPR = 0xCA;
   1501            RTC->WPR = 0x53;
   1502          
   1503            if (NewState != DISABLE)
   1504            {
   1505              /* Enable the Wakeup Timer */
   1506              RTC->CR |= (uint32_t)RTC_CR_WUTE;
   1507              status = SUCCESS;    
   1508            }
   1509            else
   1510            {
   1511              /* Disable the Wakeup Timer */
   1512              RTC->CR &= (uint32_t)~RTC_CR_WUTE;
   1513              /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
   1514              do
   1515              {
   1516                wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
   1517                wutcounter++;  
   1518              } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
   1519              
   1520              if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
   1521              {
   1522                status = ERROR;
   1523              }
   1524              else
   1525              {
   1526                status = SUCCESS;
   1527              }    
   1528            }
   1529          
   1530            /* Enable the write protection for RTC registers */
   1531            RTC->WPR = 0xFF;
   1532            
   1533            return status;
   1534          }
   1535          
   1536          /**
   1537            * @}
   1538            */
   1539          
   1540          /** @defgroup RTC_Group5 Daylight Saving configuration functions
   1541           *  @brief   Daylight Saving configuration functions 
   1542           *
   1543          @verbatim
   1544           ===============================================================================
   1545                        ##### Daylight Saving configuration functions #####
   1546           ===============================================================================
   1547              [..] This section provide functions allowing to configure the RTC DayLight Saving.
   1548          
   1549          @endverbatim
   1550            * @{
   1551            */
   1552          
   1553          /**
   1554            * @brief  Adds or substract one hour from the current time.
   1555            * @param  RTC_DayLightSaveOperation: the value of hour adjustment. 
   1556            *   This parameter can be one of the following values:
   1557            *     @arg RTC_DayLightSaving_SUB1H: Substract one hour (winter time).
   1558            *     @arg RTC_DayLightSaving_ADD1H: Add one hour (summer time).
   1559            * @param  RTC_StoreOperation: Specifies the value to be written in the BCK bit 
   1560            *                            in CR register to store the operation.
   1561            *   This parameter can be one of the following values:
   1562            *            @arg RTC_StoreOperation_Reset: BCK Bit Reset.
   1563            *            @arg RTC_StoreOperation_Set: BCK Bit Set.
   1564            * @retval None
   1565            */
   1566          void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
   1567          {
   1568            /* Check the parameters */
   1569            assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
   1570            assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
   1571          
   1572            /* Disable the write protection for RTC registers */
   1573            RTC->WPR = 0xCA;
   1574            RTC->WPR = 0x53;
   1575          
   1576            /* Clear the bits to be configured */
   1577            RTC->CR &= (uint32_t)~(RTC_CR_BCK);
   1578          
   1579            /* Configure the RTC_CR register */
   1580            RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
   1581          
   1582            /* Enable the write protection for RTC registers */
   1583            RTC->WPR = 0xFF;
   1584          }
   1585          
   1586          /**
   1587            * @brief  Returns the RTC Day Light Saving stored operation.
   1588            * @param  None
   1589            * @retval RTC Day Light Saving stored operation.
   1590            *          - RTC_StoreOperation_Reset
   1591            *          - RTC_StoreOperation_Set
   1592            */
   1593          uint32_t RTC_GetStoreOperation(void)
   1594          {
   1595            return (RTC->CR & RTC_CR_BCK);
   1596          }
   1597          
   1598          /**
   1599            * @}
   1600            */
   1601          
   1602          /** @defgroup RTC_Group6 Output pin Configuration function
   1603           *  @brief   Output pin Configuration function 
   1604           *
   1605          @verbatim
   1606           ===============================================================================
   1607                            ##### Output pin Configuration function #####
   1608           ===============================================================================
   1609              [..] This section provide functions allowing to configure the RTC Output source.
   1610          
   1611          @endverbatim
   1612            * @{
   1613            */
   1614          
   1615          /**
   1616            * @brief  Configures the RTC output source (AFO_ALARM).
   1617            * @param  RTC_Output: Specifies which signal will be routed to the RTC output. 
   1618            *   This parameter can be one of the following values:
   1619            *     @arg RTC_Output_Disable: No output selected
   1620            *     @arg RTC_Output_AlarmA: signal of AlarmA mapped to output.
   1621            *     @arg RTC_Output_AlarmB: signal of AlarmB mapped to output.
   1622            *     @arg RTC_Output_WakeUp: signal of WakeUp mapped to output.
   1623            * @param  RTC_OutputPolarity: Specifies the polarity of the output signal.
   1624            *   This parameter can be one of the following:
   1625            *     @arg RTC_OutputPolarity_High: The output pin is high when the 
   1626            *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL).
   1627            *     @arg RTC_OutputPolarity_Low: The output pin is low when the 
   1628            *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL).
   1629            * @retval None
   1630            */
   1631          void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
   1632          {
   1633            /* Check the parameters */
   1634            assert_param(IS_RTC_OUTPUT(RTC_Output));
   1635            assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
   1636          
   1637            /* Disable the write protection for RTC registers */
   1638            RTC->WPR = 0xCA;
   1639            RTC->WPR = 0x53;
   1640          
   1641            /* Clear the bits to be configured */
   1642            RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
   1643          
   1644            /* Configure the output selection and polarity */
   1645            RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
   1646          
   1647            /* Enable the write protection for RTC registers */
   1648            RTC->WPR = 0xFF;
   1649          }
   1650          
   1651          /**
   1652            * @}
   1653            */
   1654          
   1655          /** @defgroup RTC_Group7 Coarse and Smooth Calibrations configuration functions
   1656           *  @brief   Coarse and Smooth Calibrations configuration functions 
   1657           *
   1658          @verbatim
   1659           ===============================================================================
   1660                  ##### Coarse and Smooth Calibrations configuration functions #####
   1661           ===============================================================================
   1662          
   1663          @endverbatim
   1664            * @{
   1665            */
   1666          
   1667          /**
   1668            * @brief  Configures the Coarse Calibration parameters.
   1669            * @param  RTC_CalibSign: specifies the sign of the calibration value.
   1670            *   This parameter can be  one of the following values:
   1671            *     @arg RTC_CalibSign_Positive: The value sign is positive.
   1672            *     @arg RTC_CalibSign_Negative: The value sign is negative.
   1673            * @param  Value: value of calibration expressed in ppm (coded on 5 bits) 
   1674            *                This value should be between 0 and 63 when using negative sign
   1675            *                with a 2-ppm step.
   1676            *                This value should be between 0 and 126 when using positive sign
   1677            *                with a 4-ppm step.
   1678            * @retval An ErrorStatus enumeration value:
   1679            *          - SUCCESS: RTC Coarse calibration are initialized
   1680            *          - ERROR: RTC Coarse calibration are not initialized 
   1681            */
   1682          ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
   1683          {
   1684            ErrorStatus status = ERROR;
   1685             
   1686            /* Check the parameters */
   1687            assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
   1688            assert_param(IS_RTC_CALIB_VALUE(Value)); 
   1689          
   1690            /* Disable the write protection for RTC registers */
   1691            RTC->WPR = 0xCA;
   1692            RTC->WPR = 0x53;
   1693          
   1694            /* Set Initialization mode */
   1695            if (RTC_EnterInitMode() == ERROR)
   1696            {
   1697              status = ERROR;
   1698            } 
   1699            else
   1700            {
   1701              /* Set the coarse calibration value */
   1702              RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
   1703              /* Exit Initialization mode */
   1704              RTC_ExitInitMode();
   1705              
   1706              status = SUCCESS;
   1707            } 
   1708          
   1709            /* Enable the write protection for RTC registers */
   1710            RTC->WPR = 0xFF; 
   1711            
   1712            return status;
   1713          }
   1714          
   1715          /**
   1716          * @brief  Enables or disables the Coarse calibration process.
   1717            * @param  NewState: new state of the Coarse calibration.
   1718            *          This parameter can be: ENABLE or DISABLE.
   1719            * @retval An ErrorStatus enumeration value:
   1720            *          - SUCCESS: RTC Coarse calibration are enabled/disabled
   1721            *          - ERROR: RTC Coarse calibration are not enabled/disabled    
   1722            */
   1723          ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
   1724          {
   1725            ErrorStatus status = ERROR;
   1726            
   1727            /* Check the parameters */
   1728            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1729          
   1730            /* Disable the write protection for RTC registers */
   1731            RTC->WPR = 0xCA;
   1732            RTC->WPR = 0x53;
   1733            
   1734            /* Set Initialization mode */
   1735            if (RTC_EnterInitMode() == ERROR)
   1736            {
   1737              status =  ERROR;
   1738            }
   1739            else
   1740            {
   1741              if (NewState != DISABLE)
   1742              {
   1743                /* Enable the Coarse Calibration */
   1744                RTC->CR |= (uint32_t)RTC_CR_DCE;
   1745              }
   1746              else
   1747              { 
   1748                /* Disable the Coarse Calibration */
   1749                RTC->CR &= (uint32_t)~RTC_CR_DCE;
   1750              }
   1751              /* Exit Initialization mode */
   1752              RTC_ExitInitMode();
   1753              
   1754              status = SUCCESS;
   1755            } 
   1756            
   1757            /* Enable the write protection for RTC registers */
   1758            RTC->WPR = 0xFF; 
   1759            
   1760            return status;
   1761          }
   1762          
   1763          /**
   1764            * @brief  Enables or disables the RTC clock to be output through the relative 
   1765            *         pin.
   1766            * @param  NewState: new state of the coarse calibration Output.
   1767            *   This parameter can be: ENABLE or DISABLE.
   1768            * @retval None
   1769            */
   1770          void RTC_CalibOutputCmd(FunctionalState NewState)
   1771          {
   1772            /* Check the parameters */
   1773            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1774            
   1775            /* Disable the write protection for RTC registers */
   1776            RTC->WPR = 0xCA;
   1777            RTC->WPR = 0x53;
   1778            
   1779            if (NewState != DISABLE)
   1780            {
   1781              /* Enable the RTC clock output */
   1782              RTC->CR |= (uint32_t)RTC_CR_COE;
   1783            }
   1784            else
   1785            { 
   1786              /* Disable the RTC clock output */
   1787              RTC->CR &= (uint32_t)~RTC_CR_COE;
   1788            }
   1789            
   1790            /* Enable the write protection for RTC registers */
   1791            RTC->WPR = 0xFF; 
   1792          }
   1793          
   1794          /**
   1795            * @brief  Configure the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
   1796            * @param  RTC_CalibOutput : Select the Calibration output Selection .
   1797            *   This parameter can be one of the following values:
   1798            *     @arg RTC_CalibOutput_512Hz: A signal has a regular waveform at 512Hz. 
   1799            *     @arg RTC_CalibOutput_1Hz: A signal has a regular waveform at 1Hz.
   1800            * @retval None
   1801          */
   1802          void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
   1803          {
   1804            /* Check the parameters */
   1805            assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));
   1806          
   1807            /* Disable the write protection for RTC registers */
   1808            RTC->WPR = 0xCA;
   1809            RTC->WPR = 0x53;
   1810            
   1811            /*clear flags before config*/
   1812            RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
   1813          
   1814            /* Configure the RTC_CR register */
   1815            RTC->CR |= (uint32_t)RTC_CalibOutput;
   1816          
   1817            /* Enable the write protection for RTC registers */
   1818            RTC->WPR = 0xFF;
   1819          }
   1820          
   1821          /**
   1822            * @brief  Configures the Smooth Calibration Settings.
   1823            * @param  RTC_SmoothCalibPeriod: Select the Smooth Calibration Period.
   1824            *   This parameter can be can be one of the following values:
   1825            *     @arg RTC_SmoothCalibPeriod_32sec: The smooth calibration periode is 32s.
   1826            *     @arg RTC_SmoothCalibPeriod_16sec: The smooth calibration periode is 16s.
   1827            *     @arg RTC_SmoothCalibPeriod_8sec: The smooth calibartion periode is 8s.
   1828            * @param  RTC_SmoothCalibPlusPulses: Select to Set or reset the CALP bit.
   1829            *   This parameter can be one of the following values:
   1830            *     @arg RTC_SmoothCalibPlusPulses_Set: Add one RTCCLK puls every 2**11 pulses.
   1831            *     @arg RTC_SmoothCalibPlusPulses_Reset: No RTCCLK pulses are added.
   1832            * @param  RTC_SmouthCalibMinusPulsesValue: Select the value of CALM[8:0] bits.
   1833            *   This parameter can be one any value from 0 to 0x000001FF.
   1834            * @retval An ErrorStatus enumeration value:
   1835            *          - SUCCESS: RTC Calib registers are configured
   1836            *          - ERROR: RTC Calib registers are not configured
   1837          */
   1838          ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
   1839                                            uint32_t RTC_SmoothCalibPlusPulses,
   1840                                            uint32_t RTC_SmouthCalibMinusPulsesValue)
   1841          {
   1842            ErrorStatus status = ERROR;
   1843            uint32_t recalpfcount = 0;
   1844          
   1845            /* Check the parameters */
   1846            assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
   1847            assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
   1848            assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
   1849          
   1850            /* Disable the write protection for RTC registers */
   1851            RTC->WPR = 0xCA;
   1852            RTC->WPR = 0x53;
   1853            
   1854            /* check if a calibration is pending*/
   1855            if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
   1856            {
   1857              /* wait until the Calibration is completed*/
   1858              while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
   1859              {
   1860                recalpfcount++;
   1861              }
   1862            }
   1863          
   1864            /* check if the calibration pending is completed or if there is no calibration operation at all*/
   1865            if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
   1866            {
   1867              /* Configure the Smooth calibration settings */
   1868              RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
   1869          
   1870              status = SUCCESS;
   1871            }
   1872            else
   1873            {
   1874              status = ERROR;
   1875            }
   1876          
   1877            /* Enable the write protection for RTC registers */
   1878            RTC->WPR = 0xFF;
   1879            
   1880            return (ErrorStatus)(status);
   1881          }
   1882          
   1883          /**
   1884            * @}
   1885            */
   1886          
   1887          
   1888          /** @defgroup RTC_Group8 TimeStamp configuration functions
   1889           *  @brief   TimeStamp configuration functions 
   1890           *
   1891          @verbatim
   1892           ===============================================================================
   1893                           ##### TimeStamp configuration functions #####
   1894           ===============================================================================
   1895          
   1896          @endverbatim
   1897            * @{
   1898            */
   1899          
   1900          /**
   1901            * @brief  Enables or Disables the RTC TimeStamp functionality with the 
   1902            *         specified time stamp pin stimulating edge.
   1903            * @param  RTC_TimeStampEdge: Specifies the pin edge on which the TimeStamp is 
   1904            *         activated.
   1905            *   This parameter can be one of the following:
   1906            *     @arg RTC_TimeStampEdge_Rising: the Time stamp event occurs on the rising 
   1907            *                                    edge of the related pin.
   1908            *     @arg RTC_TimeStampEdge_Falling: the Time stamp event occurs on the 
   1909            *                                     falling edge of the related pin.
   1910            * @param  NewState: new state of the TimeStamp.
   1911            *   This parameter can be: ENABLE or DISABLE.
   1912            * @retval None
   1913            */
   1914          void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
   1915          {
   1916            uint32_t tmpreg = 0;
   1917          
   1918            /* Check the parameters */
   1919            assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
   1920            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1921          
   1922            /* Get the RTC_CR register and clear the bits to be configured */
   1923            tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
   1924          
   1925            /* Get the new configuration */
   1926            if (NewState != DISABLE)
   1927            {
   1928              tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
   1929            }
   1930            else
   1931            {
   1932              tmpreg |= (uint32_t)(RTC_TimeStampEdge);
   1933            }
   1934          
   1935            /* Disable the write protection for RTC registers */
   1936            RTC->WPR = 0xCA;
   1937            RTC->WPR = 0x53;
   1938          
   1939            /* Configure the Time Stamp TSEDGE and Enable bits */
   1940            RTC->CR = (uint32_t)tmpreg;
   1941          
   1942            /* Enable the write protection for RTC registers */
   1943            RTC->WPR = 0xFF;
   1944          }
   1945          
   1946          /**
   1947            * @brief  Get the RTC TimeStamp value and masks.
   1948            * @param  RTC_Format: specifies the format of the output parameters.
   1949            *   This parameter can be one of the following values:
   1950            *     @arg RTC_Format_BIN: Binary data format 
   1951            *     @arg RTC_Format_BCD: BCD data format
   1952            * @param RTC_StampTimeStruct: pointer to a RTC_TimeTypeDef structure that will 
   1953            *                             contains the TimeStamp time values. 
   1954            * @param RTC_StampDateStruct: pointer to a RTC_DateTypeDef structure that will 
   1955            *                             contains the TimeStamp date values.     
   1956            * @retval None
   1957            */
   1958          void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
   1959                                                RTC_DateTypeDef* RTC_StampDateStruct)
   1960          {
   1961            uint32_t tmptime = 0, tmpdate = 0;
   1962          
   1963            /* Check the parameters */
   1964            assert_param(IS_RTC_FORMAT(RTC_Format));
   1965          
   1966            /* Get the TimeStamp time and date registers values */
   1967            tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
   1968            tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
   1969          
   1970            /* Fill the Time structure fields with the read parameters */
   1971            RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
   1972            RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
   1973            RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
   1974            RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
   1975          
   1976            /* Fill the Date structure fields with the read parameters */
   1977            RTC_StampDateStruct->RTC_Year = 0;
   1978            RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
   1979            RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
   1980            RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
   1981          
   1982            /* Check the input parameters format */
   1983            if (RTC_Format == RTC_Format_BIN)
   1984            {
   1985              /* Convert the Time structure parameters to Binary format */
   1986              RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
   1987              RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
   1988              RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
   1989          
   1990              /* Convert the Date structure parameters to Binary format */
   1991              RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
   1992              RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
   1993              RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
   1994            }
   1995          }
   1996          
   1997          /**
   1998            * @brief  Get the RTC timestamp Subseconds value.
   1999            * @param  None
   2000            * @retval RTC current timestamp Subseconds value.
   2001            */
   2002          uint32_t RTC_GetTimeStampSubSecond(void)
   2003          {
   2004            /* Get timestamp subseconds values from the correspondent registers */
   2005            return (uint32_t)(RTC->TSSSR);
   2006          }
   2007          
   2008          /**
   2009            * @}
   2010            */
   2011          
   2012          /** @defgroup RTC_Group9 Tampers configuration functions
   2013           *  @brief   Tampers configuration functions 
   2014           *
   2015          @verbatim
   2016           ===============================================================================
   2017                           ##### Tampers configuration functions #####
   2018           ===============================================================================
   2019          
   2020          @endverbatim
   2021            * @{
   2022            */
   2023          
   2024          /**
   2025            * @brief  Configures the select Tamper pin edge.
   2026            * @param  RTC_Tamper: Selected tamper pin.
   2027            *   This parameter can be any combination of the following values:
   2028            *     @arg RTC_Tamper_1: Select Tamper 1.
   2029            *     @arg RTC_Tamper_2: Select Tamper 2.
   2030            *     @arg RTC_Tamper_3: Select Tamper 3.
   2031            * @param  RTC_TamperTrigger: Specifies the trigger on the tamper pin that 
   2032            *                            stimulates tamper event. 
   2033            *   This parameter can be one of the following values:
   2034            *     @arg RTC_TamperTrigger_RisingEdge: Rising Edge of the tamper pin causes tamper event.
   2035            *     @arg RTC_TamperTrigger_FallingEdge: Falling Edge of the tamper pin causes tamper event.
   2036            *     @arg RTC_TamperTrigger_LowLevel: Low Level of the tamper pin causes tamper event.
   2037            *     @arg RTC_TamperTrigger_HighLevel: High Level of the tamper pin causes tamper event.
   2038            * @retval None
   2039            */
   2040          void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
   2041          {
   2042            /* Check the parameters */
   2043            assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
   2044            assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
   2045           
   2046            /* Check if the  active level for Tamper is rising edge (Low level)*/
   2047            if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
   2048            {  
   2049              /* Configure the RTC_TAFCR register */
   2050              RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
   2051            }
   2052            else
   2053            { 
   2054              /* Configure the RTC_TAFCR register */
   2055              RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
   2056            }  
   2057          }
   2058          
   2059          /**
   2060            * @brief  Enables or Disables the Tamper detection.
   2061            * @param  RTC_Tamper: Selected tamper pin.
   2062            *   This parameter can be any combination of the following values:
   2063            *     @arg RTC_Tamper_1: Select Tamper 1.
   2064            *     @arg RTC_Tamper_2: Select Tamper 2.
   2065            *     @arg RTC_Tamper_3: Select Tamper 3.
   2066            * @param  NewState: new state of the tamper pin.
   2067            *         This parameter can be: ENABLE or DISABLE.                   
   2068            * @retval None
   2069            */
   2070          void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
   2071          {
   2072            /* Check the parameters */
   2073            assert_param(IS_RTC_TAMPER(RTC_Tamper));  
   2074            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2075            
   2076            if (NewState != DISABLE)
   2077            {
   2078              /* Enable the selected Tamper pin */
   2079              RTC->TAFCR |= (uint32_t)RTC_Tamper;
   2080            }
   2081            else
   2082            {
   2083              /* Disable the selected Tamper pin */
   2084              RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
   2085            }  
   2086          }
   2087          
   2088          /**
   2089            * @brief  Configures the Tampers Filter.
   2090            * @param  RTC_TamperFilter: Specifies the tampers filter.
   2091            *   This parameter can be one of the following values:
   2092            *     @arg RTC_TamperFilter_Disable: Tamper filter is disabled.
   2093            *     @arg RTC_TamperFilter_2Sample: Tamper is activated after 2 consecutive 
   2094            *                                    samples at the active level.
   2095            *     @arg RTC_TamperFilter_4Sample: Tamper is activated after 4 consecutive 
   2096            *                                    samples at the active level.
   2097            *     @arg RTC_TamperFilter_8Sample: Tamper is activated after 8 consecutive 
   2098            *                                    samples at the active level.
   2099            * @retval None
   2100            */
   2101          void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
   2102          {
   2103            /* Check the parameters */
   2104            assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
   2105             
   2106            /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
   2107            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
   2108          
   2109            /* Configure the RTC_TAFCR register */
   2110            RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
   2111          }
   2112          
   2113          /**
   2114            * @brief  Configures the Tampers Sampling Frequency.
   2115            * @param  RTC_TamperSamplingFreq: Specifies the tampers Sampling Frequency.
   2116            *   This parameter can be one of the following values:
   2117            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div32768: Each of the tamper inputs are sampled
   2118            *                                           with a frequency =  RTCCLK / 32768
   2119            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div16384: Each of the tamper inputs are sampled
   2120            *                                           with a frequency =  RTCCLK / 16384
   2121            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div8192: Each of the tamper inputs are sampled
   2122            *                                           with a frequency =  RTCCLK / 8192
   2123            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div4096: Each of the tamper inputs are sampled
   2124            *                                           with a frequency =  RTCCLK / 4096
   2125            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div2048: Each of the tamper inputs are sampled
   2126            *                                           with a frequency =  RTCCLK / 2048
   2127            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div1024: Each of the tamper inputs are sampled
   2128            *                                           with a frequency =  RTCCLK / 1024
   2129            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div512: Each of the tamper inputs are sampled
   2130            *                                           with a frequency =  RTCCLK / 512  
   2131            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div256: Each of the tamper inputs are sampled
   2132            *                                           with a frequency =  RTCCLK / 256  
   2133            * @retval None
   2134            */
   2135          void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
   2136          {
   2137            /* Check the parameters */
   2138            assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
   2139           
   2140            /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
   2141            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
   2142          
   2143            /* Configure the RTC_TAFCR register */
   2144            RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
   2145          }
   2146          
   2147          /**
   2148            * @brief  Configures the Tampers Pins input Precharge Duration.
   2149            * @param  RTC_TamperPrechargeDuration: Specifies the Tampers Pins input
   2150            *         Precharge Duration.
   2151            *   This parameter can be one of the following values:
   2152            *     @arg RTC_TamperPrechargeDuration_1RTCCLK: Tamper pins are pre-charged before sampling during 1 RTCCLK cycle.
   2153            *     @arg RTC_TamperPrechargeDuration_2RTCCLK: Tamper pins are pre-charged before sampling during 2 RTCCLK cycle.
   2154            *     @arg RTC_TamperPrechargeDuration_4RTCCLK: Tamper pins are pre-charged before sampling during 4 RTCCLK cycle.
   2155            *     @arg RTC_TamperPrechargeDuration_8RTCCLK: Tamper pins are pre-charged before sampling during 8 RTCCLK cycle.
   2156            * @retval None
   2157            */
   2158          void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
   2159          {
   2160            /* Check the parameters */
   2161            assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
   2162             
   2163            /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
   2164            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
   2165          
   2166            /* Configure the RTC_TAFCR register */
   2167            RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
   2168          }
   2169          
   2170          /**
   2171            * @brief  Enables or Disables the TimeStamp on Tamper Detection Event.
   2172            * @note   The timestamp is valid even the TSE bit in tamper control register 
   2173            *         is reset.   
   2174            * @param  NewState: new state of the timestamp on tamper event.
   2175            *         This parameter can be: ENABLE or DISABLE.
   2176            * @retval None
   2177            */
   2178          void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
   2179          {
   2180            /* Check the parameters */
   2181            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2182             
   2183            if (NewState != DISABLE)
   2184            {
   2185              /* Save timestamp on tamper detection event */
   2186              RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
   2187            }
   2188            else
   2189            {
   2190              /* Tamper detection does not cause a timestamp to be saved */
   2191              RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
   2192            }
   2193          }
   2194          
   2195          /**
   2196            * @brief  Enables or Disables the Precharge of Tamper pin.
   2197            * @param  NewState: new state of tamper pull up.
   2198            *   This parameter can be: ENABLE or DISABLE.                   
   2199            * @retval None
   2200            */
   2201          void RTC_TamperPullUpCmd(FunctionalState NewState)
   2202          {
   2203            /* Check the parameters */
   2204            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2205            
   2206           if (NewState != DISABLE)
   2207            {
   2208              /* Enable precharge of the selected Tamper pin */
   2209              RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
   2210            }
   2211            else
   2212            {
   2213              /* Disable precharge of the selected Tamper pin */
   2214              RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
   2215            } 
   2216          }
   2217          
   2218          /**
   2219            * @}
   2220            */
   2221          
   2222          /** @defgroup RTC_Group10 Backup Data Registers configuration functions
   2223           *  @brief   Backup Data Registers configuration functions  
   2224           *
   2225          @verbatim
   2226           ===============================================================================
   2227                    ##### Backup Data Registers configuration functions #####
   2228           ===============================================================================
   2229          
   2230          @endverbatim
   2231            * @{
   2232            */
   2233          
   2234          /**
   2235            * @brief  Writes a data in a specified RTC Backup data register.
   2236            * @param  RTC_BKP_DR: RTC Backup data Register number.
   2237            *   This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
   2238            *                          specify the register.
   2239            * @param  Data: Data to be written in the specified RTC Backup data register.                     
   2240            * @retval None
   2241            */
   2242          void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
   2243          {
   2244            __IO uint32_t tmp = 0;
   2245            
   2246            /* Check the parameters */
   2247            assert_param(IS_RTC_BKP(RTC_BKP_DR));
   2248          
   2249            tmp = RTC_BASE + 0x50;
   2250            tmp += (RTC_BKP_DR * 4);
   2251          
   2252            /* Write the specified register */
   2253            *(__IO uint32_t *)tmp = (uint32_t)Data;
   2254          }
   2255          
   2256          /**
   2257            * @brief  Reads data from the specified RTC Backup data Register.
   2258            * @param  RTC_BKP_DR: RTC Backup data Register number.
   2259            *   This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
   2260            *                          specify the register.                   
   2261            * @retval None
   2262            */
   2263          uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
   2264          {
   2265            __IO uint32_t tmp = 0;
   2266            
   2267            /* Check the parameters */
   2268            assert_param(IS_RTC_BKP(RTC_BKP_DR));
   2269          
   2270            tmp = RTC_BASE + 0x50;
   2271            tmp += (RTC_BKP_DR * 4);
   2272            
   2273            /* Read the specified register */
   2274            return (*(__IO uint32_t *)tmp);
   2275          }
   2276          
   2277          /**
   2278            * @}
   2279            */
   2280          
   2281          /** @defgroup RTC_Group11 Output Type Config configuration functions
   2282           *  @brief   Output Type Config configuration functions  
   2283           *
   2284          @verbatim
   2285           ===============================================================================
   2286                       ##### Output Type Config configuration functions #####
   2287           ===============================================================================
   2288          
   2289          @endverbatim
   2290            * @{
   2291            */
   2292          
   2293          /**
   2294            * @brief  Configures the RTC Output Pin mode. 
   2295            * @param  RTC_OutputType: specifies the RTC Output (PC13) pin mode.
   2296            *   This parameter can be one of the following values:
   2297            *     @arg RTC_OutputType_OpenDrain: RTC Output (PC13) is configured in 
   2298            *                                    Open Drain mode.
   2299            *     @arg RTC_OutputType_PushPull:  RTC Output (PC13) is configured in 
   2300            *                                    Push Pull mode.    
   2301            * @retval None
   2302            */
   2303          void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
   2304          {
   2305            /* Check the parameters */
   2306            assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
   2307            
   2308            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
   2309            RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
   2310          }
   2311          
   2312          /**
   2313            * @}
   2314            */
   2315          
   2316          /** @defgroup RTC_Group12 Shift control synchronisation functions
   2317           *  @brief   Shift control synchronisation functions 
   2318           *
   2319          @verbatim
   2320           ===============================================================================
   2321                      ##### Shift control synchronisation functions #####
   2322           ===============================================================================
   2323          
   2324          @endverbatim
   2325            * @{
   2326            */
   2327          
   2328          /**
   2329            * @brief  Configures the Synchronization Shift Control Settings.
   2330            * @note   When REFCKON is set, firmware must not write to Shift control register 
   2331            * @param  RTC_ShiftAdd1S : Select to add or not 1 second to the time Calendar.
   2332            *   This parameter can be one of the following values :
   2333            *     @arg RTC_ShiftAdd1S_Set: Add one second to the clock calendar. 
   2334            *     @arg RTC_ShiftAdd1S_Reset: No effect.
   2335            * @param  RTC_ShiftSubFS: Select the number of Second Fractions to Substitute.
   2336            *         This parameter can be one any value from 0 to 0x7FFF.
   2337            * @retval An ErrorStatus enumeration value:
   2338            *          - SUCCESS: RTC Shift registers are configured
   2339            *          - ERROR: RTC Shift registers are not configured
   2340          */
   2341          ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
   2342          {
   2343            ErrorStatus status = ERROR;
   2344            uint32_t shpfcount = 0;
   2345          
   2346            /* Check the parameters */
   2347            assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
   2348            assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
   2349          
   2350            /* Disable the write protection for RTC registers */
   2351            RTC->WPR = 0xCA;
   2352            RTC->WPR = 0x53;
   2353            
   2354            /* Check if a Shift is pending*/
   2355            if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
   2356            {
   2357              /* Wait until the shift is completed*/
   2358              while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
   2359              {
   2360                shpfcount++;
   2361              }
   2362            }
   2363          
   2364            /* Check if the Shift pending is completed or if there is no Shift operation at all*/
   2365            if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
   2366            {
   2367              /* check if the reference clock detection is disabled */
   2368              if((RTC->CR & RTC_CR_REFCKON) == RESET)
   2369              {
   2370                /* Configure the Shift settings */
   2371                RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
   2372              
   2373                if(RTC_WaitForSynchro() == ERROR)
   2374                {
   2375                  status = ERROR;
   2376                }
   2377                else
   2378                {
   2379                  status = SUCCESS;
   2380                }
   2381              }
   2382              else
   2383              {
   2384                status = ERROR;
   2385              }
   2386            }
   2387            else
   2388            {
   2389              status = ERROR;
   2390            }
   2391          
   2392            /* Enable the write protection for RTC registers */
   2393            RTC->WPR = 0xFF;
   2394            
   2395            return (ErrorStatus)(status);
   2396          }
   2397          
   2398          /**
   2399            * @}
   2400            */
   2401          
   2402          /** @defgroup RTC_Group13 Interrupts and flags management functions
   2403           *  @brief   Interrupts and flags management functions  
   2404           *
   2405          @verbatim
   2406           ===============================================================================
   2407                      ##### Interrupts and flags management functions #####
   2408           ===============================================================================
   2409              [..] All RTC interrupts are connected to the EXTI controller.
   2410                   (+) To enable the RTC Alarm interrupt, the following sequence is required:
   2411                   (+) Configure and enable the EXTI Line 17 in interrupt mode and select 
   2412                       the rising edge sensitivity using the EXTI_Init() function.
   2413                   (+) Configure and enable the RTC_Alarm IRQ channel in the NVIC using 
   2414                       the NVIC_Init() function.
   2415                   (+) Configure the RTC to generate RTC alarms (Alarm A and/or Alarm B) 
   2416                       using the RTC_SetAlarm() and RTC_AlarmCmd() functions.
   2417          
   2418                   (+) To enable the RTC Wakeup interrupt, the following sequence is required:
   2419                   (+) Configure and enable the EXTI Line 20 in interrupt mode and select 
   2420                       the rising edge sensitivity using the EXTI_Init() function.
   2421                   (+) Configure and enable the RTC_WKUP IRQ channel in the NVIC using the 
   2422                       NVIC_Init() function.
   2423                   (+) Configure the RTC to generate the RTC wakeup timer event using the 
   2424                       RTC_WakeUpClockConfig(), RTC_SetWakeUpCounter() and RTC_WakeUpCmd() 
   2425                       functions.
   2426          
   2427                   (+) To enable the RTC Tamper interrupt, the following sequence is required:
   2428                   (+) Configure and enable the EXTI Line 19 in interrupt mode and select 
   2429                       the rising edge sensitivity using the EXTI_Init() function.
   2430                   (+) Configure and enable the TAMP_STAMP IRQ channel in the NVIC using 
   2431                       the NVIC_Init() function.
   2432                   (+) Configure the RTC to detect the RTC tamper event using the 
   2433                       RTC_TamperTriggerConfig() and RTC_TamperCmd() functions.
   2434          
   2435                   (+) To enable the RTC TimeStamp interrupt, the following sequence is 
   2436                       required:
   2437                   (+) Configure and enable the EXTI Line 19 in interrupt mode and select 
   2438                       the rising edge sensitivity using the EXTI_Init() function.
   2439                   (+) Configure and enable the TAMP_STAMP IRQ channel in the NVIC using 
   2440                       the NVIC_Init() function.
   2441                   (+) Configure the RTC to detect the RTC time-stamp event using the 
   2442                       RTC_TimeStampCmd() functions.
   2443          
   2444          @endverbatim
   2445            * @{
   2446            */
   2447          
   2448          /**
   2449            * @brief  Enables or disables the specified RTC interrupts.
   2450            * @param  RTC_IT: specifies the RTC interrupt sources to be enabled or disabled. 
   2451            *   This parameter can be any combination of the following values:
   2452            *     @arg RTC_IT_TS:  Time Stamp interrupt mask.
   2453            *     @arg RTC_IT_WUT:  WakeUp Timer interrupt mask.
   2454            *     @arg RTC_IT_ALRB:  Alarm B interrupt mask.
   2455            *     @arg RTC_IT_ALRA:  Alarm A interrupt mask.
   2456            *     @arg RTC_IT_TAMP: Tamper event interrupt mask.
   2457            * @param  NewState: new state of the specified RTC interrupts.
   2458            *   This parameter can be: ENABLE or DISABLE.
   2459            * @retval None
   2460            */
   2461          void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
   2462          {
   2463            /* Check the parameters */
   2464            assert_param(IS_RTC_CONFIG_IT(RTC_IT));
   2465            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2466          
   2467            /* Disable the write protection for RTC registers */
   2468            RTC->WPR = 0xCA;
   2469            RTC->WPR = 0x53;
   2470          
   2471            if (NewState != DISABLE)
   2472            {
   2473              /* Configure the Interrupts in the RTC_CR register */
   2474              RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
   2475              /* Configure the Tamper Interrupt in the RTC_TAFCR */
   2476              RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
   2477            }
   2478            else
   2479            {
   2480              /* Configure the Interrupts in the RTC_CR register */
   2481              RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
   2482              /* Configure the Tamper Interrupt in the RTC_TAFCR */
   2483              RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
   2484            }
   2485            /* Enable the write protection for RTC registers */
   2486            RTC->WPR = 0xFF; 
   2487          }
   2488          
   2489          /**
   2490            * @brief  Checks whether the specified RTC flag is set or not.
   2491            * @param  RTC_FLAG: specifies the flag to check.
   2492            *   This parameter can be one of the following values:
   2493            *     @arg RTC_FLAG_RECALPF: RECALPF event flag.
   2494            *     @arg RTC_FLAG_TAMP3F: Tamper 3 event flag.
   2495            *     @arg RTC_FLAG_TAMP2F: Tamper 2 event flag.
   2496            *     @arg RTC_FLAG_TAMP1F: Tamper 1 event flag.
   2497            *     @arg RTC_FLAG_TSOVF: Time Stamp OverFlow flag.
   2498            *     @arg RTC_FLAG_TSF: Time Stamp event flag.
   2499            *     @arg RTC_FLAG_WUTF: WakeUp Timer flag.
   2500            *     @arg RTC_FLAG_ALRBF: Alarm B flag.
   2501            *     @arg RTC_FLAG_ALRAF: Alarm A flag.
   2502            *     @arg RTC_FLAG_INITF: Initialization mode flag.
   2503            *     @arg RTC_FLAG_RSF: Registers Synchronized flag.
   2504            *     @arg RTC_FLAG_INITS: Registers Configured flag.
   2505            *     @argRTC_FLAG_SHPF: Shift operation pending flag.
   2506            *     @arg RTC_FLAG_WUTWF: WakeUp Timer Write flag.
   2507            *     @arg RTC_FLAG_ALRBWF: Alarm B Write flag.
   2508            *     @arg RTC_FLAG_ALRAWF: Alarm A write flag.
   2509            * @retval The new state of RTC_FLAG (SET or RESET).
   2510            */
   2511          FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
   2512          {
   2513            FlagStatus bitstatus = RESET;
   2514            uint32_t tmpreg = 0;
   2515            
   2516            /* Check the parameters */
   2517            assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
   2518            
   2519            /* Get all the flags */
   2520            tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
   2521            
   2522            /* Return the status of the flag */
   2523            if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
   2524            {
   2525              bitstatus = SET;
   2526            }
   2527            else
   2528            {
   2529              bitstatus = RESET;
   2530            }
   2531            return bitstatus;
   2532          }
   2533          
   2534          /**
   2535            * @brief  Clears the RTC's pending flags.
   2536            * @param  RTC_FLAG: specifies the RTC flag to clear.
   2537            *   This parameter can be any combination of the following values:
   2538            *     @arg RTC_FLAG_TAMP3F: Tamper 3 event flag.
   2539            *     @arg RTC_FLAG_TAMP2F: Tamper 2 event flag.
   2540            *     @arg RTC_FLAG_TAMP1F: Tamper 1 event flag.
   2541            *     @arg RTC_FLAG_TSOVF: Time Stamp Overflow flag.
   2542            *     @arg RTC_FLAG_TSF: Time Stamp event flag.
   2543            *     @arg RTC_FLAG_WUTF: WakeUp Timer flag.
   2544            *     @arg RTC_FLAG_ALRBF: Alarm B flag.
   2545            *     @arg RTC_FLAG_ALRAF: Alarm A flag.
   2546            *     @arg RTC_FLAG_RSF: Registers Synchronized flag.
   2547            * @retval None
   2548            */
   2549          void RTC_ClearFlag(uint32_t RTC_FLAG)
   2550          {
   2551            /* Check the parameters */
   2552            assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
   2553          
   2554            /* Clear the Flags in the RTC_ISR register */
   2555            RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0001FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));    
   2556          }
   2557          
   2558          /**
   2559            * @brief  Checks whether the specified RTC interrupt has occurred or not.
   2560            * @param  RTC_IT: specifies the RTC interrupt source to check.
   2561            *   This parameter can be one of the following values:
   2562            *     @arg RTC_IT_TS: Time Stamp interrupt.
   2563            *     @arg RTC_IT_WUT: WakeUp Timer interrupt.
   2564            *     @arg RTC_IT_ALRB: Alarm B interrupt. 
   2565            *     @arg RTC_IT_ALRA: Alarm A interrupt. 
   2566            *     @arg RTC_IT_TAMP1: Tamper1 event interrupt. 
   2567            *     @arg RTC_IT_TAMP2: Tamper2 event interrupt. 
   2568            *     @arg RTC_IT_TAMP3: Tamper3 event interrupt.
   2569            * @retval The new state of RTC_IT (SET or RESET).
   2570            */
   2571          ITStatus RTC_GetITStatus(uint32_t RTC_IT)
   2572          {
   2573            ITStatus bitstatus = RESET;
   2574            uint32_t tmpreg = 0, enablestatus = 0;
   2575           
   2576            /* Check the parameters */
   2577            assert_param(IS_RTC_GET_IT(RTC_IT));
   2578            
   2579            /* Get the TAMPER Interrupt enable bit and pending bit */
   2580            tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
   2581           
   2582            /* Get the Interrupt enable Status */
   2583            enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & ((RTC_IT >> (RTC_IT >> 18)) >> 15)));
   2584            
   2585            /* Get the Interrupt pending bit */
   2586            tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
   2587            
   2588            /* Get the status of the Interrupt */
   2589            if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
   2590            {
   2591              bitstatus = SET;
   2592            }
   2593            else
   2594            {
   2595              bitstatus = RESET;
   2596            }
   2597            return bitstatus;
   2598          }
   2599          
   2600          /**
   2601            * @brief  Clears the RTC's interrupt pending bits.
   2602            * @param  RTC_IT: specifies the RTC interrupt pending bit to clear.
   2603            *   This parameter can be any combination of the following values:
   2604            *     @arg RTC_IT_TS: Time Stamp interrupt 
   2605            *     @arg RTC_IT_WUT: WakeUp Timer interrupt 
   2606            *     @arg RTC_IT_ALRB: Alarm B interrupt 
   2607            *     @arg RTC_IT_ALRA: Alarm A interrupt 
   2608            *     @arg RTC_IT_TAMP1: Tamper1 event interrupt
   2609            *     @arg RTC_IT_TAMP2: Tamper2 event interrupt
   2610            *     @arg RTC_IT_TAMP3: Tamper3 event interrupt 
   2611            * @retval None
   2612            */
   2613          void RTC_ClearITPendingBit(uint32_t RTC_IT)
   2614          {
   2615            uint32_t tmpreg = 0;
   2616          
   2617            /* Check the parameters */
   2618            assert_param(IS_RTC_CLEAR_IT(RTC_IT));
   2619          
   2620            /* Get the RTC_ISR Interrupt pending bits mask */
   2621            tmpreg = (uint32_t)(RTC_IT >> 4);
   2622          
   2623            /* Clear the interrupt pending bits in the RTC_ISR register */
   2624            RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
   2625          }
   2626          
   2627          /**
   2628            * @}
   2629            */
   2630          
   2631          /**
   2632            * @brief  Converts a 2 digit decimal to BCD format.
   2633            * @param  Value: Byte to be converted.
   2634            * @retval Converted byte
   2635            */
   2636          static uint8_t RTC_ByteToBcd2(uint8_t Value)
   2637          {
   2638            uint8_t bcdhigh = 0;
   2639            
   2640            while (Value >= 10)
   2641            {
   2642              bcdhigh++;
   2643              Value -= 10;
   2644            }
   2645            
   2646            return  ((uint8_t)(bcdhigh << 4) | Value);
   2647          }
   2648          
   2649          /**
   2650            * @brief  Convert from 2 digit BCD to Binary.
   2651            * @param  Value: BCD value to be converted.
   2652            * @retval Converted word
   2653            */
   2654          static uint8_t RTC_Bcd2ToByte(uint8_t Value)
   2655          {
   2656            uint8_t tmp = 0;
   2657            tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
   2658            return (tmp + (Value & (uint8_t)0x0F));
   2659          }
   2660          
   2661          /**
   2662            * @}
   2663            */ 
   2664          
   2665          /**
   2666            * @}
   2667            */ 
   2668          
   2669          /**
   2670            * @}
   2671            */ 
   2672          
   2673          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   RTC_AlarmCmd
       0   RTC_AlarmStructInit
       0   RTC_AlarmSubSecondConfig
       0   RTC_BypassShadowCmd
       0   RTC_CalibOutputCmd
       0   RTC_CalibOutputConfig
       0   RTC_ClearFlag
       0   RTC_ClearITPendingBit
       8   RTC_CoarseCalibCmd
      12   RTC_CoarseCalibConfig
       0   RTC_DateStructInit
       0   RTC_DayLightSavingConfig
       8   RTC_DeInit
       4   RTC_EnterInitMode
       0   RTC_ExitInitMode
       0   RTC_GetAlarm
       0   RTC_GetAlarmSubSecond
       0   RTC_GetDate
       0   RTC_GetFlagStatus
       8   RTC_GetITStatus
       0   RTC_GetStoreOperation
       0   RTC_GetSubSecond
       0   RTC_GetTime
      12   RTC_GetTimeStamp
       0   RTC_GetTimeStampSubSecond
       0   RTC_GetWakeUpCounter
       0   RTC_ITConfig
       8   RTC_Init
       0   RTC_OutputConfig
       0   RTC_OutputTypeConfig
       4   RTC_ReadBackupRegister
       8   RTC_RefClockCmd
      16   RTC_SetAlarm
      16   RTC_SetDate
      20   RTC_SetTime
       0   RTC_SetWakeUpCounter
      12   RTC_SmoothCalibConfig
       0   RTC_StructInit
      12   RTC_SynchroShiftConfig
       0   RTC_TamperCmd
       0   RTC_TamperFilterConfig
       0   RTC_TamperPinsPrechargeDuration
       0   RTC_TamperPullUpCmd
       0   RTC_TamperSamplingFreqConfig
       0   RTC_TamperTriggerConfig
       0   RTC_TimeStampCmd
       0   RTC_TimeStampOnTamperDetectionCmd
       0   RTC_TimeStructInit
       4   RTC_WaitForSynchro
       0   RTC_WakeUpClockConfig
       4   RTC_WakeUpCmd
       4   RTC_WriteBackupRegister
       0   RTC_WriteProtectionCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable48
       4  ??DataTable48_1
       4  ??DataTable48_10
       4  ??DataTable48_11
       4  ??DataTable48_12
       4  ??DataTable48_13
       4  ??DataTable48_14
       4  ??DataTable48_15
       4  ??DataTable48_16
       4  ??DataTable48_2
       4  ??DataTable48_3
       4  ??DataTable48_4
       4  ??DataTable48_5
       4  ??DataTable48_6
       4  ??DataTable48_7
       4  ??DataTable48_8
       4  ??DataTable48_9
      90  RTC_AlarmCmd
      22  RTC_AlarmStructInit
      38  RTC_AlarmSubSecondConfig
      34  RTC_BypassShadowCmd
      32  RTC_CalibOutputCmd
      30  RTC_CalibOutputConfig
      24  RTC_ClearFlag
      24  RTC_ClearITPendingBit
     100  RTC_CoarseCalibCmd
      84  RTC_CoarseCalibConfig
      14  RTC_DateStructInit
      34  RTC_DayLightSavingConfig
     192  RTC_DeInit
      60  RTC_EnterInitMode
      14  RTC_ExitInitMode
     146  RTC_GetAlarm
      20  RTC_GetAlarmSubSecond
      92  RTC_GetDate
      20  RTC_GetFlagStatus
      46  RTC_GetITStatus
      12  RTC_GetStoreOperation
      10  RTC_GetSubSecond
      96  RTC_GetTime
     172  RTC_GetTimeStamp
       6  RTC_GetTimeStampSubSecond
      10  RTC_GetWakeUpCounter
      58  RTC_ITConfig
     114  RTC_Init
      34  RTC_OutputConfig
      18  RTC_OutputTypeConfig
      26  RTC_ReadBackupRegister
     100  RTC_RefClockCmd
     222  RTC_SetAlarm
     272  RTC_SetDate
     274  RTC_SetTime
      20  RTC_SetWakeUpCounter
      62  RTC_SmoothCalibConfig
      14  RTC_StructInit
     118  RTC_SynchroShiftConfig
      18  RTC_TamperCmd
      18  RTC_TamperFilterConfig
      18  RTC_TamperPinsPrechargeDuration
      20  RTC_TamperPullUpCmd
      18  RTC_TamperSamplingFreqConfig
      20  RTC_TamperTriggerConfig
      36  RTC_TimeStampCmd
      20  RTC_TimeStampOnTamperDetectionCmd
      12  RTC_TimeStructInit
      62  RTC_WaitForSynchro
      32  RTC_WakeUpClockConfig
      82  RTC_WakeUpCmd
      26  RTC_WriteBackupRegister
      20  RTC_WriteProtectionCmd

 
 3 224 bytes in section .text
 
 3 224 bytes of CODE memory

Errors: none
Warnings: none
