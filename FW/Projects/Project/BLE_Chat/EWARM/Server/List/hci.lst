###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.60.1.5097/W32 for ARM      31/Oct/2014  21:00:35 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\FredZhou\Documents\Origin\Projects\Bluetooth    #
#                    LE\SimpleBlueNRG_HCI\hci\hci.c                           #
#    Command line =  "C:\Users\FredZhou\Documents\Origin\Projects\Bluetooth   #
#                    LE\SimpleBlueNRG_HCI\hci\hci.c" -D USE_STDPERIPH_DRIVER  #
#                    -D STM32L1XX_MD -D SYSCLK_FREQ_HSI_32MHz -D ENABLE_USB   #
#                    -D ENABLE_USB_PRINTF -D DEBUG -D SERVER -D ACCEL_TEST    #
#                    -lcN C:\Users\FredZhou\Documents\Origin\Projects\Project #
#                    \BLE_Chat\EWARM\Server\List\ --diag_suppress Pa050 -o    #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Server\Obj\ --debug --endian=little           #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.5\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\inc\ -I "C:\Users\FredZhou\Documents\Origi #
#                    n\Projects\Project\BLE_Chat\EWARM\..\..\..\Bluetooth     #
#                    LE\SimpleBlueNRG_HCI\" -I "C:\Users\FredZhou\Documents\O #
#                    rigin\Projects\Project\BLE_Chat\EWARM\..\..\..\Bluetooth #
#                     LE\SimpleBlueNRG_HCI\includes\" -I                      #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\ -I               #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\ -I     #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\CMSIS\C #
#                    M3\DeviceSupport\ST\STM32L1xx\ -I                        #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32_U #
#                    SB-FS-Device_Driver\inc\ -I                              #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32L1 #
#                    xx_StdPeriph_Driver\inc\ -I                              #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\I2C\inc #
#                    \ -I C:\Users\FredZhou\Documents\Origin\Projects\Project #
#                    \BLE_Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\LI #
#                    S3DH\inc\ -I C:\Users\FredZhou\Documents\Origin\Projects #
#                    \Project\BLE_Chat\EWARM\..\..\..\platform\STM32L1XX\Libr #
#                    aries\STLM75\inc\ -I C:\Users\FredZhou\Documents\Origin\ #
#                    Projects\Project\BLE_Chat\EWARM\..\..\..\platform\STM32L #
#                    1XX\Libraries\HTS221\inc\ -I                             #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\LPS25H\ #
#                    inc\ -I C:\Users\FredZhou\Documents\Origin\Projects\Proj #
#                    ect\BLE_Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries #
#                    \SDK_Eval_STM32L\inc\ -Ohs --use_c++_inline -I           #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Server\List\hci.lst                           #
#    Object file  =  C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Server\Obj\hci.o                              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\FredZhou\Documents\Origin\Projects\Bluetooth LE\SimpleBlueNRG_HCI\hci\hci.c
      1          /******************** (C) COPYRIGHT 2013 STMicroelectronics ********************
      2          * File Name          : bluenrg_hci.h
      3          * Author             : AMS - HEA&RF BU
      4          * Version            : V1.0.0
      5          * Date               : 4-Oct-2013
      6          * Description        : Function for managing HCI interface. Implementation of
      7          *                      standard HCI commands.
      8          ********************************************************************************
      9          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     10          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     11          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     12          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     13          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     14          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     15          *******************************************************************************/
     16          
     17          /**
     18            ******************************************************************************
     19            * @file    hci.c 
     20            * @author  AMS/HESA Application Team
     21            * @brief   Function for managing HCI interface.
     22            ******************************************************************************
     23            * @copy
     24            *
     25            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     26            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     27            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     28            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     29            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     30            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     31            *
     32            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     33            */ 
     34          
     35          #include "hal_types.h"
     36          #include "osal.h"
     37          #include "ble_status.h"
     38          #include "hal.h"
     39          #include <hci_internal.h>
     40          #include "gp_timer.h"
     41          
     42          #if BLE_CONFIG_DBG_ENABLE
     43          #define PRINTF(...) printf(__VA_ARGS__)
     44          #else
     45          #define PRINTF(...)
     46          #endif
     47          
     48          #define HCI_LOG_ON 0
     49          
     50          #define HCI_READ_PACKET_NUM_MAX 		 (5)
     51          
     52          #define MIN(a,b)            ((a) < (b) )? (a) : (b)
     53          #define MAX(a,b)            ((a) > (b) )? (a) : (b)
     54          
     55          static void enqueue_packet(tHciDataPacket * hciReadPacket);
     56          
     57          tListNode hciReadPktPool;
     58          tListNode hciReadPktRxQueue;
     59          /* pool of hci read packets */
     60          static tHciDataPacket     hciReadPacketBuffer[HCI_READ_PACKET_NUM_MAX];
     61          
     62          static uint8_t *hci_buffer = NULL;
     63          static volatile uint16_t hci_pckt_len;
     64          
     65          volatile uint8_t readPacketListFull=FALSE;
     66          
     67          void HCI_Init(void)
     68          {
     69              uint8_t index;
     70              
     71              /* Initialize list heads of ready and free hci data packet queues */
     72              list_init_head (&hciReadPktPool);
     73              list_init_head (&hciReadPktRxQueue);
     74              
     75              /* Initialize the queue of free hci data packets */
     76              for (index = 0; index < HCI_READ_PACKET_NUM_MAX; index++)
     77              {
     78                  list_insert_tail(&hciReadPktPool, (tListNode *)&hciReadPacketBuffer[index]);
     79              }
     80          }
     81          
     82          static volatile hci_packet_complete_callback packet_complete_callback = NULL;
     83          
     84          static void hci_set_packet_complete_callback(hci_packet_complete_callback cb)
     85          {
     86          	packet_complete_callback = cb;
     87          }
     88          
     89          void HCI_Input(tHciDataPacket * hciReadPacket)
     90          {
     91              uint8_t byte;
     92              hci_acl_hdr *acl_hdr;
     93          
     94          	static hci_state state = WAITING_TYPE;
     95          
     96          	tHalUint16 collected_payload_len = 0;
     97          	tHalUint16 payload_len;
     98              
     99              hci_buffer = hciReadPacket->dataBuff;
    100              
    101              if(state == WAITING_TYPE)
    102                  hci_pckt_len = 0;
    103              
    104              while(hci_pckt_len < HCI_PACKET_SIZE){
    105          
    106                  byte = hci_buffer[hci_pckt_len++];
    107          
    108                  if(state == WAITING_TYPE){
    109                      /* Only ACL Data and Events packets are accepted. */
    110                      if(byte == HCI_EVENT_PKT){
    111                           state = WAITING_EVENT_CODE;
    112                      }
    113          //            else if(byte == HCI_ACLDATA_PKT){
    114          //                state = WAITING_HANDLE;
    115          //            }
    116                      else{
    117                          /* Incorrect type. Reset state machine. */
    118                          state = WAITING_TYPE;
    119                          break;
    120                      }
    121                  }
    122                  else if(state == WAITING_EVENT_CODE)
    123                      state = WAITING_PARAM_LEN;
    124                  else if(state == WAITING_HANDLE)
    125                      state = WAITING_HANDLE_FLAG;
    126                  else if(state == WAITING_HANDLE_FLAG)
    127                      state = WAITING_DATA_LEN1;
    128                  else if(state == WAITING_DATA_LEN1)
    129                      state = WAITING_DATA_LEN2;
    130          
    131                  else if(state == WAITING_DATA_LEN2){
    132                      acl_hdr = (void *)&hci_buffer[HCI_HDR_SIZE];
    133                      payload_len = acl_hdr->dlen;
    134                      collected_payload_len = 0;
    135                      state = WAITING_PAYLOAD;
    136                  }
    137                  else if(state == WAITING_PARAM_LEN){
    138                       payload_len = byte;
    139                       collected_payload_len = 0;
    140                       state = WAITING_PAYLOAD;
    141                  }
    142                  else if(state == WAITING_PAYLOAD){
    143                      collected_payload_len += 1;
    144                      if(collected_payload_len >= payload_len){
    145                          /* Reset state machine. */
    146                          state = WAITING_TYPE;
    147                          enqueue_packet(hciReadPacket);
    148                          
    149                          if(packet_complete_callback){
    150                            uint16_t len = hci_pckt_len;
    151                            packet_complete_callback(hci_buffer, len);
    152                          }
    153                          break;
    154                      }
    155                  }
    156              }        
    157          }
    158          
    159          void enqueue_packet(tHciDataPacket * hciReadPacket)
    160          {
    161              hci_uart_pckt *hci_pckt = (void*)hciReadPacket->dataBuff;
    162              hci_event_pckt *event_pckt = (void*)hci_pckt->data;
    163              
    164              // Do not enqueue Command Complete or Command Status events
    165              
    166              if((hci_pckt->type != HCI_EVENT_PKT) ||
    167                 event_pckt->evt == EVT_CMD_COMPLETE ||
    168                     event_pckt->evt == EVT_CMD_STATUS){
    169                  // Insert the packet back into the pool.
    170                  list_insert_tail(&hciReadPktPool, (tListNode *)hciReadPacket);
    171              }
    172              else {    
    173                  // Insert the packet into the queue of events to be processed.
    174                  list_insert_tail(&hciReadPktRxQueue, (tListNode *)hciReadPacket);
    175              }
    176          }
    177          
    178          void HCI_Process(void)
    179          {
    180              uint8_t data_len;
    181              uint8_t buffer[HCI_PACKET_SIZE];
    182              tHciDataPacket * hciReadPacket = NULL;
    183          
    184              Disable_SPI_IRQ();
    185              tHalBool list_empty = list_is_empty(&hciReadPktRxQueue);        
    186              /* process any pending events read */
    187              while(list_empty == FALSE)
    188              {
    189                  list_remove_head (&hciReadPktRxQueue, (tListNode **)&hciReadPacket);
    190                  Enable_SPI_IRQ();
    191                  HCI_Event_CB(hciReadPacket->dataBuff);
    192                  Disable_SPI_IRQ();
    193                  list_insert_tail(&hciReadPktPool, (tListNode *)hciReadPacket);
    194                  list_empty = list_is_empty(&hciReadPktRxQueue);
    195              }
    196              if (readPacketListFull) {
    197                while(BlueNRG_DataPresent()) {
    198          	data_len = BlueNRG_SPI_Read_All(buffer, HCI_PACKET_SIZE);
    199          	if(data_len > 0)
    200          	  HCI_Event_CB(buffer);
    201                }
    202                readPacketListFull = FALSE;
    203              }
    204          
    205              Enable_SPI_IRQ();    
    206          }
    207          
    208          void HCI_Isr(void)
    209          {
    210            tHciDataPacket * hciReadPacket = NULL;
    211            uint8_t data_len;
    212              
    213            Clear_SPI_EXTI_Flag();
    214            while(SdkEvalSPI_Irq_Pin()){        
    215              if (list_is_empty (&hciReadPktPool) == FALSE){
    216                      
    217                /* enqueueing a packet for read */
    218                list_remove_head (&hciReadPktPool, (tListNode **)&hciReadPacket);
    219                      
    220                data_len = BlueNRG_SPI_Read_All(hciReadPacket->dataBuff,HCI_PACKET_SIZE);
    221                if(data_len > 0){                    
    222          	HCI_Input(hciReadPacket);
    223          	// Packet will be inserted to te correct queue by 
    224                }
    225                else {
    226          	// Insert the packet back into the pool.
    227          	list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);
    228                }
    229                      
    230              }
    231              else{
    232                // HCI Read Packet Pool is empty, wait for a free packet.
    233                readPacketListFull = TRUE;
    234                Clear_SPI_EXTI_Flag();
    235                return;
    236              }
    237                  
    238              Clear_SPI_EXTI_Flag();
    239            }
    240          }
    241          
    242          void hci_write(const void* data1, const void* data2, uint32_t n_bytes1, uint32_t n_bytes2){
    243          #if  HCI_LOG_ON
    244              PRINTF("HCI <- ");
    245              for(int i=0; i < n_bytes1; i++)
    246                  PRINTF("%02X ", *((uint8_t*)data1 + i));
    247              for(int i=0; i < n_bytes2; i++)
    248                  PRINTF("%02X ", *((uint8_t*)data2 + i));
    249              PRINTF("\n");    
    250          #endif
    251                  
    252          	Hal_Write_Serial(data1, data2, n_bytes1, n_bytes2);
    253          }
    254          
    255          int hci_send_cmd(uint16_t ogf, uint16_t ocf, uint8_t plen, void *param)
    256          {
    257          	hci_command_hdr hc;
    258          
    259          	hc.opcode = htobs(cmd_opcode_pack(ogf, ocf));
    260          	hc.plen= plen;
    261          	
    262          	uint8_t header[HCI_HDR_SIZE + HCI_COMMAND_HDR_SIZE];
    263          	header[0] = HCI_COMMAND_PKT;
    264          	Osal_MemCpy(header+1, &hc, sizeof(hc));
    265              
    266          	hci_write(header, param, sizeof(header), plen);
    267          
    268          	return 0;
    269          }
    270          
    271          static tHalBool new_packet;
    272          
    273          void new_hci_event(void *pckt, tHalUint16 len)
    274          {
    275          	Disable_SPI_IRQ(); /* Must be re-enabled after packet processing. */
    276          
    277          	new_packet = TRUE;
    278          }
    279          
    280          /* 'to' is timeout in system clock ticks.  */
    281          int hci_send_req(struct hci_request *r)
    282          {
    283          	tHalUint8 *ptr;
    284          	tHalUint16 opcode = htobs(cmd_opcode_pack(r->ogf, r->ocf));
    285          	hci_event_pckt *event_pckt;
    286          	hci_uart_pckt *hci_hdr;
    287          	int try;
    288              int to = DEFAULT_TIMEOUT;
    289              
    290          	new_packet = FALSE;
    291          	hci_set_packet_complete_callback(new_hci_event);
    292          	if (hci_send_cmd(r->ogf, r->ocf, r->clen, r->cparam) < 0)
    293          		goto failed;
    294              
    295          	try = 10;
    296          	while (try--) {
    297          		evt_cmd_complete *cc;
    298          		evt_cmd_status *cs;
    299          		evt_le_meta_event *me;
    300          		int len;
    301                  
    302                  /* Minimum timeout is 1. */
    303                  if(to == 0)
    304                      to = 1;
    305                  
    306          		if (to > 0) {
    307          			struct timer t;
    308                      
    309          			Timer_Set(&t, to);
    310                      
    311          			while(1){
    312          				if(Timer_Expired(&t)){
    313          					goto failed;
    314          				}
    315          				if(new_packet){
    316          					break;
    317          				}
    318          			}
    319          		}
    320                  
    321          		hci_hdr = (void *)hci_buffer;
    322          		if(hci_hdr->type != HCI_EVENT_PKT){
    323                      new_packet = FALSE;
    324                      Enable_SPI_IRQ();
    325                      continue;
    326                  }
    327                  
    328          		event_pckt = (void *) (hci_hdr->data);
    329                  
    330          		ptr = hci_buffer + (1 + HCI_EVENT_HDR_SIZE);
    331          		len = hci_pckt_len - (1 + HCI_EVENT_HDR_SIZE);
    332                  
    333          		switch (event_pckt->evt) {
    334                      
    335          		case EVT_CMD_STATUS:
    336          			cs = (void *) ptr;
    337                      
    338          			if (cs->opcode != opcode)
    339          				break;
    340                      
    341          			if (r->event != EVT_CMD_STATUS) {
    342          				if (cs->status) {
    343          					goto failed;
    344          				}
    345          				break;
    346          			}
    347                      
    348          			r->rlen = MIN(len, r->rlen);
    349          			Osal_MemCpy(r->rparam, ptr, r->rlen);
    350          			goto done;
    351                      
    352          		case EVT_CMD_COMPLETE:
    353          			cc = (void *) ptr;
    354                      
    355          			if (cc->opcode != opcode)
    356          				break;
    357                      
    358          			ptr += EVT_CMD_COMPLETE_SIZE;
    359          			len -= EVT_CMD_COMPLETE_SIZE;
    360                      
    361          			r->rlen = MIN(len, r->rlen);
    362          			Osal_MemCpy(r->rparam, ptr, r->rlen);
    363          			goto done;
    364                      
    365          		case EVT_LE_META_EVENT:
    366          			me = (void *) ptr;
    367                      
    368          			if (me->subevent != r->event)
    369          				break;
    370                      
    371          			len -= 1;
    372          			r->rlen = MIN(len, r->rlen);
    373          			Osal_MemCpy(r->rparam, me->data, r->rlen);
    374          			goto done;
    375                      
    376                  case EVT_HARDWARE_ERROR:            
    377                      goto failed;
    378                      
    379          		default:
    380                      break; // In the meantime there could be other events from the controller.
    381          		}
    382                  
    383          		new_packet = FALSE;
    384          		Enable_SPI_IRQ();
    385                  
    386          	}
    387              
    388          failed:
    389          	hci_set_packet_complete_callback(NULL);
    390          	Enable_SPI_IRQ();
    391          	return -1;
    392              
    393          done:
    394          	hci_set_packet_complete_callback(NULL);
    395          	Enable_SPI_IRQ();
    396          	return 0;
    397          }
    398          
    399          int hci_reset()
    400          {
    401            	struct hci_request rq;
    402          	tHalUint8 status;
    403          
    404          	Osal_MemSet(&rq, 0, sizeof(rq));
    405          	rq.ogf = OGF_HOST_CTL;
    406          	rq.ocf = OCF_RESET;
    407          	rq.rparam = &status;
    408          	rq.rlen = 1;
    409          
    410          	if (hci_send_req(&rq) < 0)
    411          		return -1;
    412          
    413          	if (status) {
    414          		return -1;
    415          	}
    416          
    417          	return 0;  
    418          }
    419          
    420          int hci_disconnect(uint16_t	handle, uint8_t reason)
    421          {
    422            struct hci_request rq;
    423          	disconnect_cp cp;
    424          	uint8_t status;
    425            
    426          	cp.handle = handle;
    427          	cp.reason = reason;
    428          
    429          	Osal_MemSet(&rq, 0, sizeof(rq));
    430          	rq.ogf = OGF_LINK_CTL;
    431          	rq.ocf = OCF_DISCONNECT;
    432              rq.cparam = &cp;
    433          	rq.clen = DISCONNECT_CP_SIZE;
    434              rq.event = EVT_CMD_STATUS;
    435          	rq.rparam = &status;
    436          	rq.rlen = 1;
    437          
    438          	if (hci_send_req(&rq) < 0)
    439          		return -1;
    440          
    441          	if (status) {
    442          		return -1;
    443          	}
    444          
    445          	return 0;  
    446          }
    447          
    448          int hci_le_read_local_version(uint8_t *hci_version, uint16_t *hci_revision, uint8_t *lmp_pal_version, 
    449          			      uint16_t *manufacturer_name, uint16_t *lmp_pal_subversion)
    450          {
    451          	struct hci_request rq;
    452          	read_local_version_rp resp;
    453          
    454          	Osal_MemSet(&resp, 0, sizeof(resp));
    455          
    456          	Osal_MemSet(&rq, 0, sizeof(rq));
    457          	rq.ogf = OGF_INFO_PARAM;
    458          	rq.ocf = OCF_READ_LOCAL_VERSION;
    459          	rq.cparam = NULL;
    460          	rq.clen = 0;
    461          	rq.rparam = &resp;
    462          	rq.rlen = READ_LOCAL_VERSION_RP_SIZE;
    463          
    464          	if (hci_send_req(&rq) < 0)
    465          		return -1;
    466          
    467          	if (resp.status) {
    468          		return -1;
    469          	}
    470          
    471          
    472          	*hci_version = resp.hci_version;
    473          	*hci_revision =  btohs(resp.hci_revision);
    474          	*lmp_pal_version = resp.lmp_pal_version;
    475          	*manufacturer_name = btohs(resp.manufacturer_name);
    476          	*lmp_pal_subversion = btohs(resp.lmp_pal_subversion);
    477          
    478          	return 0;
    479          }
    480          
    481          int hci_le_read_buffer_size(uint16_t *pkt_len, uint8_t *max_pkt)
    482          {
    483          	struct hci_request rq;
    484          	le_read_buffer_size_rp resp;
    485          
    486          	Osal_MemSet(&resp, 0, sizeof(resp));
    487          
    488          	Osal_MemSet(&rq, 0, sizeof(rq));
    489          	rq.ogf = OGF_LE_CTL;
    490          	rq.ocf = OCF_LE_READ_BUFFER_SIZE;
    491          	rq.cparam = NULL;
    492          	rq.clen = 0;
    493          	rq.rparam = &resp;
    494          	rq.rlen = LE_READ_BUFFER_SIZE_RP_SIZE;
    495          
    496          	if (hci_send_req(&rq) < 0)
    497          		return -1;
    498          
    499          	if (resp.status) {
    500          		return -1;
    501          	}
    502          	
    503          	*pkt_len = resp.pkt_len;
    504          	*max_pkt = resp.max_pkt;
    505          
    506          	return 0;
    507          }
    508          
    509          int hci_le_set_advertising_parameters(uint16_t min_interval, uint16_t max_interval, uint8_t advtype,
    510          		uint8_t own_bdaddr_type, uint8_t direct_bdaddr_type, tBDAddr direct_bdaddr, uint8_t chan_map,
    511          		uint8_t filter)
    512          {
    513          	struct hci_request rq;
    514          	le_set_adv_parameters_cp adv_cp;
    515          	uint8_t status;
    516          
    517          	Osal_MemSet(&adv_cp, 0, sizeof(adv_cp));
    518          	adv_cp.min_interval = min_interval;
    519          	adv_cp.max_interval = max_interval;
    520          	adv_cp.advtype = advtype;
    521          	adv_cp.own_bdaddr_type = own_bdaddr_type;
    522          	adv_cp.direct_bdaddr_type = direct_bdaddr_type;
    523              Osal_MemCpy(adv_cp.direct_bdaddr,direct_bdaddr,sizeof(adv_cp.direct_bdaddr));
    524          	adv_cp.chan_map = chan_map;
    525          	adv_cp.filter = filter;
    526          
    527          	Osal_MemSet(&rq, 0, sizeof(rq));
    528          	rq.ogf = OGF_LE_CTL;
    529          	rq.ocf = OCF_LE_SET_ADV_PARAMETERS;
    530          	rq.cparam = &adv_cp;
    531          	rq.clen = LE_SET_ADV_PARAMETERS_CP_SIZE;
    532          	rq.rparam = &status;
    533          	rq.rlen = 1;
    534          
    535          	if (hci_send_req(&rq) < 0)
    536          		return -1;
    537          
    538          	if (status) {
    539          		return -1;
    540          	}
    541          
    542          	return 0;
    543          }
    544          
    545          int hci_le_set_advertising_data(uint8_t length, const uint8_t data[])
    546          {
    547          	struct hci_request rq;
    548          	le_set_adv_data_cp adv_cp;
    549          	uint8_t status;
    550          
    551          	Osal_MemSet(&adv_cp, 0, sizeof(adv_cp));
    552          	adv_cp.length = length;
    553          	Osal_MemCpy(adv_cp.data, data, MIN(31,length));
    554          
    555          	Osal_MemSet(&rq, 0, sizeof(rq));
    556          	rq.ogf = OGF_LE_CTL;
    557          	rq.ocf = OCF_LE_SET_ADV_DATA;
    558          	rq.cparam = &adv_cp;
    559          	rq.clen = LE_SET_ADV_DATA_CP_SIZE;
    560          	rq.rparam = &status;
    561          	rq.rlen = 1;
    562          
    563          	if (hci_send_req(&rq) < 0)
    564          		return -1;
    565          
    566          	if (status) {
    567          		return -1;
    568          	}
    569          
    570          	return 0;
    571          }
    572          
    573          int hci_le_set_advertise_enable(tHalUint8 enable)
    574          {
    575          	struct hci_request rq;
    576          	le_set_advertise_enable_cp adv_cp;
    577          	uint8_t status;
    578          
    579          	Osal_MemSet(&adv_cp, 0, sizeof(adv_cp));
    580          	adv_cp.enable = enable?1:0;
    581          
    582          	Osal_MemSet(&rq, 0, sizeof(rq));
    583          	rq.ogf = OGF_LE_CTL;
    584          	rq.ocf = OCF_LE_SET_ADVERTISE_ENABLE;
    585          	rq.cparam = &adv_cp;
    586          	rq.clen = LE_SET_ADVERTISE_ENABLE_CP_SIZE;
    587          	rq.rparam = &status;
    588          	rq.rlen = 1;
    589          
    590          	if (hci_send_req(&rq) < 0)
    591          		return -1;
    592          
    593          	if (status) {
    594          		return -1;
    595          	}
    596          
    597          	return 0;
    598          }
    599          
    600          int hci_le_rand(uint8_t random_number[8])
    601          {
    602          	struct hci_request rq;
    603          	le_rand_rp resp;
    604          
    605          	Osal_MemSet(&resp, 0, sizeof(resp));
    606          
    607          	Osal_MemSet(&rq, 0, sizeof(rq));
    608          	rq.ogf = OGF_LE_CTL;
    609          	rq.ocf = OCF_LE_RAND;
    610          	rq.cparam = NULL;
    611          	rq.clen = 0;
    612          	rq.rparam = &resp;
    613          	rq.rlen = LE_RAND_RP_SIZE;
    614          
    615          	if (hci_send_req(&rq) < 0)
    616          		return -1;
    617          
    618          	if (resp.status) {
    619          		return -1;
    620          	}
    621              
    622              Osal_MemCpy(random_number, resp.random, 8);
    623          
    624          	return 0;
    625          }
    626          
    627          int hci_le_set_scan_resp_data(uint8_t length, const uint8_t data[])
    628          {
    629          	struct hci_request rq;
    630          	le_set_scan_response_data_cp scan_resp_cp;
    631          	uint8_t status;
    632          
    633          	Osal_MemSet(&scan_resp_cp, 0, sizeof(scan_resp_cp));
    634          	scan_resp_cp.length = length;
    635          	Osal_MemCpy(scan_resp_cp.data, data, MIN(31,length));
    636          
    637          	Osal_MemSet(&rq, 0, sizeof(rq));
    638          	rq.ogf = OGF_LE_CTL;
    639          	rq.ocf = OCF_LE_SET_SCAN_RESPONSE_DATA;
    640          	rq.cparam = &scan_resp_cp;
    641          	rq.clen = LE_SET_SCAN_RESPONSE_DATA_CP_SIZE;
    642          	rq.rparam = &status;
    643          	rq.rlen = 1;
    644          
    645          	if (hci_send_req(&rq) < 0)
    646          		return -1;
    647          
    648          	if (status) {
    649          		return -1;
    650          	}
    651          
    652          	return 0;
    653          }
    654          
    655          int hci_le_read_advertising_channel_tx_power(int8_t *tx_power_level)
    656          {
    657          	struct hci_request rq;
    658          	le_read_adv_channel_tx_power_rp resp;
    659          
    660          	Osal_MemSet(&resp, 0, sizeof(resp));
    661          
    662          	Osal_MemSet(&rq, 0, sizeof(rq));
    663          	rq.ogf = OGF_LE_CTL;
    664          	rq.ocf = OCF_LE_READ_ADV_CHANNEL_TX_POWER;
    665          	rq.cparam = NULL;
    666          	rq.clen = 0;
    667          	rq.rparam = &resp;
    668          	rq.rlen = LE_RAND_RP_SIZE;
    669          
    670          	if (hci_send_req(&rq) < 0)
    671          		return -1;
    672          
    673          	if (resp.status) {
    674          		return -1;
    675          	}
    676          
    677          	*tx_power_level = resp.level;
    678          
    679          	return 0;
    680          }
    681          
    682          int hci_le_set_random_address(tBDAddr bdaddr)
    683          {
    684          	struct hci_request rq;
    685          	le_set_random_address_cp set_rand_addr_cp;
    686          	uint8_t status;
    687          
    688          	Osal_MemSet(&set_rand_addr_cp, 0, sizeof(set_rand_addr_cp));
    689          	Osal_MemCpy(set_rand_addr_cp.bdaddr, bdaddr, sizeof(tBDAddr));
    690          
    691          	Osal_MemSet(&rq, 0, sizeof(rq));
    692          	rq.ogf = OGF_LE_CTL;
    693          	rq.ocf = OCF_LE_SET_RANDOM_ADDRESS;
    694          	rq.cparam = &set_rand_addr_cp;
    695          	rq.clen = LE_SET_RANDOM_ADDRESS_CP_SIZE;
    696          	rq.rparam = &status;
    697          	rq.rlen = 1;
    698          
    699          	if (hci_send_req(&rq) < 0)
    700          		return -1;
    701          
    702          	if (status) {
    703          		return -1;
    704          	}
    705          
    706          	return 0;
    707          }
    708          
    709          int hci_read_bd_addr(tBDAddr bdaddr)
    710          {
    711          	struct hci_request rq;
    712          	read_bd_addr_rp resp;
    713          
    714          	Osal_MemSet(&resp, 0, sizeof(resp));
    715          
    716          	Osal_MemSet(&rq, 0, sizeof(rq));
    717          	rq.ogf = OGF_INFO_PARAM;
    718          	rq.ocf = OCF_READ_BD_ADDR;
    719          	rq.cparam = NULL;
    720          	rq.clen = 0;
    721          	rq.rparam = &resp;
    722          	rq.rlen = READ_BD_ADDR_RP_SIZE;
    723          
    724          	if (hci_send_req(&rq) < 0)
    725          		return -1;
    726          
    727          	if (resp.status) {
    728          		return -1;
    729          	}
    730          	Osal_MemCpy(bdaddr, resp.bdaddr, sizeof(tBDAddr));
    731          
    732          	return 0;
    733          }
    734          
    735          int hci_le_create_connection(uint16_t interval,	uint16_t window, uint8_t initiator_filter, uint8_t peer_bdaddr_type,
    736                                       const tBDAddr peer_bdaddr,	uint8_t	own_bdaddr_type, uint16_t min_interval,	uint16_t max_interval,
    737                                       uint16_t latency,	uint16_t supervision_timeout, uint16_t min_ce_length, uint16_t max_ce_length)
    738          {
    739          	struct hci_request rq;
    740          	le_create_connection_cp create_cp;
    741          	uint8_t status;
    742          
    743          	Osal_MemSet(&create_cp, 0, sizeof(create_cp));
    744          	create_cp.interval = interval;
    745          	create_cp.window =  window;
    746          	create_cp.initiator_filter = initiator_filter;
    747          	create_cp.peer_bdaddr_type = peer_bdaddr_type;
    748          	Osal_MemCpy(create_cp.peer_bdaddr, peer_bdaddr, sizeof(tBDAddr));
    749          	create_cp.own_bdaddr_type = own_bdaddr_type;
    750          	create_cp.min_interval=min_interval;
    751          	create_cp.max_interval=max_interval;
    752          	create_cp.latency = latency;
    753          	create_cp.supervision_timeout=supervision_timeout;
    754          	create_cp.min_ce_length=min_ce_length;
    755          	create_cp.max_ce_length=max_ce_length;
    756          
    757          	Osal_MemSet(&rq, 0, sizeof(rq));
    758          	rq.ogf = OGF_LE_CTL;
    759          	rq.ocf = OCF_LE_CREATE_CONN;
    760          	rq.cparam = &create_cp;
    761          	rq.clen = LE_CREATE_CONN_CP_SIZE;
    762              rq.event = EVT_CMD_STATUS;
    763          	rq.rparam = &status;
    764          	rq.rlen = 1;
    765          
    766          	if (hci_send_req(&rq) < 0)
    767          		return -1;
    768          
    769          	if (status) {
    770          		return -1;
    771          	}
    772          
    773          	return 0;
    774          }
    775          
    776          int hci_le_encrypt(uint8_t key[16], uint8_t plaintextData[16], uint8_t encryptedData[16])
    777          {
    778          	struct hci_request rq;
    779          	le_encrypt_cp params;
    780          	le_encrypt_rp resp;
    781          	
    782          	Osal_MemSet(&resp, 0, sizeof(resp));
    783          
    784          	Osal_MemCpy(params.key, key, 16);
    785          	Osal_MemCpy(params.plaintext, plaintextData, 16);
    786          
    787          	Osal_MemSet(&rq, 0, sizeof(rq));
    788          	rq.ogf = OGF_LE_CTL;
    789          	rq.ocf = OCF_LE_ENCRYPT;
    790          	rq.cparam = &params;
    791          	rq.clen = LE_ENCRYPT_CP_SIZE;
    792          	rq.rparam = &resp;
    793          	rq.rlen = LE_ENCRYPT_RP_SIZE;
    794          
    795          	if (hci_send_req(&rq) < 0){
    796          		return -1;
    797          	}
    798          
    799          	if (resp.status) {
    800          		return -1;
    801          	}
    802          	
    803          	Osal_MemCpy(encryptedData, resp.encdata, 16);
    804          
    805          	return 0;
    806          }
    807          
    808          int hci_le_ltk_request_reply(uint8_t key[16])
    809          {
    810          	struct hci_request rq;
    811          	le_ltk_reply_cp params;
    812          	le_ltk_reply_rp resp;
    813          	
    814          	Osal_MemSet(&resp, 0, sizeof(resp));
    815          
    816          	params.handle = 1;
    817          	Osal_MemCpy(params.key, key, 16);
    818          
    819          	Osal_MemSet(&rq, 0, sizeof(rq));
    820          	rq.ogf = OGF_LE_CTL;
    821          	rq.ocf = OCF_LE_LTK_REPLY;
    822          	rq.cparam = &params;
    823          	rq.clen = LE_LTK_REPLY_CP_SIZE;
    824          	rq.rparam = &resp;
    825          	rq.rlen = LE_LTK_REPLY_RP_SIZE;
    826          
    827          	if (hci_send_req(&rq) < 0)
    828          		return -1;
    829          
    830          	if (resp.status) {
    831          		return -1;
    832          	}
    833          
    834          	return 0;
    835          }
    836          
    837          int hci_le_ltk_request_neg_reply()
    838          {
    839          	struct hci_request rq;
    840          	le_ltk_neg_reply_cp params;
    841          	le_ltk_neg_reply_rp resp;
    842          	
    843          	Osal_MemSet(&resp, 0, sizeof(resp));
    844          
    845          	params.handle = 1;
    846          
    847          	Osal_MemSet(&rq, 0, sizeof(rq));
    848          	rq.ogf = OGF_LE_CTL;
    849          	rq.ocf = OCF_LE_LTK_NEG_REPLY;
    850          	rq.cparam = &params;
    851          	rq.clen = LE_LTK_NEG_REPLY_CP_SIZE;
    852          	rq.rparam = &resp;
    853          	rq.rlen = LE_LTK_NEG_REPLY_RP_SIZE;
    854          
    855          	if (hci_send_req(&rq) < 0)
    856          		return -1;
    857          
    858          	if (resp.status) {
    859          		return -1;
    860          	}
    861          
    862          	return 0;
    863          }
    864          
    865          int hci_le_read_white_list_size(uint8_t *size)
    866          {
    867          	struct hci_request rq;
    868              le_read_white_list_size_rp resp;
    869          	
    870          	Osal_MemSet(&resp, 0, sizeof(resp));
    871          
    872          	Osal_MemSet(&rq, 0, sizeof(rq));
    873          	rq.ogf = OGF_LE_CTL;
    874          	rq.ocf = OCF_LE_READ_WHITE_LIST_SIZE;
    875          	rq.rparam = &resp;
    876          	rq.rlen = LE_READ_WHITE_LIST_SIZE_RP_SIZE;
    877          
    878          	if (hci_send_req(&rq) < 0){
    879          		return -1;
    880          	}
    881          
    882          	if (resp.status) {
    883          		return -1;
    884          	}
    885              
    886              *size = resp.size;
    887          
    888          	return 0;
    889          }
    890          
    891          int hci_le_clear_white_list()
    892          {
    893          	struct hci_request rq;
    894          	uint8_t status;
    895          
    896          	Osal_MemSet(&rq, 0, sizeof(rq));
    897          	rq.ogf = OGF_LE_CTL;
    898          	rq.ocf = OCF_LE_CLEAR_WHITE_LIST;
    899          	rq.rparam = &status;
    900          	rq.rlen = 1;
    901          
    902          	if (hci_send_req(&rq) < 0){
    903          		return -1;
    904          	}
    905          
    906          	if (status) {
    907          		return -1;
    908          	}
    909          
    910          	return 0;
    911          }
    912          
    913          int hci_le_add_device_to_white_list(uint8_t	bdaddr_type, tBDAddr bdaddr)
    914          {
    915          	struct hci_request rq;
    916          	le_add_device_to_white_list_cp params;
    917          	uint8_t status;
    918          
    919          	params.bdaddr_type = bdaddr_type;
    920          	Osal_MemCpy(params.bdaddr, bdaddr, 6);
    921          
    922          	Osal_MemSet(&rq, 0, sizeof(rq));
    923          	rq.ogf = OGF_LE_CTL;
    924          	rq.ocf = OCF_LE_ADD_DEVICE_TO_WHITE_LIST;
    925          	rq.cparam = &params;
    926          	rq.clen = LE_ADD_DEVICE_TO_WHITE_LIST_CP_SIZE;
    927          	rq.rparam = &status;
    928          	rq.rlen = 1;
    929          
    930          	if (hci_send_req(&rq) < 0){
    931          		return -1;
    932          	}
    933          
    934          	if (status) {
    935          		return -1;
    936          	}
    937          
    938          	return 0;
    939          }
    940          
    941          int hci_le_remove_device_from_white_list(uint8_t bdaddr_type, tBDAddr bdaddr)
    942          {
    943          	struct hci_request rq;
    944          	le_remove_device_from_white_list_cp params;
    945          	uint8_t status;
    946          
    947          	params.bdaddr_type = bdaddr_type;
    948          	Osal_MemCpy(params.bdaddr, bdaddr, 6);
    949          
    950          	Osal_MemSet(&rq, 0, sizeof(rq));
    951          	rq.ogf = OGF_LE_CTL;
    952          	rq.ocf = OCF_LE_REMOVE_DEVICE_FROM_WHITE_LIST;
    953          	rq.cparam = &params;
    954          	rq.clen = LE_REMOVE_DEVICE_FROM_WHITE_LIST_CP_SIZE;
    955          	rq.rparam = &status;
    956          	rq.rlen = 1;
    957          
    958          	if (hci_send_req(&rq) < 0){
    959          		return -1;
    960          	}
    961          
    962          	if (status) {
    963          		return -1;
    964          	}
    965          
    966          	return 0;
    967          }
    968          
    969          int hci_read_transmit_power_level(uint16_t *conn_handle, uint8_t type, int8_t * tx_level)
    970          {
    971              struct hci_request rq;
    972          	read_transmit_power_level_cp params;
    973          	read_transmit_power_level_rp resp;
    974          	
    975          	Osal_MemSet(&resp, 0, sizeof(resp));
    976          
    977          	params.handle = *conn_handle;
    978          	params.type = type;
    979          
    980          	Osal_MemSet(&rq, 0, sizeof(rq));
    981          	rq.ogf = OGF_HOST_CTL;
    982          	rq.ocf = OCF_READ_TRANSMIT_POWER_LEVEL;
    983          	rq.cparam = &params;
    984          	rq.clen = READ_TRANSMIT_POWER_LEVEL_CP_SIZE;
    985          	rq.rparam = &resp;
    986          	rq.rlen = READ_TRANSMIT_POWER_LEVEL_RP_SIZE;
    987          
    988          	if (hci_send_req(&rq) < 0){
    989          		return -1;
    990          	}
    991          
    992          	if (resp.status) {
    993          		return -1;
    994          	}
    995          	
    996              *conn_handle = resp.handle;
    997              *tx_level = resp.handle;
    998          
    999          	return 0;
   1000          }
   1001          
   1002          int hci_read_rssi(uint16_t *conn_handle, int8_t * rssi)
   1003          {
   1004              struct hci_request rq;
   1005          	read_rssi_cp params;
   1006          	read_rssi_rp resp;
   1007          	
   1008          	Osal_MemSet(&resp, 0, sizeof(resp));
   1009          
   1010          	params.handle = *conn_handle;
   1011          
   1012          	Osal_MemSet(&rq, 0, sizeof(rq));
   1013          	rq.ogf = OGF_STATUS_PARAM;
   1014          	rq.ocf = OCF_READ_RSSI;
   1015          	rq.cparam = &params;
   1016          	rq.clen = READ_RSSI_CP_SIZE;
   1017          	rq.rparam = &resp;
   1018          	rq.rlen = READ_RSSI_RP_SIZE;
   1019          
   1020          	if (hci_send_req(&rq) < 0){
   1021          		return -1;
   1022          	}
   1023          
   1024          	if (resp.status) {
   1025          		return -1;
   1026          	}
   1027          	
   1028              *conn_handle = resp.handle;
   1029              *rssi = resp.rssi;
   1030          
   1031          	return 0;
   1032          }
   1033          
   1034          int hci_le_read_local_supported_features(uint8_t *features)
   1035          {
   1036          	struct hci_request rq;
   1037              le_read_local_supported_features_rp resp;
   1038          	
   1039          	Osal_MemSet(&resp, 0, sizeof(resp));
   1040          
   1041          	Osal_MemSet(&rq, 0, sizeof(rq));
   1042          	rq.ogf = OGF_LE_CTL;
   1043          	rq.ocf = OCF_LE_READ_LOCAL_SUPPORTED_FEATURES;
   1044          	rq.rparam = &resp;
   1045          	rq.rlen = LE_READ_LOCAL_SUPPORTED_FEATURES_RP_SIZE;
   1046          
   1047          	if (hci_send_req(&rq) < 0){
   1048          		return -1;
   1049          	}
   1050          
   1051          	if (resp.status) {
   1052          		return -1;
   1053          	}
   1054              
   1055              Osal_MemCpy(features, resp.features, sizeof(resp.features));
   1056          
   1057          	return 0;
   1058          }
   1059          
   1060          int hci_le_read_channel_map(uint16_t conn_handle, uint8_t ch_map[5])
   1061          {
   1062              struct hci_request rq;
   1063          	le_read_channel_map_cp params;
   1064          	le_read_channel_map_rp resp;
   1065          	
   1066          	Osal_MemSet(&resp, 0, sizeof(resp));
   1067          
   1068          	params.handle = conn_handle;
   1069          
   1070          	Osal_MemSet(&rq, 0, sizeof(rq));
   1071          	rq.ogf = OGF_LE_CTL;
   1072          	rq.ocf = OCF_LE_READ_CHANNEL_MAP;
   1073          	rq.cparam = &params;
   1074          	rq.clen = LE_READ_CHANNEL_MAP_CP_SIZE;
   1075          	rq.rparam = &resp;
   1076          	rq.rlen = LE_READ_CHANNEL_MAP_RP_SIZE;
   1077          
   1078          	if (hci_send_req(&rq) < 0){
   1079          		return -1;
   1080          	}
   1081          
   1082          	if (resp.status) {
   1083          		return -1;
   1084          	}
   1085              
   1086              Osal_MemCpy(ch_map, resp.map, 5);
   1087          
   1088          	return 0;
   1089          }
   1090          
   1091          int hci_le_read_supported_states(uint8_t states[8])
   1092          {
   1093          	struct hci_request rq;
   1094              le_read_supported_states_rp resp;
   1095          	
   1096          	Osal_MemSet(&resp, 0, sizeof(resp));
   1097          
   1098          	Osal_MemSet(&rq, 0, sizeof(rq));
   1099          	rq.ogf = OGF_LE_CTL;
   1100          	rq.ocf = OCF_LE_READ_SUPPORTED_STATES;
   1101          	rq.rparam = &resp;
   1102          	rq.rlen = LE_READ_SUPPORTED_STATES_RP_SIZE;
   1103          
   1104          	if (hci_send_req(&rq) < 0){
   1105          		return -1;
   1106          	}
   1107          
   1108          	if (resp.status) {
   1109          		return -1;
   1110          	}
   1111              
   1112              Osal_MemCpy(states, resp.states, 8);
   1113          
   1114          	return 0;
   1115          }
   1116          
   1117          int hci_le_receiver_test(uint8_t frequency)
   1118          {
   1119          	struct hci_request rq;
   1120          	le_receiver_test_cp params;
   1121          	uint8_t status;
   1122          
   1123          	params.frequency = frequency;
   1124          
   1125          	Osal_MemSet(&rq, 0, sizeof(rq));
   1126          	rq.ogf = OGF_LE_CTL;
   1127          	rq.ocf = OCF_LE_RECEIVER_TEST;
   1128          	rq.cparam = &params;
   1129          	rq.clen = LE_RECEIVER_TEST_CP_SIZE;
   1130          	rq.rparam = &status;
   1131          	rq.rlen = 1;
   1132          
   1133          	if (hci_send_req(&rq) < 0){
   1134          		return -1;
   1135          	}
   1136          
   1137          	if (status) {
   1138          		return -1;
   1139          	}
   1140          
   1141          	return 0;
   1142          }
   1143          
   1144          int hci_le_transmitter_test(uint8_t frequency, uint8_t length, uint8_t payload)
   1145          {
   1146          	struct hci_request rq;
   1147          	le_transmitter_test_cp params;
   1148          	uint8_t status;
   1149          
   1150          	params.frequency = frequency;
   1151              params.length = length;
   1152              params.payload = payload;
   1153          
   1154          	Osal_MemSet(&rq, 0, sizeof(rq));
   1155          	rq.ogf = OGF_LE_CTL;
   1156          	rq.ocf = OCF_LE_TRANSMITTER_TEST;
   1157          	rq.cparam = &params;
   1158          	rq.clen = LE_TRANSMITTER_TEST_CP_SIZE;
   1159          	rq.rparam = &status;
   1160          	rq.rlen = 1;
   1161          
   1162          	if (hci_send_req(&rq) < 0){
   1163          		return -1;
   1164          	}
   1165          
   1166          	if (status) {
   1167          		return -1;
   1168          	}
   1169          
   1170          	return 0;
   1171          }
   1172          
   1173          int hci_le_test_end(uint16_t *num_pkts)
   1174          {
   1175          	struct hci_request rq;
   1176              le_test_end_rp resp;
   1177          	
   1178          	Osal_MemSet(&resp, 0, sizeof(resp));
   1179          
   1180          	Osal_MemSet(&rq, 0, sizeof(rq));
   1181          	rq.ogf = OGF_LE_CTL;
   1182          	rq.ocf = OCF_LE_TEST_END;
   1183          	rq.rparam = &resp;
   1184          	rq.rlen = LE_TEST_END_RP_SIZE;
   1185          
   1186          	if (hci_send_req(&rq) < 0){
   1187          		return -1;
   1188          	}
   1189          
   1190          	if (resp.status) {
   1191          		return -1;
   1192          	}
   1193              
   1194              *num_pkts = resp.num_pkts;
   1195          
   1196          	return 0;
   1197          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HCI_Init
         8   -> list_init_head
         0   -> list_insert_tail
         8   -> list_insert_tail
      16   HCI_Input
         0   -- Indirect call
        16   -> list_insert_tail
      16   HCI_Isr
        16   -> BlueNRG_SPI_Read_All
        16   -> Clear_SPI_EXTI_Flag
        16   -> HCI_Input
        16   -> SdkEvalSPI_Irq_Pin
        16   -> list_insert_head
        16   -> list_is_empty
        16   -> list_remove_head
      88   HCI_Process
        88   -> BlueNRG_DataPresent
        88   -> BlueNRG_SPI_Read_All
        88   -> Disable_SPI_IRQ
        88   -> Enable_SPI_IRQ
        88   -> HCI_Event_CB
        88   -> list_insert_tail
        88   -> list_is_empty
        88   -> list_remove_head
      40   hci_disconnect
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   hci_le_add_device_to_white_list
        40   -> Osal_MemCpy
        40   -> Osal_MemSet
        40   -> hci_send_req
      32   hci_le_clear_white_list
        32   -> Osal_MemSet
        32   -> hci_send_req
      80   hci_le_create_connection
        80   -> Osal_MemCpy
        80   -> Osal_MemSet
        80   -> hci_send_req
      96   hci_le_encrypt
        96   -> Osal_MemCpy
        96   -> Osal_MemSet
        96   -> hci_send_req
      40   hci_le_ltk_request_neg_reply
        40   -> Osal_MemSet
        40   -> hci_send_req
      56   hci_le_ltk_request_reply
        56   -> Osal_MemCpy
        56   -> Osal_MemSet
        56   -> hci_send_req
      48   hci_le_rand
        48   -> Osal_MemCpy
        48   -> Osal_MemSet
        48   -> hci_send_req
      40   hci_le_read_advertising_channel_tx_power
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   hci_le_read_buffer_size
        40   -> Osal_MemSet
        40   -> hci_send_req
      48   hci_le_read_channel_map
        48   -> Osal_MemCpy
        48   -> Osal_MemSet
        48   -> hci_send_req
      48   hci_le_read_local_supported_features
        48   -> Osal_MemCpy
        48   -> Osal_MemSet
        48   -> hci_send_req
      56   hci_le_read_local_version
        56   -> Osal_MemSet
        56   -> hci_send_req
      48   hci_le_read_supported_states
        48   -> Osal_MemCpy
        48   -> Osal_MemSet
        48   -> hci_send_req
      40   hci_le_read_white_list_size
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   hci_le_receiver_test
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   hci_le_remove_device_from_white_list
        40   -> Osal_MemCpy
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   hci_le_set_advertise_enable
        40   -> Osal_MemSet
        40   -> hci_send_req
      72   hci_le_set_advertising_data
        72   -> Osal_MemCpy
        72   -> Osal_MemSet
        72   -> hci_send_req
      64   hci_le_set_advertising_parameters
        64   -> Osal_MemCpy
        64   -> Osal_MemSet
        64   -> hci_send_req
      48   hci_le_set_random_address
        48   -> Osal_MemCpy
        48   -> Osal_MemSet
        48   -> hci_send_req
      72   hci_le_set_scan_resp_data
        72   -> Osal_MemCpy
        72   -> Osal_MemSet
        72   -> hci_send_req
      40   hci_le_test_end
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   hci_le_transmitter_test
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   hci_read_bd_addr
        40   -> Osal_MemCpy
        40   -> Osal_MemSet
        40   -> hci_send_req
      48   hci_read_rssi
        48   -> Osal_MemSet
        48   -> hci_send_req
      48   hci_read_transmit_power_level
        48   -> Osal_MemSet
        48   -> hci_send_req
      32   hci_reset
        32   -> Osal_MemSet
        32   -> hci_send_req
      24   hci_send_cmd
        24   -> Hal_Write_Serial
        24   -> Osal_MemCpy
      48   hci_send_req
        48   -> Enable_SPI_IRQ
        48   -> Hal_Write_Serial
        48   -> Osal_MemCpy
        48   -> Timer_Expired
        48   -> Timer_Set
       0   hci_write
         0   -> Hal_Write_Serial
       8   new_hci_event
         8   -> Disable_SPI_IRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
      84  HCI_Init
     184  HCI_Input
      92  HCI_Isr
     114  HCI_Process
      78  hci_disconnect
      80  hci_le_add_device_to_white_list
      58  hci_le_clear_white_list
     158  hci_le_create_connection
     120  hci_le_encrypt
      82  hci_le_ltk_request_neg_reply
      96  hci_le_ltk_request_reply
      94  hci_le_rand
      88  hci_le_read_advertising_channel_tx_power
      96  hci_le_read_buffer_size
     102  hci_le_read_channel_map
      88  hci_le_read_local_supported_features
     120  hci_le_read_local_version
      88  hci_le_read_supported_states
      82  hci_le_read_white_list_size
      70  hci_le_receiver_test
      80  hci_le_remove_device_from_white_list
      90  hci_le_set_advertise_enable
     100  hci_le_set_advertising_data
     130  hci_le_set_advertising_parameters
      88  hci_le_set_random_address
     102  hci_le_set_scan_resp_data
      82  hci_le_test_end
      78  hci_le_transmitter_test
      94  hci_read_bd_addr
     102  hci_read_rssi
     110  hci_read_transmit_power_level
      56  hci_reset
      60  hci_send_cmd
     310  hci_send_req
       4  hci_write
      18  new_hci_event
     432  readPacketListFull
          state
          new_packet
          hci_pckt_len
          hci_buffer
          packet_complete_callback
          hciReadPktPool
          hciReadPktRxQueue
          hciReadPacketBuffer

 
   432 bytes in section .bss
 3 490 bytes in section .text
 
 3 490 bytes of CODE memory
   432 bytes of DATA memory

Errors: none
Warnings: none
