###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.60.1.5097/W32 for ARM      09/Oct/2014  13:59:08 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\FredZhou\Documents\Origin\Projects\platform\STM #
#                    32L1XX\Libraries\LIS3DH\src\lis3dh_driver.c              #
#    Command line =  C:\Users\FredZhou\Documents\Origin\Projects\platform\STM #
#                    32L1XX\Libraries\LIS3DH\src\lis3dh_driver.c -D           #
#                    USE_STDPERIPH_DRIVER -D STM32L1XX_MD -D                  #
#                    SYSCLK_FREQ_HSI_32MHz -D ENABLE_USB -D                   #
#                    ENABLE_USB_PRINTF -D CLIENT=1 -D DEBUG -D                #
#                    BLUENRG_CONFIG=BLUENRG_16_MHZ -lcN                       #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Client\List\ --diag_suppress Pa050 -o         #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Client\Obj\ --debug --endian=little           #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.5\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\inc\ -I "C:\Users\FredZhou\Documents\Origi #
#                    n\Projects\Project\BLE_Chat\EWARM\..\..\..\Bluetooth     #
#                    LE\SimpleBlueNRG_HCI\" -I "C:\Users\FredZhou\Documents\O #
#                    rigin\Projects\Project\BLE_Chat\EWARM\..\..\..\Bluetooth #
#                     LE\SimpleBlueNRG_HCI\includes\" -I                      #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\ -I               #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\ -I     #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\CMSIS\C #
#                    M3\DeviceSupport\ST\STM32L1xx\ -I                        #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32_U #
#                    SB-FS-Device_Driver\inc\ -I                              #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32L1 #
#                    xx_StdPeriph_Driver\inc\ -I                              #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\I2C\inc #
#                    \ -I C:\Users\FredZhou\Documents\Origin\Projects\Project #
#                    \BLE_Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\LI #
#                    S3DH\inc\ -I C:\Users\FredZhou\Documents\Origin\Projects #
#                    \Project\BLE_Chat\EWARM\..\..\..\platform\STM32L1XX\Libr #
#                    aries\STLM75\inc\ -I C:\Users\FredZhou\Documents\Origin\ #
#                    Projects\Project\BLE_Chat\EWARM\..\..\..\platform\STM32L #
#                    1XX\Libraries\HTS221\inc\ -I                             #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\LPS25H\ #
#                    inc\ -I C:\Users\FredZhou\Documents\Origin\Projects\Proj #
#                    ect\BLE_Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries #
#                    \SDK_Eval_STM32L\inc\ -Ohs --use_c++_inline -I           #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Client\List\lis3dh_driver.lst                 #
#    Object file  =  C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Client\Obj\lis3dh_driver.o                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\FredZhou\Documents\Origin\Projects\platform\STM32L1XX\Libraries\LIS3DH\src\lis3dh_driver.c
      1          /******************** (C) COPYRIGHT 2012 STMicroelectronics ********************
      2          * File Name          : LIS3DH_driver.c
      3          * Author             : MSH Application Team
      4          * Author             : Fabio Tota
      5          * Version            : $Revision:$
      6          * Date               : $Date:$
      7          * Description        : LIS3DH driver file
      8          *                      
      9          * HISTORY:
     10          * Date               |	Modification                    |	Author
     11          * 24/06/2011         |	Initial Revision                |	Fabio Tota
     12          * 11/06/2012         |	Support for multiple drivers in the same program |	Abhishek Anand
     13          
     14          ********************************************************************************
     15          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     16          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     17          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     18          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     19          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     20          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     21          *
     22          * THIS SOFTWARE IS SPECIFICALLY DESIGNED FOR EXCLUSIVE USE WITH ST PARTS.
     23          *
     24          *******************************************************************************/
     25          
     26          /* Includes ------------------------------------------------------------------*/
     27          #include "lis3dh_driver.h"
     28          #include "HAL_lis3dh.h"
     29          #include "stm32l1xx.h"
     30          
     31          /* Private typedef -----------------------------------------------------------*/
     32          /* Private define ------------------------------------------------------------*/
     33          /* Private macro -------------------------------------------------------------*/
     34          /* Private variables ---------------------------------------------------------*/
     35          /* Private function prototypes -----------------------------------------------*/
     36          
     37          #define LIS3DH_CS_LOW()       GPIO_ResetBits(LIS_SPI_CS_Port, LIS_SPI_CS_Pin )
     38          #define LIS3DH_CS_HIGH()      GPIO_SetBits(LIS_SPI_CS_Port, LIS_SPI_CS_Pin)
     39          
     40          /*******************************************************************************
     41          * Function Name		: LIS3DH_SpiInit
     42          * Description		: Generic Reading function. It must be fullfilled with either
     43          *			: I2C or SPI reading functions					
     44          * Input			: Register Address
     45          * Output		: Data Read
     46          * Return		: Status [MEMS_ERROR, MEMS_SUCCESS]
     47          *******************************************************************************/
     48          void LIS3DH_SpiInit(void) {
     49            
     50            SPI_InitTypeDef  SPI_InitStructure;
     51            GPIO_InitTypeDef GPIO_InitStructure;
     52            
     53            /* Enable SPI1 and GPIO clocks */
     54            RCC_AHBPeriphClockCmd(LIS_RCC_Port_SPI, ENABLE);
     55            RCC_APB2PeriphClockCmd(LIS_RCC_Periph_SPI , ENABLE);
     56            
     57            /* Connect PXx to SPI_SCK */
     58            GPIO_PinAFConfig(LIS_SPI_Port, LIS_SPI_SCK_SOURCE, LIS_SPI_AF);
     59            
     60            /* Connect PXx to SPI_MISO */
     61            GPIO_PinAFConfig(LIS_SPI_Port, LIS_SPI_MISO_SOURCE, LIS_SPI_AF); 
     62            
     63            /* Connect PXx to SPI_MOSI */
     64            GPIO_PinAFConfig(LIS_SPI_Port, LIS_SPI_MOSI_SOURCE, LIS_SPI_AF);  
     65            
     66            /* Configure SPI1 pins: SCK, MISO and MOSI */
     67            GPIO_InitStructure.GPIO_Pin = LIS_SPI_MISO_Pin | LIS_SPI_M0SI_Pin | LIS_SPI_SCK_Pin;
     68            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     69            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     70            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     71            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
     72            GPIO_Init(LIS_SPI_Port, &GPIO_InitStructure);
     73            
     74            
     75            /* SPI1 configuration */
     76            SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
     77            SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
     78            SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
     79            SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
     80            SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
     81            SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
     82            SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;
     83            SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
     84            SPI_InitStructure.SPI_CRCPolynomial = 7;
     85            SPI_Init(LIS_SPI, &SPI_InitStructure);
     86            
     87            /* Enable SPI1  */
     88            SPI_Cmd(LIS_SPI, ENABLE);
     89            
     90            /* Configure GPIO PIN for Lis Chip select */
     91            GPIO_InitStructure.GPIO_Pin = LIS_SPI_CS_Pin;
     92            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
     93            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     94            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     95            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
     96            GPIO_Init(LIS_SPI_CS_Port, &GPIO_InitStructure);
     97            
     98            /* Deselect : Chip Select high */
     99            GPIO_SetBits(LIS_SPI_Port, LIS_SPI_CS_Pin);
    100            
    101          	
    102          }
    103          
    104          /*******************************************************************************
    105          * Function Name  : LIS3DH_SPI_SendByte
    106          * Description    : Sends a Byte through the SPI interface and return the
    107          *                  Byte received from the SPI bus.
    108          * Input          : Byte : Byte send.
    109          * Output         : None
    110          * Return         : The received byte value
    111          *******************************************************************************/
    112          unsigned char LIS3DH_SPI_SendByte(unsigned char byte)
    113          {
    114            /* Loop while DR register in not emplty */
    115            while (SPI_I2S_GetFlagStatus(LIS_SPI, SPI_I2S_FLAG_TXE) == RESET);
    116            
    117            /* Send Half Word through the SPI1 peripheral */
    118            SPI_I2S_SendData(LIS_SPI, byte);
    119            
    120            /* Wait to receive a Half Word */
    121            while (SPI_I2S_GetFlagStatus(LIS_SPI, SPI_I2S_FLAG_RXNE) == RESET);
    122            
    123            /* Return the Half Word read from the SPI bus */
    124            return (unsigned char)SPI_I2S_ReceiveData(LIS_SPI);
    125          }
    126          
    127          /*******************************************************************************
    128          * Function Name		: LIS3DH_ReadReg
    129          * Description		: Generic Reading function. It must be fullfilled with either
    130          *			: I2C or SPI reading functions					
    131          * Input			: Register Address
    132          * Output		: Data REad
    133          * Return		: None
    134          *******************************************************************************/
    135          u8_t LIS3DH_ReadReg(u8_t Reg, u8_t* Data) {
    136              
    137            Reg |= 0x80;
    138            
    139            LIS3DH_CS_LOW();
    140            
    141            LIS3DH_SPI_SendByte(Reg);
    142            
    143            *Data=LIS3DH_SPI_SendByte(0x00);
    144            
    145            LIS3DH_CS_HIGH();
    146            
    147            return MEMS_SUCCESS;
    148          }
    149          
    150          
    151          /*******************************************************************************
    152          * Function Name		: LIS3DH_WriteReg
    153          * Description		: Generic Writing function. It must be fullfilled with either
    154          *			: I2C or SPI writing function
    155          * Input			: Register Address, Data to be written
    156          * Output		: None
    157          * Return		: None
    158          *******************************************************************************/
    159          u8_t LIS3DH_WriteReg(u8_t WriteAddr, u8_t Data) {
    160            
    161            LIS3DH_CS_LOW();
    162            LIS3DH_SPI_SendByte(WriteAddr);
    163          
    164            LIS3DH_SPI_SendByte(Data);
    165          
    166            LIS3DH_CS_HIGH();
    167            
    168            return MEMS_SUCCESS;
    169          }
    170          
    171          
    172          /* Private functions ---------------------------------------------------------*/
    173          
    174          /*******************************************************************************
    175          * Function Name  : LIS3DH_GetWHO_AM_I
    176          * Description    : Read identification code by WHO_AM_I register
    177          * Input          : Char to empty by Device identification Value
    178          * Output         : None
    179          * Return         : Status [value of FSS]
    180          *******************************************************************************/
    181          status_t LIS3DH_GetWHO_AM_I(u8_t* val){
    182            
    183            if( !LIS3DH_ReadReg(LIS3DH_WHO_AM_I, val) )
    184              return MEMS_ERROR;
    185            
    186            return MEMS_SUCCESS;
    187          }
    188          
    189          
    190          /*******************************************************************************
    191          * Function Name  : LIS3DH_GetStatusAUX
    192          * Description    : Read the AUX status register
    193          * Input          : Char to empty by status register buffer
    194          * Output         : None
    195          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    196          *******************************************************************************/
    197          status_t LIS3DH_GetStatusAUX(u8_t* val) {
    198            
    199            if( !LIS3DH_ReadReg(LIS3DH_STATUS_AUX, val) )
    200              return MEMS_ERROR;
    201            
    202            return MEMS_SUCCESS;  
    203          }
    204          
    205          
    206          
    207          /*******************************************************************************
    208          * Function Name  : LIS3DH_GetStatusAUXBIT
    209          * Description    : Read the AUX status register BIT
    210          * Input          : LIS3DH_STATUS_AUX_321OR, LIS3DH_STATUS_AUX_3OR, LIS3DH_STATUS_AUX_2OR, LIS3DH_STATUS_AUX_1OR,
    211                             LIS3DH_STATUS_AUX_321DA, LIS3DH_STATUS_AUX_3DA, LIS3DH_STATUS_AUX_2DA, LIS3DH_STATUS_AUX_1DA
    212          * Output         : None
    213          * Return         : Status of BIT [MEMS_ERROR, MEMS_SUCCESS]
    214          *******************************************************************************/
    215          status_t LIS3DH_GetStatusAUXBit(u8_t statusBIT, u8_t* val) {
    216            u8_t value;  
    217            
    218            if( !LIS3DH_ReadReg(LIS3DH_STATUS_AUX, &value) )
    219              return MEMS_ERROR;
    220            
    221            if(statusBIT == LIS3DH_STATUS_AUX_321OR){
    222              if(value &= LIS3DH_STATUS_AUX_321OR){     
    223                *val = MEMS_SET;
    224                return MEMS_SUCCESS;
    225              }
    226              else{  
    227                *val = MEMS_RESET;
    228                return MEMS_SUCCESS;
    229              }   
    230            }
    231            
    232            if(statusBIT == LIS3DH_STATUS_AUX_3OR){
    233              if(value &= LIS3DH_STATUS_AUX_3OR){     
    234                *val = MEMS_SET;
    235                return MEMS_SUCCESS;
    236              }
    237              else{  
    238                *val = MEMS_RESET;
    239                return MEMS_SUCCESS;
    240              }     
    241            }
    242            
    243            if(statusBIT == LIS3DH_STATUS_AUX_2OR){
    244              if(value &= LIS3DH_STATUS_AUX_2OR){     
    245                *val = MEMS_SET;
    246                return MEMS_SUCCESS;
    247              }
    248              else{  
    249                *val = MEMS_RESET;
    250                return MEMS_SUCCESS;
    251              }    
    252            }
    253            
    254            if(statusBIT == LIS3DH_STATUS_AUX_1OR){
    255              if(value &= LIS3DH_STATUS_AUX_1OR){     
    256                *val = MEMS_SET;
    257                return MEMS_SUCCESS;
    258              }
    259              else{  
    260                *val = MEMS_RESET;
    261                return MEMS_SUCCESS;
    262              }   
    263            }
    264            
    265            if(statusBIT == LIS3DH_STATUS_AUX_321DA){
    266              if(value &= LIS3DH_STATUS_AUX_321DA) {     
    267                *val = MEMS_SET;
    268                return MEMS_SUCCESS;
    269              }
    270              else{  
    271                *val = MEMS_RESET;
    272                return MEMS_SUCCESS;
    273              }   
    274            }
    275            
    276            if(statusBIT == LIS3DH_STATUS_AUX_3DA){
    277              if(value &= LIS3DH_STATUS_AUX_3DA){     
    278                *val = MEMS_SET;
    279                return MEMS_SUCCESS;
    280              }
    281              else{  
    282                *val = MEMS_RESET;
    283                return MEMS_SUCCESS;
    284              }   
    285            }
    286            
    287            if(statusBIT == LIS3DH_STATUS_AUX_2DA){
    288              if(value &= LIS3DH_STATUS_AUX_2DA){     
    289                *val = MEMS_SET;
    290                return MEMS_SUCCESS;
    291              }
    292              else{  
    293                *val = MEMS_RESET;
    294                return MEMS_SUCCESS;
    295              }  
    296            }
    297            
    298            if(statusBIT == LIS3DH_STATUS_AUX_1DA){
    299              if(value &= LIS3DH_STATUS_AUX_1DA){     
    300                *val = MEMS_SET;
    301                return MEMS_SUCCESS;
    302              }
    303              else{  
    304                *val = MEMS_RESET;
    305                return MEMS_SUCCESS;
    306              }  
    307            }  
    308            return MEMS_ERROR;
    309          }
    310          
    311          
    312          /*******************************************************************************
    313          * Function Name  : LIS3DH_SetODR
    314          * Description    : Sets LIS3DH Output Data Rate
    315          * Input          : Output Data Rate
    316          * Output         : None
    317          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    318          *******************************************************************************/
    319          status_t LIS3DH_SetODR(LIS3DH_ODR_t ov){
    320            u8_t value;
    321            
    322            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG1, &value) )
    323              return MEMS_ERROR;
    324            
    325            value &= 0x0f;
    326            value |= ov<<LIS3DH_ODR_BIT;
    327            
    328            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG1, value) )
    329              return MEMS_ERROR;
    330            
    331            return MEMS_SUCCESS;
    332          }
    333          
    334          
    335          /*******************************************************************************
    336          * Function Name  : LIS3DH_SetTemperature
    337          * Description    : Sets LIS3DH Output Temperature
    338          * Input          : MEMS_ENABLE, MEMS_DISABLE
    339          * Output         : None
    340          * Note           : For Read Temperature by LIS3DH_OUT_AUX_3, LIS3DH_SetADCAux and LIS3DH_SetBDU 
    341          				   functions must be ENABLE
    342          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    343          *******************************************************************************/
    344          status_t LIS3DH_SetTemperature(State_t state){
    345            u8_t value;
    346            
    347            if( !LIS3DH_ReadReg(LIS3DH_TEMP_CFG_REG, &value) )
    348              return MEMS_ERROR;
    349            
    350            value &= 0xBF;
    351            value |= state<<LIS3DH_TEMP_EN;
    352            
    353            if( !LIS3DH_WriteReg(LIS3DH_TEMP_CFG_REG, value) )
    354              return MEMS_ERROR;
    355            
    356            return MEMS_SUCCESS;
    357          }
    358          
    359          
    360          /*******************************************************************************
    361          * Function Name  : LIS3DH_SetADCAux
    362          * Description    : Sets LIS3DH Output ADC
    363          * Input          : MEMS_ENABLE, MEMS_DISABLE
    364          * Output         : None
    365          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    366          *******************************************************************************/
    367          status_t LIS3DH_SetADCAux(State_t state){
    368            u8_t value;
    369            
    370            if( !LIS3DH_ReadReg(LIS3DH_TEMP_CFG_REG, &value) )
    371              return MEMS_ERROR;
    372            
    373            value &= 0x7F;
    374            value |= state<<LIS3DH_ADC_PD;
    375            
    376            if( !LIS3DH_WriteReg(LIS3DH_TEMP_CFG_REG, value) )
    377              return MEMS_ERROR;
    378            
    379            return MEMS_SUCCESS;
    380          }
    381          
    382          
    383          /*******************************************************************************
    384          * Function Name  : LIS3DH_GetAuxRaw
    385          * Description    : Read the Aux Values Output Registers
    386          * Input          : Buffer to empty
    387          * Output         : Aux Values Registers buffer
    388          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    389          *******************************************************************************/
    390          status_t LIS3DH_GetAuxRaw(LIS3DH_Aux123Raw_t* buff) {
    391            u8_t valueL;
    392            u8_t valueH;
    393            
    394            if( !LIS3DH_ReadReg(LIS3DH_OUT_1_L, &valueL) )
    395              return MEMS_ERROR;
    396            
    397            if( !LIS3DH_ReadReg(LIS3DH_OUT_1_H, &valueH) )
    398              return MEMS_ERROR;
    399            
    400            buff->AUX_1 = (u16_t)( (valueH << 8) | valueL )/16;
    401            
    402            if( !LIS3DH_ReadReg(LIS3DH_OUT_2_L, &valueL) )
    403              return MEMS_ERROR;
    404            
    405            if( !LIS3DH_ReadReg(LIS3DH_OUT_2_H, &valueH) )
    406              return MEMS_ERROR;
    407            
    408            buff->AUX_2 = (u16_t)( (valueH << 8) | valueL )/16;
    409            
    410            if( !LIS3DH_ReadReg(LIS3DH_OUT_3_L, &valueL) )
    411              return MEMS_ERROR;
    412            
    413            if( !LIS3DH_ReadReg(LIS3DH_OUT_3_H, &valueH) )
    414              return MEMS_ERROR;
    415            
    416            buff->AUX_3 = (u16_t)( (valueH << 8) | valueL )/16;
    417            
    418            return MEMS_SUCCESS;  
    419          }
    420          
    421          
    422          /*******************************************************************************
    423          * Function Name  : LIS3DH_GetTempRaw
    424          * Description    : Read the Temperature Values by AUX Output Registers OUT_3_H
    425          * Input          : Buffer to empty
    426          * Output         : Temperature Values Registers buffer
    427          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    428          *******************************************************************************/
    429          status_t LIS3DH_GetTempRaw(i8_t* buff) {
    430            u8_t valueL;
    431            u8_t valueH;
    432            
    433            if( !LIS3DH_ReadReg(LIS3DH_OUT_3_L, &valueL) )
    434              return MEMS_ERROR;
    435            
    436            if( !LIS3DH_ReadReg(LIS3DH_OUT_3_H, &valueH) )
    437              return MEMS_ERROR;
    438            
    439            *buff = (i8_t)( valueH );
    440            
    441            return MEMS_SUCCESS;  
    442          }
    443          
    444          
    445          /*******************************************************************************
    446          * Function Name  : LIS3DH_SetMode
    447          * Description    : Sets LIS3DH Operating Mode
    448          * Input          : Modality (LIS3DH_NORMAL, LIS3DH_LOW_POWER, LIS3DH_POWER_DOWN)
    449          * Output         : None
    450          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    451          *******************************************************************************/
    452          status_t LIS3DH_SetMode(LIS3DH_Mode_t md) {
    453            u8_t value;
    454            u8_t value2;
    455            static   u8_t ODR_old_value;
    456            
    457            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG1, &value) )
    458              return MEMS_ERROR;
    459            
    460            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG4, &value2) )
    461              return MEMS_ERROR;
    462            
    463            if((value & 0xF0)==0) 
    464              value = value | (ODR_old_value & 0xF0); //if it comes from POWERDOWN  
    465            
    466            switch(md) {
    467              
    468            case LIS3DH_POWER_DOWN:
    469              ODR_old_value = value;
    470              value &= 0x0F;
    471              break;
    472              
    473            case LIS3DH_NORMAL:
    474              value &= 0xF7;
    475              value |= (MEMS_RESET<<LIS3DH_LPEN);
    476              value2 &= 0xF7;
    477              value2 |= (MEMS_SET<<LIS3DH_HR);   //set HighResolution_BIT
    478              break;
    479              
    480            case LIS3DH_LOW_POWER:		
    481              value &= 0xF7;
    482              value |=  (MEMS_SET<<LIS3DH_LPEN);
    483              value2 &= 0xF7;
    484              value2 |= (MEMS_RESET<<LIS3DH_HR); //reset HighResolution_BIT
    485              break;
    486              
    487            default:
    488              return MEMS_ERROR;
    489            }
    490            
    491            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG1, value) )
    492              return MEMS_ERROR;
    493            
    494            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG4, value2) )
    495              return MEMS_ERROR;  
    496            
    497            return MEMS_SUCCESS;
    498          }
    499          
    500          
    501          /*******************************************************************************
    502          * Function Name  : LIS3DH_SetAxis
    503          * Description    : Enable/Disable LIS3DH Axis
    504          * Input          : LIS3DH_X_ENABLE/DISABLE | LIS3DH_Y_ENABLE/DISABLE | LIS3DH_Z_ENABLE/DISABLE
    505          * Output         : None
    506          * Note           : You MUST use all input variable in the argument, as example
    507          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    508          *******************************************************************************/
    509          status_t LIS3DH_SetAxis(LIS3DH_Axis_t axis) {
    510            u8_t value;
    511            
    512            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG1, &value) )
    513              return MEMS_ERROR;
    514            value &= 0xF8;
    515            value |= (0x07 & axis);
    516            
    517            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG1, value) )
    518              return MEMS_ERROR;   
    519            
    520            return MEMS_SUCCESS;
    521          }
    522          
    523          
    524          /*******************************************************************************
    525          * Function Name  : LIS3DH_SetFullScale
    526          * Description    : Sets the LIS3DH FullScale
    527          * Input          : LIS3DH_FULLSCALE_2/LIS3DH_FULLSCALE_4/LIS3DH_FULLSCALE_8/LIS3DH_FULLSCALE_16
    528          * Output         : None
    529          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    530          *******************************************************************************/
    531          status_t LIS3DH_SetFullScale(LIS3DH_Fullscale_t fs) {
    532            u8_t value;
    533            
    534            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG4, &value) )
    535              return MEMS_ERROR;
    536            
    537            value &= 0xCF;	
    538            value |= (fs<<LIS3DH_FS);
    539            
    540            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG4, value) )
    541              return MEMS_ERROR;
    542            
    543            return MEMS_SUCCESS;
    544          }
    545          
    546          
    547          /*******************************************************************************
    548          * Function Name  : LIS3DH_SetBDU
    549          * Description    : Enable/Disable Block Data Update Functionality
    550          * Input          : ENABLE/DISABLE
    551          * Output         : None
    552          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    553          *******************************************************************************/
    554          status_t LIS3DH_SetBDU(State_t bdu) {
    555            u8_t value;
    556            
    557            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG4, &value) )
    558              return MEMS_ERROR;
    559            
    560            value &= 0x7F;
    561            value |= (bdu<<LIS3DH_BDU);
    562            
    563            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG4, value) )
    564              return MEMS_ERROR;
    565            
    566            return MEMS_SUCCESS;
    567          }
    568          
    569          
    570          /*******************************************************************************
    571          * Function Name  : LIS3DH_SetBLE
    572          * Description    : Set Endianess (MSB/LSB)
    573          * Input          : BLE_LSB / BLE_MSB
    574          * Output         : None
    575          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    576          *******************************************************************************/
    577          status_t LIS3DH_SetBLE(LIS3DH_Endianess_t ble) {
    578            u8_t value;
    579            
    580            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG4, &value) )
    581              return MEMS_ERROR;
    582            
    583            value &= 0xBF;	
    584            value |= (ble<<LIS3DH_BLE);
    585            
    586            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG4, value) )
    587              return MEMS_ERROR;
    588            
    589            return MEMS_SUCCESS;
    590          }
    591          
    592          
    593          /*******************************************************************************
    594          * Function Name  : LIS3DH_SetSelfTest
    595          * Description    : Set Self Test Modality
    596          * Input          : LIS3DH_SELF_TEST_DISABLE/ST_0/ST_1
    597          * Output         : None
    598          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    599          *******************************************************************************/
    600          status_t LIS3DH_SetSelfTest(LIS3DH_SelfTest_t st) {
    601            u8_t value;
    602            
    603            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG4, &value) )
    604              return MEMS_ERROR;
    605            
    606            value &= 0xF9;
    607            value |= (st<<LIS3DH_ST);
    608            
    609            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG4, value) )
    610              return MEMS_ERROR;
    611            
    612            return MEMS_SUCCESS;
    613          }
    614          
    615          
    616          /*******************************************************************************
    617          * Function Name  : LIS3DH_HPFClick
    618          * Description    : Enable/Disable High Pass Filter for click
    619          * Input          : MEMS_ENABLE/MEMS_DISABLE
    620          * Output         : None
    621          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    622          *******************************************************************************/
    623          status_t LIS3DH_HPFClickEnable(State_t hpfe) {
    624            u8_t value;
    625            
    626            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG2, &value) )
    627              return MEMS_ERROR;
    628            
    629            value &= 0xFB;
    630            value |= (hpfe<<LIS3DH_HPCLICK);
    631            
    632            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG2, value) )
    633              return MEMS_ERROR;
    634            
    635            return MEMS_SUCCESS;
    636          }
    637          
    638          
    639          /*******************************************************************************
    640          * Function Name  : LIS3DH_HPFAOI1
    641          * Description    : Enable/Disable High Pass Filter for AOI on INT_1
    642          * Input          : MEMS_ENABLE/MEMS_DISABLE
    643          * Output         : None
    644          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    645          *******************************************************************************/
    646          status_t LIS3DH_HPFAOI1Enable(State_t hpfe) {
    647            u8_t value;
    648            
    649            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG2, &value) )
    650              return MEMS_ERROR;
    651            
    652            value &= 0xFE;
    653            value |= (hpfe<<LIS3DH_HPIS1);
    654            
    655            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG2, value) )
    656              return MEMS_ERROR;
    657            
    658            return MEMS_SUCCESS;
    659          }
    660          
    661          
    662          /*******************************************************************************
    663          * Function Name  : LIS3DH_HPFAOI2
    664          * Description    : Enable/Disable High Pass Filter for AOI on INT_2
    665          * Input          : MEMS_ENABLE/MEMS_DISABLE
    666          * Output         : None
    667          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    668          *******************************************************************************/
    669          status_t LIS3DH_HPFAOI2Enable(State_t hpfe) {
    670            u8_t value;
    671            
    672            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG2, &value) )
    673              return MEMS_ERROR;
    674            
    675            value &= 0xFD;
    676            value |= (hpfe<<LIS3DH_HPIS2);
    677            
    678            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG2, value) )
    679              return MEMS_ERROR;
    680            
    681            return MEMS_SUCCESS;
    682          }
    683          
    684          
    685          /*******************************************************************************
    686          * Function Name  : LIS3DH_SetHPFMode
    687          * Description    : Set High Pass Filter Modality
    688          * Input          : LIS3DH_HPM_NORMAL_MODE_RES/LIS3DH_HPM_REF_SIGNAL/
    689          				   LIS3DH_HPM_NORMAL_MODE/LIS3DH_HPM_AUTORESET_INT
    690          * Output         : None
    691          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    692          *******************************************************************************/
    693          status_t LIS3DH_SetHPFMode(LIS3DH_HPFMode_t hpm) {
    694            u8_t value;
    695            
    696            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG2, &value) )
    697              return MEMS_ERROR;
    698            
    699            value &= 0x3F;
    700            value |= (hpm<<LIS3DH_HPM);
    701            
    702            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG2, value) )
    703              return MEMS_ERROR;
    704            
    705            return MEMS_SUCCESS;
    706          }
    707          
    708          
    709          /*******************************************************************************
    710          * Function Name  : LIS3DH_SetHPFCutOFF
    711          * Description    : Set High Pass CUT OFF Freq
    712          * Input          : HPFCF [0,3]
    713          * Output         : None
    714          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    715          *******************************************************************************/
    716          status_t LIS3DH_SetHPFCutOFF(LIS3DH_HPFCutOffFreq_t hpf) {
    717            u8_t value;
    718            
    719            if (hpf > 3)
    720              return MEMS_ERROR;
    721            
    722            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG2, &value) )
    723              return MEMS_ERROR;
    724            
    725            value &= 0xCF;
    726            value |= (hpf<<LIS3DH_HPCF);
    727            
    728            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG2, value) )
    729              return MEMS_ERROR;
    730            
    731            return MEMS_SUCCESS;
    732            
    733          }
    734          
    735          
    736          /*******************************************************************************
    737          * Function Name  : LIS3DH_SetFilterDataSel
    738          * Description    : Set Filter Data Selection bypassed or sent to FIFO OUT register
    739          * Input          : MEMS_SET, MEMS_RESET
    740          * Output         : None
    741          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    742          *******************************************************************************/
    743          status_t LIS3DH_SetFilterDataSel(State_t state) {
    744            u8_t value;
    745            
    746            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG2, &value) )
    747              return MEMS_ERROR;
    748            
    749            value &= 0xF7;
    750            value |= (state<<LIS3DH_FDS);
    751            
    752            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG2, value) )
    753              return MEMS_ERROR;
    754            
    755            return MEMS_SUCCESS;
    756            
    757          }
    758          
    759          
    760          /*******************************************************************************
    761          * Function Name  : LIS3DH_SetInt1Pin
    762          * Description    : Set Interrupt1 pin Function
    763          * Input          :  LIS3DH_CLICK_ON_PIN_INT1_ENABLE/DISABLE    | LIS3DH_I1_INT1_ON_PIN_INT1_ENABLE/DISABLE |              
    764                              LIS3DH_I1_INT2_ON_PIN_INT1_ENABLE/DISABLE  | LIS3DH_I1_DRDY1_ON_INT1_ENABLE/DISABLE    |              
    765                              LIS3DH_I1_DRDY2_ON_INT1_ENABLE/DISABLE     | LIS3DH_WTM_ON_INT1_ENABLE/DISABLE         |           
    766                              LIS3DH_INT1_OVERRUN_ENABLE/DISABLE  
    767          * example        : SetInt1Pin(LIS3DH_CLICK_ON_PIN_INT1_ENABLE | LIS3DH_I1_INT1_ON_PIN_INT1_ENABLE |              
    768                              LIS3DH_I1_INT2_ON_PIN_INT1_DISABLE | LIS3DH_I1_DRDY1_ON_INT1_ENABLE | LIS3DH_I1_DRDY2_ON_INT1_ENABLE |
    769                              LIS3DH_WTM_ON_INT1_DISABLE | LIS3DH_INT1_OVERRUN_DISABLE   ) 
    770          * Note           : To enable Interrupt signals on INT1 Pad (You MUST use all input variable in the argument, as example)
    771          * Output         : None
    772          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    773          *******************************************************************************/
    774          status_t LIS3DH_SetInt1Pin(LIS3DH_IntPinConf_t pinConf) {
    775            u8_t value;
    776            
    777            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG3, &value) )
    778              return MEMS_ERROR;
    779            
    780            value &= 0x00;
    781            value |= pinConf;
    782            
    783            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG3, value) )
    784              return MEMS_ERROR;
    785            
    786            return MEMS_SUCCESS;
    787          }
    788          
    789          
    790          /*******************************************************************************
    791          * Function Name  : LIS3DH_SetInt2Pin
    792          * Description    : Set Interrupt2 pin Function
    793          * Input          : LIS3DH_CLICK_ON_PIN_INT2_ENABLE/DISABLE   | LIS3DH_I2_INT1_ON_PIN_INT2_ENABLE/DISABLE |               
    794                             LIS3DH_I2_INT2_ON_PIN_INT2_ENABLE/DISABLE | LIS3DH_I2_BOOT_ON_INT2_ENABLE/DISABLE |                   
    795                             LIS3DH_INT_ACTIVE_HIGH/LOW
    796          * example        : LIS3DH_SetInt2Pin(LIS3DH_CLICK_ON_PIN_INT2_ENABLE/DISABLE | LIS3DH_I2_INT1_ON_PIN_INT2_ENABLE/DISABLE |               
    797                             LIS3DH_I2_INT2_ON_PIN_INT2_ENABLE/DISABLE | LIS3DH_I2_BOOT_ON_INT2_ENABLE/DISABLE |                   
    798                             LIS3DH_INT_ACTIVE_HIGH/LOW)
    799          * Note           : To enable Interrupt signals on INT2 Pad (You MUST use all input variable in the argument, as example)
    800          * Output         : None
    801          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    802          *******************************************************************************/
    803          status_t LIS3DH_SetInt2Pin(LIS3DH_IntPinConf_t pinConf) {
    804            u8_t value;
    805            
    806            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG6, &value) )
    807              return MEMS_ERROR;
    808            
    809            value &= 0x00;
    810            value |= pinConf;
    811            
    812            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG6, value) )
    813              return MEMS_ERROR;
    814            
    815            return MEMS_SUCCESS;
    816          }                       
    817          
    818          
    819          /*******************************************************************************
    820          * Function Name  : LIS3DH_SetClickCFG
    821          * Description    : Set Click Interrupt config Function
    822          * Input          : LIS3DH_ZD_ENABLE/DISABLE | LIS3DH_ZS_ENABLE/DISABLE  | LIS3DH_YD_ENABLE/DISABLE  | 
    823                             LIS3DH_YS_ENABLE/DISABLE | LIS3DH_XD_ENABLE/DISABLE  | LIS3DH_XS_ENABLE/DISABLE 
    824          * example        : LIS3DH_SetClickCFG( LIS3DH_ZD_ENABLE | LIS3DH_ZS_DISABLE | LIS3DH_YD_ENABLE | 
    825                                         LIS3DH_YS_DISABLE | LIS3DH_XD_ENABLE | LIS3DH_XS_ENABLE)
    826          * Note           : You MUST use all input variable in the argument, as example
    827          * Output         : None
    828          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    829          *******************************************************************************/
    830          status_t LIS3DH_SetClickCFG(u8_t status) {
    831            u8_t value;
    832            
    833            if( !LIS3DH_ReadReg(LIS3DH_CLICK_CFG, &value) )
    834              return MEMS_ERROR;
    835            
    836            value &= 0xC0;
    837            value |= status;
    838            
    839            if( !LIS3DH_WriteReg(LIS3DH_CLICK_CFG, value) )
    840              return MEMS_ERROR;
    841            
    842            return MEMS_SUCCESS;
    843          }  
    844          
    845          
    846          /*******************************************************************************
    847          * Function Name  : LIS3DH_SetClickTHS
    848          * Description    : Set Click Interrupt threshold
    849          * Input          : Click-click Threshold value [0-127]
    850          * Output         : None
    851          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    852          *******************************************************************************/
    853          status_t LIS3DH_SetClickTHS(u8_t ths) {
    854            
    855            if(ths>127)     
    856              return MEMS_ERROR;
    857            
    858            if( !LIS3DH_WriteReg(LIS3DH_CLICK_THS, ths) )
    859              return MEMS_ERROR;
    860            
    861            return MEMS_SUCCESS;
    862          } 
    863          
    864          
    865          /*******************************************************************************
    866          * Function Name  : LIS3DH_SetClickLIMIT
    867          * Description    : Set Click Interrupt Time Limit
    868          * Input          : Click-click Time Limit value [0-127]
    869          * Output         : None
    870          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    871          *******************************************************************************/
    872          status_t LIS3DH_SetClickLIMIT(u8_t t_limit) {
    873            
    874            if(t_limit>127)     
    875              return MEMS_ERROR;
    876            
    877            if( !LIS3DH_WriteReg(LIS3DH_TIME_LIMIT, t_limit) )
    878              return MEMS_ERROR;
    879            
    880            return MEMS_SUCCESS;
    881          } 
    882          
    883          
    884          /*******************************************************************************
    885          * Function Name  : LIS3DH_SetClickLATENCY
    886          * Description    : Set Click Interrupt Time Latency
    887          * Input          : Click-click Time Latency value [0-255]
    888          * Output         : None
    889          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    890          *******************************************************************************/
    891          status_t LIS3DH_SetClickLATENCY(u8_t t_latency) {
    892            
    893            if( !LIS3DH_WriteReg(LIS3DH_TIME_LATENCY, t_latency) )
    894              return MEMS_ERROR;
    895            
    896            return MEMS_SUCCESS;
    897          } 
    898          
    899          
    900          /*******************************************************************************
    901          * Function Name  : LIS3DH_SetClickWINDOW
    902          * Description    : Set Click Interrupt Time Window
    903          * Input          : Click-click Time Window value [0-255]
    904          * Output         : None
    905          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    906          *******************************************************************************/
    907          status_t LIS3DH_SetClickWINDOW(u8_t t_window) {
    908            
    909            if( !LIS3DH_WriteReg(LIS3DH_TIME_WINDOW, t_window) )
    910              return MEMS_ERROR;
    911            
    912            return MEMS_SUCCESS;
    913          }
    914          
    915          
    916          /*******************************************************************************
    917          * Function Name  : LIS3DH_GetClickResponse
    918          * Description    : Get Click Interrupt Response by CLICK_SRC REGISTER
    919          * Input          : char to empty by Click Response Typedef
    920          * Output         : None
    921          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
    922          *******************************************************************************/
    923          status_t LIS3DH_GetClickResponse(u8_t* res) {
    924            u8_t value;
    925            
    926            if( !LIS3DH_ReadReg(LIS3DH_CLICK_SRC, &value) ) 
    927              return MEMS_ERROR;
    928            
    929            value &= 0x7F;
    930            
    931            if((value & LIS3DH_IA)==0) {        
    932              *res = LIS3DH_NO_CLICK;     
    933              return MEMS_SUCCESS;
    934            }
    935            else {
    936              if (value & LIS3DH_DCLICK){
    937                if (value & LIS3DH_CLICK_SIGN){
    938                  if (value & LIS3DH_CLICK_Z) {
    939                    *res = LIS3DH_DCLICK_Z_N;   
    940                    return MEMS_SUCCESS;
    941                  }
    942                  if (value & LIS3DH_CLICK_Y) {
    943                    *res = LIS3DH_DCLICK_Y_N;   
    944                    return MEMS_SUCCESS;
    945                  }
    946                  if (value & LIS3DH_CLICK_X) {
    947                    *res = LIS3DH_DCLICK_X_N;   
    948                    return MEMS_SUCCESS;
    949                  }
    950                }
    951                else{
    952                  if (value & LIS3DH_CLICK_Z) {
    953                    *res = LIS3DH_DCLICK_Z_P;   
    954                    return MEMS_SUCCESS;
    955                  }
    956                  if (value & LIS3DH_CLICK_Y) {
    957                    *res = LIS3DH_DCLICK_Y_P;   
    958                    return MEMS_SUCCESS;
    959                  }
    960                  if (value & LIS3DH_CLICK_X) {
    961                    *res = LIS3DH_DCLICK_X_P;   
    962                    return MEMS_SUCCESS;
    963                  }
    964                }       
    965              }
    966              else{
    967                if (value & LIS3DH_CLICK_SIGN){
    968                  if (value & LIS3DH_CLICK_Z) {
    969                    *res = LIS3DH_SCLICK_Z_N;   
    970                    return MEMS_SUCCESS;
    971                  }
    972                  if (value & LIS3DH_CLICK_Y) {
    973                    *res = LIS3DH_SCLICK_Y_N;   
    974                    return MEMS_SUCCESS;
    975                  }
    976                  if (value & LIS3DH_CLICK_X) {
    977                    *res = LIS3DH_SCLICK_X_N;   
    978                    return MEMS_SUCCESS;
    979                  }
    980                }
    981                else{
    982                  if (value & LIS3DH_CLICK_Z) {
    983                    *res = LIS3DH_SCLICK_Z_P;   
    984                    return MEMS_SUCCESS;
    985                  }
    986                  if (value & LIS3DH_CLICK_Y) {
    987                    *res = LIS3DH_SCLICK_Y_P;   
    988                    return MEMS_SUCCESS;
    989                  }
    990                  if (value & LIS3DH_CLICK_X) {
    991                    *res = LIS3DH_SCLICK_X_P;   
    992                    return MEMS_SUCCESS;
    993                  }
    994                }
    995              }
    996            }
    997            return MEMS_ERROR;
    998          } 
    999          
   1000          
   1001          /*******************************************************************************
   1002          * Function Name  : LIS3DH_Int1LatchEnable
   1003          * Description    : Enable Interrupt 1 Latching function
   1004          * Input          : ENABLE/DISABLE
   1005          * Output         : None
   1006          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
   1007          *******************************************************************************/
   1008          status_t LIS3DH_Int1LatchEnable(State_t latch) {
   1009            u8_t value;
   1010            
   1011            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG5, &value) )
   1012              return MEMS_ERROR;
   1013            
   1014            value &= 0xF7;
   1015            value |= latch<<LIS3DH_LIR_INT1;
   1016            
   1017            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG5, value) )
   1018              return MEMS_ERROR;
   1019            
   1020            return MEMS_SUCCESS;
   1021          }
   1022          
   1023          
   1024          /*******************************************************************************
   1025          * Function Name  : LIS3DH_ResetInt1Latch
   1026          * Description    : Reset Interrupt 1 Latching function
   1027          * Input          : None
   1028          * Output         : None
   1029          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
   1030          *******************************************************************************/
   1031          status_t LIS3DH_ResetInt1Latch(void) {
   1032            u8_t value;
   1033            
   1034            if( !LIS3DH_ReadReg(LIS3DH_INT1_SRC, &value) )
   1035              return MEMS_ERROR;
   1036            
   1037            return MEMS_SUCCESS;
   1038          }
   1039          
   1040          
   1041          /*******************************************************************************
   1042          * Function Name  : LIS3DH_SetIntConfiguration
   1043          * Description    : Interrupt 1 Configuration (without LIS3DH_6D_INT)
   1044          * Input          : LIS3DH_INT1_AND/OR | LIS3DH_INT1_ZHIE_ENABLE/DISABLE | LIS3DH_INT1_ZLIE_ENABLE/DISABLE...
   1045          * Output         : None
   1046          * Note           : You MUST use all input variable in the argument, as example
   1047          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
   1048          *******************************************************************************/
   1049          status_t LIS3DH_SetIntConfiguration(LIS3DH_Int1Conf_t ic) {
   1050            u8_t value;
   1051            
   1052            if( !LIS3DH_ReadReg(LIS3DH_INT1_CFG, &value) )
   1053              return MEMS_ERROR;
   1054            
   1055            value &= 0x40; 
   1056            value |= ic;
   1057            
   1058            if( !LIS3DH_WriteReg(LIS3DH_INT1_CFG, value) )
   1059              return MEMS_ERROR;
   1060            
   1061            return MEMS_SUCCESS;
   1062          } 
   1063          
   1064               
   1065          /*******************************************************************************
   1066          * Function Name  : LIS3DH_SetIntMode
   1067          * Description    : Interrupt 1 Configuration mode (OR, 6D Movement, AND, 6D Position)
   1068          * Input          : LIS3DH_INT_MODE_OR, LIS3DH_INT_MODE_6D_MOVEMENT, LIS3DH_INT_MODE_AND, 
   1069          				   LIS3DH_INT_MODE_6D_POSITION
   1070          * Output         : None
   1071          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
   1072          *******************************************************************************/
   1073          status_t LIS3DH_SetIntMode(LIS3DH_Int1Mode_t int_mode) {
   1074            u8_t value;
   1075            
   1076            if( !LIS3DH_ReadReg(LIS3DH_INT1_CFG, &value) )
   1077              return MEMS_ERROR;
   1078            
   1079            value &= 0x3F; 
   1080            value |= (int_mode<<LIS3DH_INT_6D);
   1081            
   1082            if( !LIS3DH_WriteReg(LIS3DH_INT1_CFG, value) )
   1083              return MEMS_ERROR;
   1084            
   1085            return MEMS_SUCCESS;
   1086          }
   1087          
   1088              
   1089          /*******************************************************************************
   1090          * Function Name  : LIS3DH_SetInt6D4DConfiguration
   1091          * Description    : 6D, 4D Interrupt Configuration
   1092          * Input          : LIS3DH_INT1_6D_ENABLE, LIS3DH_INT1_4D_ENABLE, LIS3DH_INT1_6D_4D_DISABLE
   1093          * Output         : None
   1094          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
   1095          *******************************************************************************/
   1096          status_t LIS3DH_SetInt6D4DConfiguration(LIS3DH_INT_6D_4D_t ic) {
   1097            u8_t value;
   1098            u8_t value2;
   1099            
   1100            if( !LIS3DH_ReadReg(LIS3DH_INT1_CFG, &value) )
   1101              return MEMS_ERROR;
   1102            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG5, &value2) )
   1103              return MEMS_ERROR;
   1104            
   1105            if(ic == LIS3DH_INT1_6D_ENABLE){
   1106              value &= 0xBF; 
   1107              value |= (MEMS_ENABLE<<LIS3DH_INT_6D);
   1108              value2 &= 0xFB; 
   1109              value2 |= (MEMS_DISABLE<<LIS3DH_D4D_INT1);
   1110            }
   1111            
   1112            if(ic == LIS3DH_INT1_4D_ENABLE){
   1113              value &= 0xBF; 
   1114              value |= (MEMS_ENABLE<<LIS3DH_INT_6D);
   1115              value2 &= 0xFB; 
   1116              value2 |= (MEMS_ENABLE<<LIS3DH_D4D_INT1);
   1117            }
   1118            
   1119            if(ic == LIS3DH_INT1_6D_4D_DISABLE){
   1120              value &= 0xBF; 
   1121              value |= (MEMS_DISABLE<<LIS3DH_INT_6D);
   1122              value2 &= 0xFB; 
   1123              value2 |= (MEMS_DISABLE<<LIS3DH_D4D_INT1);
   1124            }
   1125            
   1126            if( !LIS3DH_WriteReg(LIS3DH_INT1_CFG, value) )
   1127              return MEMS_ERROR;
   1128            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG5, value2) )
   1129              return MEMS_ERROR;
   1130            
   1131            return MEMS_SUCCESS;
   1132          }
   1133          
   1134          
   1135          /*******************************************************************************
   1136          * Function Name  : LIS3DH_Get6DPosition
   1137          * Description    : 6D, 4D Interrupt Position Detect
   1138          * Input          : Byte to empty by POSITION_6D_t Typedef
   1139          * Output         : None
   1140          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
   1141          *******************************************************************************/
   1142          status_t LIS3DH_Get6DPosition(u8_t* val){
   1143            u8_t value;
   1144            
   1145            if( !LIS3DH_ReadReg(LIS3DH_INT1_SRC, &value) )
   1146              return MEMS_ERROR;
   1147            
   1148            value &= 0x7F;
   1149            
   1150            switch (value){
   1151            case LIS3DH_UP_SX:   
   1152              *val = LIS3DH_UP_SX;    
   1153              break;
   1154            case LIS3DH_UP_DX:   
   1155              *val = LIS3DH_UP_DX;    
   1156              break;
   1157            case LIS3DH_DW_SX:   
   1158              *val = LIS3DH_DW_SX;    
   1159              break;
   1160            case LIS3DH_DW_DX:   
   1161              *val = LIS3DH_DW_DX;    
   1162              break;
   1163            case LIS3DH_TOP:     
   1164              *val = LIS3DH_TOP;      
   1165              break;
   1166            case LIS3DH_BOTTOM:  
   1167              *val = LIS3DH_BOTTOM;   
   1168              break;
   1169            }
   1170            
   1171            return MEMS_SUCCESS;  
   1172          }
   1173          
   1174          
   1175          /*******************************************************************************
   1176          * Function Name  : LIS3DH_SetInt1Threshold
   1177          * Description    : Sets Interrupt 1 Threshold
   1178          * Input          : Threshold = [0,31]
   1179          * Output         : None
   1180          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
   1181          *******************************************************************************/
   1182          status_t LIS3DH_SetInt1Threshold(u8_t ths) {
   1183            if (ths > 127)
   1184              return MEMS_ERROR;
   1185            
   1186            if( !LIS3DH_WriteReg(LIS3DH_INT1_THS, ths) )
   1187              return MEMS_ERROR;    
   1188            
   1189            return MEMS_SUCCESS;
   1190          }
   1191          
   1192          
   1193          /*******************************************************************************
   1194          * Function Name  : LIS3DH_SetInt1Duration
   1195          * Description    : Sets Interrupt 1 Duration
   1196          * Input          : Duration value
   1197          * Output         : None
   1198          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
   1199          *******************************************************************************/
   1200          status_t LIS3DH_SetInt1Duration(LIS3DH_Int1Conf_t id) {
   1201            
   1202            if (id > 127)
   1203              return MEMS_ERROR;
   1204            
   1205            if( !LIS3DH_WriteReg(LIS3DH_INT1_DURATION, id) )
   1206              return MEMS_ERROR;
   1207            
   1208            return MEMS_SUCCESS;
   1209          }
   1210          
   1211          
   1212          /*******************************************************************************
   1213          * Function Name  : LIS3DH_FIFOModeEnable
   1214          * Description    : Sets Fifo Modality
   1215          * Input          : LIS3DH_FIFO_DISABLE, LIS3DH_FIFO_BYPASS_MODE, LIS3DH_FIFO_MODE, 
   1216          				   LIS3DH_FIFO_STREAM_MODE, LIS3DH_FIFO_TRIGGER_MODE
   1217          * Output         : None
   1218          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
   1219          *******************************************************************************/
   1220          status_t LIS3DH_FIFOModeEnable(LIS3DH_FifoMode_t fm) {
   1221            u8_t value;  
   1222            
   1223            if(fm == LIS3DH_FIFO_DISABLE) { 
   1224              if( !LIS3DH_ReadReg(LIS3DH_FIFO_CTRL_REG, &value) )
   1225                return MEMS_ERROR;
   1226              
   1227              value &= 0x1F;
   1228              value |= (LIS3DH_FIFO_BYPASS_MODE<<LIS3DH_FM);                     
   1229              
   1230              if( !LIS3DH_WriteReg(LIS3DH_FIFO_CTRL_REG, value) )           //fifo mode bypass
   1231                return MEMS_ERROR;   
   1232              if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG5, &value) )
   1233                return MEMS_ERROR;
   1234              
   1235              value &= 0xBF;    
   1236              
   1237              if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG5, value) )               //fifo disable
   1238                return MEMS_ERROR;   
   1239            }
   1240            
   1241            if(fm == LIS3DH_FIFO_BYPASS_MODE)   {  
   1242              if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG5, &value) )
   1243                return MEMS_ERROR;
   1244              
   1245              value &= 0xBF;
   1246              value |= MEMS_SET<<LIS3DH_FIFO_EN;
   1247              
   1248              if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG5, value) )               //fifo enable
   1249                return MEMS_ERROR;  
   1250              if( !LIS3DH_ReadReg(LIS3DH_FIFO_CTRL_REG, &value) )
   1251                return MEMS_ERROR;
   1252              
   1253              value &= 0x1f;
   1254              value |= (fm<<LIS3DH_FM);                     //fifo mode configuration
   1255              
   1256              if( !LIS3DH_WriteReg(LIS3DH_FIFO_CTRL_REG, value) )
   1257                return MEMS_ERROR;
   1258            }
   1259            
   1260            if(fm == LIS3DH_FIFO_MODE)   {
   1261              if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG5, &value) )
   1262                return MEMS_ERROR;
   1263              
   1264              value &= 0xBF;
   1265              value |= MEMS_SET<<LIS3DH_FIFO_EN;
   1266              
   1267              if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG5, value) )               //fifo enable
   1268                return MEMS_ERROR;  
   1269              if( !LIS3DH_ReadReg(LIS3DH_FIFO_CTRL_REG, &value) )
   1270                return MEMS_ERROR;
   1271              
   1272              value &= 0x1f;
   1273              value |= (fm<<LIS3DH_FM);                      //fifo mode configuration
   1274              
   1275              if( !LIS3DH_WriteReg(LIS3DH_FIFO_CTRL_REG, value) )
   1276                return MEMS_ERROR;
   1277            }
   1278            
   1279            if(fm == LIS3DH_FIFO_STREAM_MODE)   {  
   1280              if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG5, &value) )
   1281                return MEMS_ERROR;
   1282              
   1283              value &= 0xBF;
   1284              value |= MEMS_SET<<LIS3DH_FIFO_EN;
   1285              
   1286              if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG5, value) )               //fifo enable
   1287                return MEMS_ERROR;   
   1288              if( !LIS3DH_ReadReg(LIS3DH_FIFO_CTRL_REG, &value) )
   1289                return MEMS_ERROR;
   1290              
   1291              value &= 0x1f;
   1292              value |= (fm<<LIS3DH_FM);                      //fifo mode configuration
   1293              
   1294              if( !LIS3DH_WriteReg(LIS3DH_FIFO_CTRL_REG, value) )
   1295                return MEMS_ERROR;
   1296            }
   1297            
   1298            if(fm == LIS3DH_FIFO_TRIGGER_MODE)   {  
   1299              if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG5, &value) )
   1300                return MEMS_ERROR;
   1301              
   1302              value &= 0xBF;
   1303              value |= MEMS_SET<<LIS3DH_FIFO_EN;
   1304              
   1305              if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG5, value) )               //fifo enable
   1306                return MEMS_ERROR;    
   1307              if( !LIS3DH_ReadReg(LIS3DH_FIFO_CTRL_REG, &value) )
   1308                return MEMS_ERROR;
   1309              
   1310              value &= 0x1f;
   1311              value |= (fm<<LIS3DH_FM);                      //fifo mode configuration
   1312              
   1313              if( !LIS3DH_WriteReg(LIS3DH_FIFO_CTRL_REG, value) )
   1314                return MEMS_ERROR;
   1315            }
   1316            
   1317            return MEMS_SUCCESS;
   1318          }
   1319          
   1320          
   1321          /*******************************************************************************
   1322          * Function Name  : LIS3DH_SetTriggerInt
   1323          * Description    : Trigger event liked to trigger signal INT1/INT2
   1324          * Input          : LIS3DH_TRIG_INT1/LIS3DH_TRIG_INT2
   1325          * Output         : None
   1326          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
   1327          *******************************************************************************/
   1328          status_t LIS3DH_SetTriggerInt(LIS3DH_TrigInt_t tr) {
   1329            u8_t value;  
   1330            
   1331            if( !LIS3DH_ReadReg(LIS3DH_FIFO_CTRL_REG, &value) )
   1332              return MEMS_ERROR;
   1333            
   1334            value &= 0xDF;
   1335            value |= (tr<<LIS3DH_TR); 
   1336            
   1337            if( !LIS3DH_WriteReg(LIS3DH_FIFO_CTRL_REG, value) )
   1338              return MEMS_ERROR;
   1339            
   1340            return MEMS_SUCCESS;
   1341          }
   1342          
   1343          
   1344          /*******************************************************************************
   1345          * Function Name  : LIS3DH_SetWaterMark
   1346          * Description    : Sets Watermark Value
   1347          * Input          : Watermark = [0,31]
   1348          * Output         : None
   1349          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
   1350          *******************************************************************************/
   1351          status_t LIS3DH_SetWaterMark(u8_t wtm) {
   1352            u8_t value;
   1353            
   1354            if(wtm > 31)
   1355              return MEMS_ERROR;  
   1356            
   1357            if( !LIS3DH_ReadReg(LIS3DH_FIFO_CTRL_REG, &value) )
   1358              return MEMS_ERROR;
   1359            
   1360            value &= 0xE0;
   1361            value |= wtm; 
   1362            
   1363            if( !LIS3DH_WriteReg(LIS3DH_FIFO_CTRL_REG, value) )
   1364              return MEMS_ERROR;
   1365            
   1366            return MEMS_SUCCESS;
   1367          }
   1368          
   1369            
   1370          /*******************************************************************************
   1371          * Function Name  : LIS3DH_GetStatusReg
   1372          * Description    : Read the status register
   1373          * Input          : char to empty by Status Reg Value
   1374          * Output         : None
   1375          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
   1376          *******************************************************************************/
   1377          status_t LIS3DH_GetStatusReg(u8_t* val) {
   1378            if( !LIS3DH_ReadReg(LIS3DH_STATUS_REG, val) )
   1379              return MEMS_ERROR;
   1380            
   1381            return MEMS_SUCCESS;  
   1382          }
   1383          
   1384          
   1385          /*******************************************************************************
   1386          * Function Name  : LIS3DH_GetStatusBIT
   1387          * Description    : Read the status register BIT
   1388          * Input          : LIS3DH_STATUS_REG_ZYXOR, LIS3DH_STATUS_REG_ZOR, LIS3DH_STATUS_REG_YOR, LIS3DH_STATUS_REG_XOR,
   1389                             LIS3DH_STATUS_REG_ZYXDA, LIS3DH_STATUS_REG_ZDA, LIS3DH_STATUS_REG_YDA, LIS3DH_STATUS_REG_XDA, 
   1390          				   LIS3DH_DATAREADY_BIT
   1391          				   val: Byte to be filled with the status bit	
   1392          * Output         : status register BIT
   1393          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
   1394          *******************************************************************************/
   1395          status_t LIS3DH_GetStatusBit(u8_t statusBIT, u8_t* val) {
   1396            u8_t value;  
   1397            
   1398            if( !LIS3DH_ReadReg(LIS3DH_STATUS_REG, &value) )
   1399              return MEMS_ERROR;
   1400            
   1401            switch (statusBIT){
   1402            case LIS3DH_STATUS_REG_ZYXOR:     
   1403              if(value &= LIS3DH_STATUS_REG_ZYXOR){     
   1404                *val = MEMS_SET;
   1405                return MEMS_SUCCESS;
   1406              }
   1407              else{  
   1408                *val = MEMS_RESET;
   1409                return MEMS_SUCCESS;
   1410              }  
   1411            case LIS3DH_STATUS_REG_ZOR:       
   1412              if(value &= LIS3DH_STATUS_REG_ZOR){     
   1413                *val = MEMS_SET;
   1414                return MEMS_SUCCESS;
   1415              }
   1416              else{  
   1417                *val = MEMS_RESET;
   1418                return MEMS_SUCCESS;
   1419              }  
   1420            case LIS3DH_STATUS_REG_YOR:       
   1421              if(value &= LIS3DH_STATUS_REG_YOR){     
   1422                *val = MEMS_SET;
   1423                return MEMS_SUCCESS;
   1424              }
   1425              else{  
   1426                *val = MEMS_RESET;
   1427                return MEMS_SUCCESS;
   1428              }                                 
   1429            case LIS3DH_STATUS_REG_XOR:       
   1430              if(value &= LIS3DH_STATUS_REG_XOR){     
   1431                *val = MEMS_SET;
   1432                return MEMS_SUCCESS;
   1433              }
   1434              else{  
   1435                *val = MEMS_RESET;
   1436                return MEMS_SUCCESS;
   1437              }     
   1438            case LIS3DH_STATUS_REG_ZYXDA:     
   1439              if(value &= LIS3DH_STATUS_REG_ZYXDA){     
   1440                *val = MEMS_SET;
   1441                return MEMS_SUCCESS;
   1442              }
   1443              else{  
   1444                *val = MEMS_RESET;
   1445                return MEMS_SUCCESS;
   1446              }   
   1447            case LIS3DH_STATUS_REG_ZDA:       
   1448              if(value &= LIS3DH_STATUS_REG_ZDA){     
   1449                *val = MEMS_SET;
   1450                return MEMS_SUCCESS;
   1451              }
   1452              else{  
   1453                *val = MEMS_RESET;
   1454                return MEMS_SUCCESS;
   1455              }   
   1456            case LIS3DH_STATUS_REG_YDA:       
   1457              if(value &= LIS3DH_STATUS_REG_YDA){     
   1458                *val = MEMS_SET;
   1459                return MEMS_SUCCESS;
   1460              }
   1461              else{  
   1462                *val = MEMS_RESET;
   1463                return MEMS_SUCCESS;
   1464              }   
   1465            case LIS3DH_STATUS_REG_XDA:       
   1466              if(value &= LIS3DH_STATUS_REG_XDA){     
   1467                *val = MEMS_SET;
   1468                return MEMS_SUCCESS;
   1469              }
   1470              else{  
   1471                *val = MEMS_RESET;
   1472                return MEMS_SUCCESS;
   1473              }                                  
   1474              
   1475            }
   1476            return MEMS_ERROR;
   1477          }
   1478          
   1479          
   1480          /*******************************************************************************
   1481          * Function Name  : LIS3DH_GetAccAxesRaw
   1482          * Description    : Read the Acceleration Values Output Registers
   1483          * Input          : buffer to empity by AxesRaw_t Typedef
   1484          * Output         : None
   1485          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
   1486          *******************************************************************************/
   1487          status_t LIS3DH_GetAccAxesRaw(AxesRaw_t* buff) {
   1488            i16_t value;
   1489            u8_t *valueL = (u8_t *)(&value);
   1490            u8_t *valueH = ((u8_t *)(&value)+1);
   1491            
   1492            if( !LIS3DH_ReadReg(LIS3DH_OUT_X_L, valueL) )
   1493              return MEMS_ERROR;
   1494            
   1495            if( !LIS3DH_ReadReg(LIS3DH_OUT_X_H, valueH) )
   1496              return MEMS_ERROR;
   1497            
   1498            buff->AXIS_X = value;
   1499            
   1500            if( !LIS3DH_ReadReg(LIS3DH_OUT_Y_L, valueL) )
   1501              return MEMS_ERROR;
   1502            
   1503            if( !LIS3DH_ReadReg(LIS3DH_OUT_Y_H, valueH) )
   1504              return MEMS_ERROR;
   1505            
   1506            buff->AXIS_Y = value;
   1507            
   1508            if( !LIS3DH_ReadReg(LIS3DH_OUT_Z_L, valueL) )
   1509              return MEMS_ERROR;
   1510            
   1511            if( !LIS3DH_ReadReg(LIS3DH_OUT_Z_H, valueH) )
   1512              return MEMS_ERROR;
   1513            
   1514            buff->AXIS_Z = value;
   1515            
   1516            return MEMS_SUCCESS; 
   1517          }
   1518          
   1519          /*******************************************************************************
   1520          * Function Name  : LIS3DH_ConvAccValue
   1521          * Description    : Convert the raw acceleration data to value in mg units
   1522          * Input          : raw data to be converted
   1523          * Output         : converted data with value in mg units
   1524          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
   1525          *******************************************************************************/
   1526          status_t LIS3DH_ConvAccValue(AxesRaw_t* data)
   1527          {
   1528            
   1529            u8_t crtl4;
   1530            u8_t sensitivity;
   1531            
   1532            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG4, &crtl4) )
   1533              return MEMS_ERROR;
   1534            
   1535            /* switch the sensitivity value set in the CRTL4*/
   1536            switch(crtl4 & 0x30)
   1537            {
   1538            case 0x00:
   1539              sensitivity = LIS3DH_Acc_Sensitivity_2g;
   1540              break;
   1541            case 0x10:
   1542              sensitivity = LIS3DH_Acc_Sensitivity_4g;
   1543              break;
   1544            case 0x20:
   1545              sensitivity = LIS3DH_Acc_Sensitivity_8g;
   1546              break;
   1547            case 0x30:
   1548              sensitivity = LIS3DH_Acc_Sensitivity_16g;
   1549              break;
   1550            }    
   1551            
   1552            data->AXIS_X = (data->AXIS_X >> 4)*sensitivity;
   1553            data->AXIS_Y = (data->AXIS_Y >> 4)*sensitivity;
   1554            data->AXIS_Z = (data->AXIS_Z >> 4)*sensitivity;
   1555            
   1556            return MEMS_SUCCESS;
   1557          }
   1558          
   1559          
   1560          /*******************************************************************************
   1561          * Function Name  : LIS3DH_GetInt1Src
   1562          * Description    : Reset Interrupt 1 Latching function
   1563          * Input          : Char to empty by Int1 source value
   1564          * Output         : None
   1565          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
   1566          *******************************************************************************/
   1567          status_t LIS3DH_GetInt1Src(u8_t* val) {
   1568            
   1569            if( !LIS3DH_ReadReg(LIS3DH_INT1_SRC, val) )
   1570              return MEMS_ERROR;
   1571            
   1572            return MEMS_SUCCESS;
   1573          }
   1574          
   1575          
   1576          /*******************************************************************************
   1577          * Function Name  : LIS3DH_GetInt1SrcBit
   1578          * Description    : Reset Interrupt 1 Latching function
   1579          * Input          : statusBIT: LIS3DH_INT_SRC_IA, LIS3DH_INT_SRC_ZH, LIS3DH_INT_SRC_ZL.....
   1580          *                  val: Byte to be filled with the status bit
   1581          * Output         : None
   1582          * Return         : Status of BIT [MEMS_ERROR, MEMS_SUCCESS]
   1583          *******************************************************************************/
   1584          status_t LIS3DH_GetInt1SrcBit(u8_t statusBIT, u8_t* val) {
   1585            u8_t value;  
   1586             
   1587            if( !LIS3DH_ReadReg(LIS3DH_INT1_SRC, &value) )
   1588                return MEMS_ERROR;
   1589             
   1590            if(statusBIT == LIS3DH_INT1_SRC_IA){
   1591              if(value &= LIS3DH_INT1_SRC_IA){     
   1592                *val = MEMS_SET;
   1593                return MEMS_SUCCESS;
   1594              }
   1595              else{  
   1596                *val = MEMS_RESET;
   1597                return MEMS_SUCCESS;
   1598              }  
   1599            }
   1600            
   1601            if(statusBIT == LIS3DH_INT1_SRC_ZH){
   1602              if(value &= LIS3DH_INT1_SRC_ZH){     
   1603                *val = MEMS_SET;
   1604                return MEMS_SUCCESS;
   1605              }
   1606              else{  
   1607                *val = MEMS_RESET;
   1608                return MEMS_SUCCESS;
   1609              }  
   1610            }
   1611            
   1612            if(statusBIT == LIS3DH_INT1_SRC_ZL){
   1613              if(value &= LIS3DH_INT1_SRC_ZL){     
   1614                *val = MEMS_SET;
   1615                return MEMS_SUCCESS;
   1616              }
   1617              else{  
   1618                *val = MEMS_RESET;
   1619                return MEMS_SUCCESS;
   1620              }  
   1621            }
   1622            
   1623            if(statusBIT == LIS3DH_INT1_SRC_YH){
   1624              if(value &= LIS3DH_INT1_SRC_YH){     
   1625                *val = MEMS_SET;
   1626                return MEMS_SUCCESS;
   1627              }
   1628              else{  
   1629                *val = MEMS_RESET;
   1630                return MEMS_SUCCESS;
   1631              }  
   1632            }
   1633            
   1634            if(statusBIT == LIS3DH_INT1_SRC_YL){
   1635              if(value &= LIS3DH_INT1_SRC_YL){     
   1636                *val = MEMS_SET;
   1637                return MEMS_SUCCESS;
   1638              }
   1639              else{  
   1640                *val = MEMS_RESET;
   1641                return MEMS_SUCCESS;
   1642              }  
   1643            }
   1644            if(statusBIT == LIS3DH_INT1_SRC_XH){
   1645              if(value &= LIS3DH_INT1_SRC_XH){     
   1646                *val = MEMS_SET;
   1647                return MEMS_SUCCESS;
   1648              }
   1649              else{  
   1650                *val = MEMS_RESET;
   1651                return MEMS_SUCCESS;
   1652              }  
   1653            }
   1654            
   1655            if(statusBIT == LIS3DH_INT1_SRC_XL){
   1656              if(value &= LIS3DH_INT1_SRC_XL){     
   1657                *val = MEMS_SET;
   1658                return MEMS_SUCCESS;
   1659              }
   1660              else{  
   1661                *val = MEMS_RESET;
   1662                return MEMS_SUCCESS;
   1663              }  
   1664            }
   1665            return MEMS_ERROR;
   1666          }
   1667          
   1668          
   1669          /*******************************************************************************
   1670          * Function Name  : LIS3DH_GetFifoSourceReg
   1671          * Description    : Read Fifo source Register
   1672          * Input          : Byte to empty by FIFO source register value
   1673          * Output         : None
   1674          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
   1675          *******************************************************************************/
   1676          status_t LIS3DH_GetFifoSourceReg(u8_t* val) {
   1677            
   1678            if( !LIS3DH_ReadReg(LIS3DH_FIFO_SRC_REG, val) )
   1679              return MEMS_ERROR;
   1680            
   1681            return MEMS_SUCCESS;
   1682          }
   1683          
   1684          
   1685          /*******************************************************************************
   1686          * Function Name  : LIS3DH_GetFifoSourceBit
   1687          * Description    : Read Fifo WaterMark source bit
   1688          * Input          : statusBIT: LIS3DH_FIFO_SRC_WTM, LIS3DH_FIFO_SRC_OVRUN, LIS3DH_FIFO_SRC_EMPTY
   1689          *				   val: Byte to fill  with the bit value
   1690          * Output         : None
   1691          * Return         : Status of BIT [MEMS_ERROR, MEMS_SUCCESS]
   1692          *******************************************************************************/
   1693          status_t LIS3DH_GetFifoSourceBit(u8_t statusBIT,  u8_t* val){
   1694            u8_t value;  
   1695            
   1696            if( !LIS3DH_ReadReg(LIS3DH_FIFO_SRC_REG, &value) )
   1697              return MEMS_ERROR;
   1698            
   1699            
   1700            if(statusBIT == LIS3DH_FIFO_SRC_WTM){
   1701              if(value &= LIS3DH_FIFO_SRC_WTM){     
   1702                *val = MEMS_SET;
   1703                return MEMS_SUCCESS;
   1704              }
   1705              else{  
   1706                *val = MEMS_RESET;
   1707                return MEMS_SUCCESS;
   1708              }  
   1709            }
   1710            
   1711            if(statusBIT == LIS3DH_FIFO_SRC_OVRUN){
   1712              if(value &= LIS3DH_FIFO_SRC_OVRUN){     
   1713                *val = MEMS_SET;
   1714                return MEMS_SUCCESS;
   1715              }
   1716              else{  
   1717                *val = MEMS_RESET;
   1718                return MEMS_SUCCESS;
   1719              }  
   1720            }
   1721            if(statusBIT == LIS3DH_FIFO_SRC_EMPTY){
   1722              if(value &= statusBIT == LIS3DH_FIFO_SRC_EMPTY){     
   1723                *val = MEMS_SET;
   1724                return MEMS_SUCCESS;
   1725              }
   1726              else{  
   1727                *val = MEMS_RESET;
   1728                return MEMS_SUCCESS;
   1729              }  
   1730            }
   1731            return MEMS_ERROR;
   1732          }
   1733          
   1734          
   1735          /*******************************************************************************
   1736          * Function Name  : LIS3DH_GetFifoSourceFSS
   1737          * Description    : Read current number of unread samples stored in FIFO
   1738          * Input          : Byte to empty by FIFO unread sample value
   1739          * Output         : None
   1740          * Return         : Status [value of FSS]
   1741          *******************************************************************************/
   1742          status_t LIS3DH_GetFifoSourceFSS(u8_t* val){
   1743            u8_t value;
   1744            
   1745            if( !LIS3DH_ReadReg(LIS3DH_FIFO_SRC_REG, &value) )
   1746              return MEMS_ERROR;
   1747            
   1748            value &= 0x1F;
   1749            
   1750            *val = value;
   1751            
   1752            return MEMS_SUCCESS;
   1753          }
   1754          
   1755                
   1756          /*******************************************************************************
   1757          * Function Name  : LIS3DH_SetSPIInterface
   1758          * Description    : Set SPI mode: 3 Wire Interface OR 4 Wire Interface
   1759          * Input          : LIS3DH_SPI_3_WIRE, LIS3DH_SPI_4_WIRE
   1760          * Output         : None
   1761          * Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
   1762          *******************************************************************************/
   1763          status_t LIS3DH_SetSPIInterface(LIS3DH_SPIMode_t spi) {
   1764            u8_t value;
   1765            
   1766            if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG4, &value) )
   1767              return MEMS_ERROR;
   1768            
   1769            value &= 0xFE;
   1770            value |= spi<<LIS3DH_SIM;
   1771            
   1772            if( !LIS3DH_WriteReg(LIS3DH_CTRL_REG4, value) )
   1773              return MEMS_ERROR;
   1774            
   1775            return MEMS_SUCCESS;
   1776          }
   1777          /******************* (C) COPYRIGHT 2012 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   LIS3DH_ConvAccValue
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> LIS3DH_SPI_SendByte
      24   LIS3DH_FIFOModeEnable
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> LIS3DH_SPI_SendByte
        24   -> LIS3DH_WriteReg
      16   LIS3DH_Get6DPosition
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
      16   LIS3DH_GetAccAxesRaw
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
      24   LIS3DH_GetAuxRaw
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> SPI_I2S_GetFlagStatus
        24   -> SPI_I2S_ReceiveData
        24   -> SPI_I2S_SendData
      16   LIS3DH_GetClickResponse
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
      24   LIS3DH_GetFifoSourceBit
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> LIS3DH_SPI_SendByte
      16   LIS3DH_GetFifoSourceFSS
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
      16   LIS3DH_GetFifoSourceReg
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
      16   LIS3DH_GetInt1Src
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
      24   LIS3DH_GetInt1SrcBit
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> LIS3DH_SPI_SendByte
      16   LIS3DH_GetStatusAUX
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
      24   LIS3DH_GetStatusAUXBit
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> SPI_I2S_GetFlagStatus
        24   -> SPI_I2S_ReceiveData
        24   -> SPI_I2S_SendData
      24   LIS3DH_GetStatusBit
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> LIS3DH_SPI_SendByte
      16   LIS3DH_GetStatusReg
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
      16   LIS3DH_GetTempRaw
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
      16   LIS3DH_GetWHO_AM_I
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
      16   LIS3DH_HPFAOI1Enable
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
        16   -> LIS3DH_WriteReg
      16   LIS3DH_HPFAOI2Enable
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
        16   -> LIS3DH_WriteReg
      16   LIS3DH_HPFClickEnable
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
        16   -> LIS3DH_WriteReg
      16   LIS3DH_Int1LatchEnable
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
        16   -> LIS3DH_WriteReg
      16   LIS3DH_ReadReg
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
       8   LIS3DH_ResetInt1Latch
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
         8   -> LIS3DH_SPI_SendByte
      16   LIS3DH_SPI_SendByte
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
      16   LIS3DH_SetADCAux
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_WriteReg
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
      16   LIS3DH_SetAxis
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_WriteReg
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
      16   LIS3DH_SetBDU
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_WriteReg
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
      16   LIS3DH_SetBLE
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_WriteReg
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
      16   LIS3DH_SetClickCFG
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
        16   -> LIS3DH_WriteReg
       8   LIS3DH_SetClickLATENCY
         8   -> LIS3DH_WriteReg
       8   LIS3DH_SetClickLIMIT
         8   -> LIS3DH_WriteReg
       8   LIS3DH_SetClickTHS
         8   -> LIS3DH_WriteReg
       8   LIS3DH_SetClickWINDOW
         8   -> LIS3DH_WriteReg
      16   LIS3DH_SetFilterDataSel
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
        16   -> LIS3DH_WriteReg
      16   LIS3DH_SetFullScale
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_WriteReg
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
      16   LIS3DH_SetHPFCutOFF
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
        16   -> LIS3DH_WriteReg
      16   LIS3DH_SetHPFMode
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
        16   -> LIS3DH_WriteReg
       8   LIS3DH_SetInt1Duration
         8   -> LIS3DH_WriteReg
      16   LIS3DH_SetInt1Pin
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
        16   -> LIS3DH_WriteReg
       8   LIS3DH_SetInt1Threshold
         8   -> LIS3DH_WriteReg
      16   LIS3DH_SetInt2Pin
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
        16   -> LIS3DH_WriteReg
      24   LIS3DH_SetInt6D4DConfiguration
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> LIS3DH_SPI_SendByte
        24   -> LIS3DH_WriteReg
      16   LIS3DH_SetIntConfiguration
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
        16   -> LIS3DH_WriteReg
      16   LIS3DH_SetIntMode
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
        16   -> LIS3DH_WriteReg
      24   LIS3DH_SetMode
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> LIS3DH_WriteReg
        24   -> SPI_I2S_GetFlagStatus
        24   -> SPI_I2S_ReceiveData
        24   -> SPI_I2S_SendData
      16   LIS3DH_SetODR
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_WriteReg
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
      16   LIS3DH_SetSPIInterface
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
        16   -> LIS3DH_WriteReg
      16   LIS3DH_SetSelfTest
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
        16   -> LIS3DH_WriteReg
      16   LIS3DH_SetTemperature
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_WriteReg
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
      16   LIS3DH_SetTriggerInt
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
        16   -> LIS3DH_WriteReg
      16   LIS3DH_SetWaterMark
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte
        16   -> LIS3DH_WriteReg
      40   LIS3DH_SpiInit
        40   -> GPIO_Init
        40   -> GPIO_PinAFConfig
        40   -> GPIO_SetBits
        40   -> RCC_AHBPeriphClockCmd
        40   -> RCC_APB2PeriphClockCmd
        40   -> SPI_Cmd
        40   -> SPI_Init
      16   LIS3DH_WriteReg
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> LIS3DH_SPI_SendByte


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable26
       4  ??DataTable27
       4  ??DataTable42
       4  ??DataTable45
       4  ??DataTable46
     108  LIS3DH_ConvAccValue
     424  LIS3DH_FIFOModeEnable
      72  LIS3DH_Get6DPosition
     224  LIS3DH_GetAccAxesRaw
     620  LIS3DH_GetAuxRaw
     174  LIS3DH_GetClickResponse
      98  LIS3DH_GetFifoSourceBit
      46  LIS3DH_GetFifoSourceFSS
      44  LIS3DH_GetFifoSourceReg
      44  LIS3DH_GetInt1Src
     130  LIS3DH_GetInt1SrcBit
      46  LIS3DH_GetStatusAUX
     208  LIS3DH_GetStatusAUXBit
     140  LIS3DH_GetStatusBit
      46  LIS3DH_GetStatusReg
     204  LIS3DH_GetTempRaw
      46  LIS3DH_GetWHO_AM_I
      56  LIS3DH_HPFAOI1Enable
      58  LIS3DH_HPFAOI2Enable
      58  LIS3DH_HPFClickEnable
      60  LIS3DH_Int1LatchEnable
      82  LIS3DH_ReadReg
      38  LIS3DH_ResetInt1Latch
      54  LIS3DH_SPI_SendByte
     128  LIS3DH_SetADCAux
     128  LIS3DH_SetAxis
     126  LIS3DH_SetBDU
     126  LIS3DH_SetBLE
      56  LIS3DH_SetClickCFG
      20  LIS3DH_SetClickLATENCY
      28  LIS3DH_SetClickLIMIT
      28  LIS3DH_SetClickTHS
      20  LIS3DH_SetClickWINDOW
      58  LIS3DH_SetFilterDataSel
     128  LIS3DH_SetFullScale
      66  LIS3DH_SetHPFCutOFF
      58  LIS3DH_SetHPFMode
      28  LIS3DH_SetInt1Duration
      52  LIS3DH_SetInt1Pin
      28  LIS3DH_SetInt1Threshold
      52  LIS3DH_SetInt2Pin
     130  LIS3DH_SetInt6D4DConfiguration
      58  LIS3DH_SetIntConfiguration
      60  LIS3DH_SetIntMode
     294  LIS3DH_SetMode
     128  LIS3DH_SetODR
      56  LIS3DH_SetSPIInterface
      58  LIS3DH_SetSelfTest
     128  LIS3DH_SetTemperature
      60  LIS3DH_SetTriggerInt
      66  LIS3DH_SetWaterMark
     196  LIS3DH_SpiInit
      42  LIS3DH_WriteReg
       1  ODR_old_value

 
     1 byte  in section .bss
 5 506 bytes in section .text
 
 5 506 bytes of CODE memory
     1 byte  of DATA memory

Errors: none
Warnings: none
