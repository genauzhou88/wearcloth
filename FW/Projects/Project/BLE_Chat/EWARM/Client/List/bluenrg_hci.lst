###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.60.1.5097/W32 for ARM      09/Oct/2014  10:33:24 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\FredZhou\Documents\Origin\Projects\Bluetooth    #
#                    LE\SimpleBlueNRG_HCI\hci\controller\bluenrg_hci.c        #
#    Command line =  "C:\Users\FredZhou\Documents\Origin\Projects\Bluetooth   #
#                    LE\SimpleBlueNRG_HCI\hci\controller\bluenrg_hci.c" -D    #
#                    USE_STDPERIPH_DRIVER -D STM32L1XX_MD -D                  #
#                    SYSCLK_FREQ_HSI_32MHz -D ENABLE_USB -D                   #
#                    ENABLE_USB_PRINTF -D CLIENT=1 -D DEBUG -D                #
#                    BLUENRG_CONFIG=BLUENRG_16_MHZ -lcN                       #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Client\List\ --diag_suppress Pa050 -o         #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Client\Obj\ --debug --endian=little           #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.5\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\inc\ -I "C:\Users\FredZhou\Documents\Origi #
#                    n\Projects\Project\BLE_Chat\EWARM\..\..\..\Bluetooth     #
#                    LE\SimpleBlueNRG_HCI\" -I "C:\Users\FredZhou\Documents\O #
#                    rigin\Projects\Project\BLE_Chat\EWARM\..\..\..\Bluetooth #
#                     LE\SimpleBlueNRG_HCI\includes\" -I                      #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\ -I               #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\ -I     #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\CMSIS\C #
#                    M3\DeviceSupport\ST\STM32L1xx\ -I                        #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32_U #
#                    SB-FS-Device_Driver\inc\ -I                              #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32L1 #
#                    xx_StdPeriph_Driver\inc\ -I                              #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\I2C\inc #
#                    \ -I C:\Users\FredZhou\Documents\Origin\Projects\Project #
#                    \BLE_Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\LI #
#                    S3DH\inc\ -I C:\Users\FredZhou\Documents\Origin\Projects #
#                    \Project\BLE_Chat\EWARM\..\..\..\platform\STM32L1XX\Libr #
#                    aries\STLM75\inc\ -I C:\Users\FredZhou\Documents\Origin\ #
#                    Projects\Project\BLE_Chat\EWARM\..\..\..\platform\STM32L #
#                    1XX\Libraries\HTS221\inc\ -I                             #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\LPS25H\ #
#                    inc\ -I C:\Users\FredZhou\Documents\Origin\Projects\Proj #
#                    ect\BLE_Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries #
#                    \SDK_Eval_STM32L\inc\ -Ohs --use_c++_inline -I           #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Client\List\bluenrg_hci.lst                   #
#    Object file  =  C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Client\Obj\bluenrg_hci.o                      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\FredZhou\Documents\Origin\Projects\Bluetooth LE\SimpleBlueNRG_HCI\hci\controller\bluenrg_hci.c
      1          /******************** (C) COPYRIGHT 2013 STMicroelectronics ********************
      2          * File Name          : bluenrg_hci.c
      3          * Author             : AMS - HEA&RF BU
      4          * Version            : V1.0.0
      5          * Date               : 4-Oct-2013
      6          * Description        : File with HCI commands for BlueNRG FW6.0 and above.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          #include "hal_types.h"
     17          #include "osal.h"
     18          #include "ble_status.h"
     19          #include "hal.h"
     20          #include "osal.h"
     21          #include "hci_internal.h"
     22          #include "bluenrg_hci_internal.h"
     23          #include "gatt_server.h"
     24          #include "gap.h"
     25          
     26          
     27          tBleStatus aci_gatt_init()
     28          {
     29            struct hci_request rq;
     30            tHalUint8 status;
     31          
     32            Osal_MemSet(&rq, 0, sizeof(rq));
     33            rq.ogf = OGF_VENDOR_CMD;
     34            rq.ocf = OCF_GATT_INIT;
     35            rq.rparam = &status;
     36            rq.rlen = 1;
     37          
     38            if (hci_send_req(&rq) < 0)
     39              return -1;
     40          
     41            if (status) {
     42              return status;
     43            }
     44          
     45            return 0;
     46          }
     47          
     48          tBleStatus aci_gap_init(uint8_t role, uint16_t* service_handle, uint16_t* dev_name_char_handle, uint16_t* appearance_char_handle)
     49          {
     50            struct hci_request rq;
     51            gap_init_cp cp;
     52            gap_init_rp resp;
     53          
     54            cp.role = role;
     55              
     56            Osal_MemSet(&resp, 0, sizeof(resp));
     57            
     58            Osal_MemSet(&rq, 0, sizeof(rq));
     59            rq.ogf = OGF_VENDOR_CMD;
     60            rq.ocf = OCF_GAP_INIT;
     61            rq.cparam = &cp;
     62            rq.clen = GAP_INIT_CP_SIZE;
     63            rq.rparam = &resp;
     64            rq.rlen = GAP_INIT_RP_SIZE;
     65            
     66            if (hci_send_req(&rq) < 0)
     67              return -1;
     68            
     69            if (resp.status) {
     70              return resp.status;
     71            }
     72            
     73            *service_handle = btohs(resp.service_handle);
     74            *dev_name_char_handle = btohs(resp.dev_name_char_handle);
     75            *appearance_char_handle = btohs(resp.appearance_char_handle);
     76            
     77            return 0;
     78          }
     79          
     80          tBleStatus aci_gap_set_non_discoverable(void)
     81          {
     82            struct hci_request rq;
     83            tHalUint8 status;
     84            
     85            Osal_MemSet(&rq, 0, sizeof(rq));
     86            rq.ogf = OGF_VENDOR_CMD;
     87            rq.ocf = OCF_GAP_SET_NON_DISCOVERABLE;
     88            rq.rparam = &status;
     89            rq.rlen = 1;
     90            
     91            if (hci_send_req(&rq) < 0)
     92              return -1;
     93            
     94            return status;  
     95          }
     96          
     97          tBleStatus aci_gap_set_limited_discoverable(uint8_t AdvType, uint16_t AdvIntervMin, uint16_t AdvIntervMax,
     98          					    uint8_t OwnAddrType, uint8_t AdvFilterPolicy, uint8_t LocalNameLen,
     99          					    const char *LocalName, uint8_t ServiceUUIDLen, uint8_t* ServiceUUIDList,
    100          					    uint16_t SlaveConnIntervMin, uint16_t SlaveConnIntervMax)
    101          {
    102            struct hci_request rq;
    103            uint8_t status;    
    104            uint8_t buffer[40];
    105            uint8_t indx = 0; 
    106              
    107            if ((LocalNameLen+ServiceUUIDLen+14) > sizeof(buffer))
    108              return BLE_STATUS_INVALID_PARAMS;
    109          
    110            buffer[indx] = AdvType;
    111            indx++;
    112              
    113            AdvIntervMin = htobs(AdvIntervMin);
    114            Osal_MemCpy(buffer + indx, &AdvIntervMin, 2);
    115            indx +=  2;
    116              
    117            AdvIntervMax = htobs(AdvIntervMax);
    118            Osal_MemCpy(buffer + indx, &AdvIntervMax, 2);
    119            indx +=  2;
    120              
    121            buffer[indx] = OwnAddrType;
    122            indx++;
    123              
    124            buffer[indx] = AdvFilterPolicy;
    125            indx++;
    126              
    127            buffer[indx] = LocalNameLen;
    128            indx++;
    129              
    130            Osal_MemCpy(buffer + indx, LocalName, LocalNameLen);
    131            indx +=  LocalNameLen;
    132          
    133            buffer[indx] = ServiceUUIDLen;
    134            indx++;
    135          
    136            Osal_MemCpy(buffer + indx, ServiceUUIDList, ServiceUUIDLen);
    137            indx +=  ServiceUUIDLen;
    138          
    139            Osal_MemCpy(buffer + indx, &SlaveConnIntervMin, 2);
    140            indx +=  2;
    141          
    142            Osal_MemCpy(buffer + indx, &SlaveConnIntervMax, 2);
    143            indx +=  2;    
    144          
    145            Osal_MemSet(&rq, 0, sizeof(rq));
    146            rq.ogf = OGF_VENDOR_CMD;
    147            rq.ocf = OCF_GAP_SET_LIMITED_DISCOVERABLE;
    148            rq.cparam = (void *)buffer;
    149            rq.clen = indx;
    150            rq.event = EVT_CMD_STATUS;
    151            rq.rparam = &status;
    152            rq.rlen = 1;
    153          
    154            if (hci_send_req(&rq) < 0)
    155              return -1;
    156          
    157            return status;
    158          }
    159          
    160          tBleStatus aci_gap_set_discoverable(uint8_t AdvType, uint16_t AdvIntervMin, uint16_t AdvIntervMax,
    161                                       uint8_t OwnAddrType, uint8_t AdvFilterPolicy, uint8_t LocalNameLen,
    162                                       const char *LocalName, uint8_t ServiceUUIDLen, uint8_t* ServiceUUIDList,
    163                                       uint16_t SlaveConnIntervMin, uint16_t SlaveConnIntervMax)
    164          {
    165            struct hci_request rq;
    166            uint8_t status;   
    167            uint8_t buffer[40];
    168            uint8_t indx = 0;
    169            
    170            if ((LocalNameLen+ServiceUUIDLen+14) > sizeof(buffer))
    171              return BLE_STATUS_INVALID_PARAMS;
    172          
    173            buffer[indx] = AdvType;
    174            indx++;
    175            
    176            AdvIntervMin = htobs(AdvIntervMin);
    177            Osal_MemCpy(buffer + indx, &AdvIntervMin, 2);
    178            indx +=  2;
    179              
    180            AdvIntervMax = htobs(AdvIntervMax);
    181            Osal_MemCpy(buffer + indx, &AdvIntervMax, 2);
    182            indx +=  2;
    183              
    184            buffer[indx] = OwnAddrType;
    185            indx++;
    186              
    187            buffer[indx] = AdvFilterPolicy;
    188            indx++;
    189              
    190            buffer[indx] = LocalNameLen;
    191            indx++;
    192              
    193            Osal_MemCpy(buffer + indx, LocalName, LocalNameLen);
    194            indx +=  LocalNameLen;
    195            
    196            buffer[indx] = ServiceUUIDLen;
    197            indx++;
    198          
    199            Osal_MemCpy(buffer + indx, ServiceUUIDList, ServiceUUIDLen);
    200            indx +=  ServiceUUIDLen;  
    201          
    202            SlaveConnIntervMin = htobs(SlaveConnIntervMin);
    203            Osal_MemCpy(buffer + indx, &SlaveConnIntervMin, 2);
    204            indx +=  2;
    205            
    206            SlaveConnIntervMax = htobs(SlaveConnIntervMax);
    207            Osal_MemCpy(buffer + indx, &SlaveConnIntervMax, 2);
    208            indx +=  2;    
    209          
    210            Osal_MemSet(&rq, 0, sizeof(rq));
    211            rq.ogf = OGF_VENDOR_CMD;
    212            rq.ocf = OCF_GAP_SET_DISCOVERABLE;
    213            rq.cparam = (void *)buffer;
    214            rq.clen = indx;
    215            rq.rparam = &status;
    216            rq.rlen = 1;
    217          
    218            if (hci_send_req(&rq) < 0)
    219              return -1;
    220          
    221            if (status) {
    222              return status;
    223            }
    224          
    225            return 0;
    226          }
    227          
    228          tBleStatus aci_gap_set_direct_connectable(uint8_t own_addr_type, uint8_t initiator_addr_type, uint8_t *initiator_addr)
    229          {
    230            struct hci_request rq;
    231            gap_set_direct_conectable_cp cp;
    232            uint8_t status;    
    233          
    234            cp.own_bdaddr_type = own_addr_type;
    235            cp.direct_bdaddr_type = initiator_addr_type;
    236            Osal_MemCpy(cp.direct_bdaddr, initiator_addr, 6);
    237          
    238            Osal_MemSet(&rq, 0, sizeof(rq));
    239            rq.ogf = OGF_VENDOR_CMD;
    240            rq.ocf = OCF_GAP_SET_DIRECT_CONNECTABLE;
    241            rq.cparam = &cp;
    242            rq.clen = GAP_SET_DIRECT_CONNECTABLE_CP_SIZE;
    243            rq.rparam = &status;
    244            rq.rlen = 1;
    245              
    246            if (hci_send_req(&rq) < 0)
    247              return -1;
    248              
    249            return status;
    250          }
    251          
    252          tBleStatus aci_gap_set_io_capabilitiy(uint8_t io_capability)
    253          {
    254            struct hci_request rq;
    255            uint8_t status;
    256            gap_set_io_capability_cp cp;
    257              
    258            cp.io_capability = io_capability;
    259          
    260            Osal_MemSet(&rq, 0, sizeof(rq));
    261            rq.ogf = OGF_VENDOR_CMD;
    262            rq.ocf = OCF_GAP_SET_IO_CAPABILITY;
    263            rq.cparam = &cp;
    264            rq.clen = GAP_SET_IO_CAPABILITY_CP_SIZE;
    265            rq.rparam = &status;
    266            rq.rlen = 1;
    267              
    268            if (hci_send_req(&rq) < 0)
    269              return -1;
    270              
    271            return status;
    272          }
    273          
    274          tBleStatus aci_gap_update_adv_data(tHalUint8 AdvLen, tHalUint8 *AdvData)
    275          {
    276            struct hci_request rq;
    277            uint8_t status;
    278            uint8_t buffer[32];
    279            uint8_t indx = 0;
    280              
    281            if (AdvLen > (sizeof(buffer)-1))
    282              return BLE_STATUS_INVALID_PARAMS;
    283          
    284            buffer[indx] = AdvLen;
    285            indx++;
    286              
    287            Osal_MemCpy(buffer + indx, AdvData, AdvLen);
    288            indx +=  AdvLen;
    289              
    290            Osal_MemSet(&rq, 0, sizeof(rq));
    291            rq.ogf = OGF_VENDOR_CMD;
    292            rq.ocf = OCF_GAP_UPDATE_ADV_DATA;
    293            rq.cparam = (void *)buffer;
    294            rq.clen = indx;
    295            rq.rparam = &status;
    296            rq.rlen = 1;
    297              
    298            if (hci_send_req(&rq) < 0)
    299              return -1;
    300              
    301            return status;
    302          }
    303          
    304          
    305          tBleStatus aci_gatt_add_serv(tHalUint8 service_uuid_type, const tHalUint8* service_uuid, tHalUint8 service_type, tHalUint8 max_attr_records, tHalUint16 *serviceHandle)
    306          {
    307            struct hci_request rq;
    308            gatt_add_serv_rp resp;    
    309            uint8_t buffer[19];
    310            uint8_t uuid_len;
    311            uint8_t indx = 0;
    312              
    313            buffer[indx] = service_uuid_type;
    314            indx++;
    315              
    316            if(service_uuid_type == 0x01){
    317              uuid_len = 2;
    318            }
    319            else {
    320              uuid_len = 16;
    321            }        
    322            Osal_MemCpy(buffer + indx, service_uuid, uuid_len);
    323            indx +=  uuid_len;
    324              
    325            buffer[indx] = service_type;
    326            indx++;
    327              
    328            buffer[indx] = max_attr_records;
    329            indx++;
    330              
    331              
    332            Osal_MemSet(&resp, 0, sizeof(resp));
    333          
    334            Osal_MemSet(&rq, 0, sizeof(rq));
    335            rq.ogf = OGF_VENDOR_CMD;
    336            rq.ocf = OCF_GATT_ADD_SERV;
    337            rq.cparam = (void *)buffer;
    338            rq.clen = indx;
    339            rq.rparam = &resp;
    340            rq.rlen = GATT_ADD_SERV_RP_SIZE;
    341          
    342            if (hci_send_req(&rq) < 0)
    343              return -1;
    344          
    345            if (resp.status) {
    346              return resp.status;
    347            }
    348              
    349            *serviceHandle = btohs(resp.handle);
    350          
    351            return 0;
    352          }
    353          
    354          tBleStatus aci_gatt_include_service(uint16_t service_handle, uint16_t included_start_handle,
    355          				    uint16_t included_end_handle, uint8_t included_uuid_type,
    356          				    const uint8_t* included_uuid, uint16_t *included_handle)
    357          {
    358            struct hci_request rq;
    359            gatt_include_serv_rp resp;    
    360            uint8_t buffer[23];
    361            uint8_t uuid_len;
    362            uint8_t indx = 0;
    363          
    364            service_handle = htobs(service_handle);
    365            Osal_MemCpy(buffer, &service_handle, 2);
    366            indx += 2;
    367              
    368            included_start_handle = htobs(included_start_handle);
    369            Osal_MemCpy(buffer+indx, &included_start_handle, 2);
    370            indx += 2;
    371          
    372            included_end_handle = htobs(included_end_handle);
    373            Osal_MemCpy(buffer+indx, &included_end_handle, 2);
    374            indx += 2;
    375          
    376            if(included_uuid_type == 0x01){
    377              uuid_len = 2;
    378            } else {
    379              uuid_len = 16;
    380            }        
    381          
    382            buffer[indx] = included_uuid_type;
    383            indx++;
    384          
    385            Osal_MemCpy(buffer + indx, included_uuid, uuid_len);
    386            indx += uuid_len;
    387              
    388            Osal_MemSet(&resp, 0, sizeof(resp));
    389          
    390            Osal_MemSet(&rq, 0, sizeof(rq));
    391            rq.ogf = OGF_VENDOR_CMD;
    392            rq.ocf = OCF_GATT_INCLUDE_SERV;
    393            rq.cparam = (void *)buffer;
    394            rq.clen = indx;
    395            rq.rparam = &resp;
    396            rq.rlen = GATT_INCLUDE_SERV_RP_SIZE;
    397          
    398            if (hci_send_req(&rq) < 0)
    399              return -1;
    400          
    401            if (resp.status) {
    402              return resp.status;
    403            }
    404              
    405            *included_handle = btohs(resp.handle);
    406          
    407            return 0;
    408          }
    409          
    410          tBleStatus aci_gatt_add_char(tHalUint16 serviceHandle,
    411          			     tUuidType charUuidType,
    412          			     const tHalUint8* charUuid, 
    413          			     tHalUint8 charValueLen, 
    414          			     tHalUint8 charProperties,
    415          			     tAttrSecurityFlags secPermissions,
    416          			     tGattServerEvent gattEvtMask,
    417          			     tHalUint8 encryKeySize,
    418          			     tHalUint8 isVariable,
    419          			     tHalUint16* charHandle)                     
    420          {
    421            struct hci_request rq;
    422            gatt_add_serv_rp resp;
    423            uint8_t buffer[25];
    424            uint8_t uuid_len;
    425            uint8_t indx = 0;
    426              
    427            serviceHandle = htobs(serviceHandle);
    428            Osal_MemCpy(buffer + indx, &serviceHandle, 2);
    429            indx += 2;
    430              
    431            buffer[indx] = charUuidType;
    432            indx++;
    433              
    434            if(charUuidType == 0x01){
    435              uuid_len = 2;
    436            }
    437            else {
    438              uuid_len = 16;
    439            }        
    440            Osal_MemCpy(buffer + indx, charUuid, uuid_len);
    441            indx +=  uuid_len;
    442              
    443            buffer[indx] = charValueLen;
    444            indx++;
    445              
    446            buffer[indx] = charProperties;
    447            indx++;
    448              
    449            buffer[indx] = secPermissions;
    450            indx++;
    451              
    452            buffer[indx] = gattEvtMask;
    453            indx++;
    454              
    455            buffer[indx] = encryKeySize;
    456            indx++;
    457              
    458            buffer[indx] = isVariable;
    459            indx++;
    460              
    461            Osal_MemSet(&resp, 0, sizeof(resp));
    462          
    463            Osal_MemSet(&rq, 0, sizeof(rq));
    464            rq.ogf = OGF_VENDOR_CMD;
    465            rq.ocf = OCF_GATT_ADD_CHAR;
    466            rq.cparam = (void *)buffer;
    467            rq.clen = indx;
    468            rq.rparam = &resp;
    469            rq.rlen = GATT_ADD_CHAR_RP_SIZE;
    470          
    471            if (hci_send_req(&rq) < 0)
    472              return -1;
    473          
    474            if (resp.status) {
    475              return resp.status;
    476            }
    477              
    478            *charHandle = btohs(resp.handle);
    479          
    480            return 0;
    481          }
    482          
    483          tBleStatus aci_gatt_add_char_desc(tHalUint16 serviceHandle,
    484                                            tHalUint16 charHandle,
    485                                            tUuidType descUuidType,
    486                                            const tHalUint8* uuid, 
    487                                            tHalUint8 descValueMaxLen,
    488                                            tHalUint8 descValueLen,
    489                                            const void* descValue, 
    490                                            tAttrSecurityFlags secPermissions,
    491                                            tAttrSecurityFlags accPermissions,
    492                                            tGattServerEvent gattEvtMask,
    493                                            tHalUint8 encryKeySize,
    494                                            tHalUint8 isVariable,
    495                                            tHalUint16* descHandle)                     
    496          {
    497            struct hci_request rq;
    498            gatt_add_char_desc_rp resp;
    499            uint8_t buffer[HCI_MAX_PACKET_SIZE];
    500            uint8_t uuid_len;
    501            uint8_t indx = 0;
    502              
    503            serviceHandle = htobs(serviceHandle);
    504            Osal_MemCpy(buffer + indx, &serviceHandle, 2);
    505            indx += 2;
    506              
    507            charHandle = htobs(charHandle);
    508            Osal_MemCpy(buffer + indx, &charHandle, 2);
    509            indx += 2;
    510              
    511            buffer[indx] = descUuidType;
    512            indx++;
    513              
    514            if(descUuidType == 0x01){
    515              uuid_len = 2;
    516            }
    517            else {
    518              uuid_len = 16;
    519            }        
    520            Osal_MemCpy(buffer + indx, uuid, uuid_len);
    521            indx +=  uuid_len;
    522              
    523            buffer[indx] = descValueMaxLen;
    524            indx++;
    525              
    526            buffer[indx] = descValueLen;
    527            indx++;
    528          
    529            if ((descValueLen+indx+5) > HCI_MAX_PACKET_SIZE)
    530              return BLE_STATUS_INVALID_PARAMS;
    531            
    532            Osal_MemCpy(buffer + indx, descValue, descValueLen);
    533            indx += descValueLen;
    534              
    535            buffer[indx] = secPermissions;
    536            indx++;
    537              
    538            buffer[indx] = accPermissions;
    539            indx++;
    540              
    541            buffer[indx] = gattEvtMask;
    542            indx++;
    543              
    544            buffer[indx] = encryKeySize;
    545            indx++;
    546              
    547            buffer[indx] = isVariable;
    548            indx++;
    549              
    550            Osal_MemSet(&resp, 0, sizeof(resp));
    551          
    552            Osal_MemSet(&rq, 0, sizeof(rq));
    553            rq.ogf = OGF_VENDOR_CMD;
    554            rq.ocf = OCF_GATT_ADD_CHAR_DESC;
    555            rq.cparam = (void *)buffer;
    556            rq.clen = indx;
    557            rq.rparam = &resp;
    558            rq.rlen = GATT_ADD_CHAR_DESC_RP_SIZE;
    559          
    560            if (hci_send_req(&rq) < 0)
    561              return -1;
    562          
    563            if (resp.status) {
    564              return resp.status;
    565            }
    566              
    567            *descHandle = btohs(resp.handle);
    568          
    569            return 0;
    570          }
    571          
    572          
    573          tBleStatus aci_gatt_update_char_value(tHalUint16 servHandle, 
    574          				      tHalUint16 charHandle,
    575          				      tHalUint8 charValOffset,
    576          				      tHalUint8 charValueLen,   
    577          				      const tHalUint8 *charValue)
    578          {
    579            struct hci_request rq;
    580            uint8_t status;
    581            uint8_t buffer[HCI_MAX_PACKET_SIZE];
    582            uint8_t indx = 0;
    583              
    584            if ((charValueLen+6) > HCI_MAX_PACKET_SIZE)
    585              return BLE_STATUS_INVALID_PARAMS;
    586          
    587            servHandle = htobs(servHandle);
    588            Osal_MemCpy(buffer + indx, &servHandle, 2);
    589            indx += 2;
    590              
    591            charHandle = htobs(charHandle);
    592            Osal_MemCpy(buffer + indx, &charHandle, 2);
    593            indx += 2;
    594              
    595            buffer[indx] = charValOffset;
    596            indx++;
    597              
    598            buffer[indx] = charValueLen;
    599            indx++;
    600                  
    601            Osal_MemCpy(buffer + indx, charValue, charValueLen);
    602            indx +=  charValueLen;
    603          
    604            Osal_MemSet(&rq, 0, sizeof(rq));
    605            rq.ogf = OGF_VENDOR_CMD;
    606            rq.ocf = OCF_GATT_UPD_CHAR_VAL;
    607            rq.cparam = (void *)buffer;
    608            rq.clen = indx;
    609            rq.rparam = &status;
    610            rq.rlen = 1;
    611          
    612            if (hci_send_req(&rq) < 0)
    613              return -1;
    614          
    615            if (status) {
    616              return status;
    617            }
    618          
    619            return 0;
    620          }
    621          
    622          tBleStatus aci_gatt_allow_read(tHalUint16 conn_handle)
    623          {
    624              struct hci_request rq;
    625              gatt_allow_read_cp cp;
    626              tHalUint8 status;
    627              
    628              cp.conn_handle = htobs(conn_handle);
    629          
    630              Osal_MemSet(&rq, 0, sizeof(rq));
    631              rq.ogf = OGF_VENDOR_CMD;
    632              rq.ocf = OCF_GATT_ALLOW_READ;
    633              rq.cparam = &cp;
    634              rq.clen = GATT_ALLOW_READ_CP_SIZE;
    635              rq.rparam = &status;
    636              rq.rlen = 1;
    637          
    638              if (hci_send_req(&rq) < 0)
    639                return -1;
    640          
    641              if (status) {
    642                return status;
    643              }
    644          
    645              return 0;
    646          }
    647          
    648          tBleStatus aci_gatt_set_desc_value(tHalUint16 servHandle, 
    649          				   tHalUint16 charHandle,
    650          				   tHalUint16 charDescHandle,
    651          				   tHalUint16 charDescValOffset,
    652          				   tHalUint8 charDescValueLen,   
    653          				   const tHalUint8 *charDescValue)
    654          {
    655            struct hci_request rq;
    656            uint8_t status;
    657            uint8_t buffer[HCI_MAX_PACKET_SIZE];
    658            uint8_t indx = 0;
    659              
    660            if ((charDescValueLen+9) > HCI_MAX_PACKET_SIZE)
    661              return BLE_STATUS_INVALID_PARAMS;
    662          
    663            servHandle = htobs(servHandle);
    664            Osal_MemCpy(buffer + indx, &servHandle, 2);
    665            indx += 2;
    666              
    667            charHandle = htobs(charHandle);
    668            Osal_MemCpy(buffer + indx, &charHandle, 2);
    669            indx += 2;
    670              
    671            charDescHandle = htobs(charDescHandle);
    672            Osal_MemCpy(buffer + indx, &charDescHandle, 2);
    673            indx += 2;
    674              
    675            Osal_MemCpy(buffer + indx, &charDescValOffset, 2);
    676            indx += 2;
    677              
    678            buffer[indx] = charDescValueLen;
    679            indx++;
    680                  
    681            Osal_MemCpy(buffer + indx, charDescValue, charDescValueLen);
    682            indx +=  charDescValueLen;
    683          
    684            Osal_MemSet(&rq, 0, sizeof(rq));
    685            rq.ogf = OGF_VENDOR_CMD;
    686            rq.ocf = OCF_GATT_SET_DESC_VAL;
    687            rq.cparam = (void *)buffer;
    688            rq.clen = indx;
    689            rq.rparam = &status;
    690            rq.rlen = 1;
    691          
    692            if (hci_send_req(&rq) < 0)
    693              return -1;
    694          
    695            if (status) {
    696              return status;
    697            }
    698          
    699            return 0;
    700          }
    701          
    702          tBleStatus aci_gatt_read_handle_value(uint16_t attr_handle, uint8_t data_len, uint8_t *data)
    703          {
    704            struct hci_request rq;
    705            uint8_t buffer[HCI_MAX_PACKET_SIZE];
    706           
    707            if ((data_len+1) > HCI_MAX_PACKET_SIZE)
    708              return BLE_STATUS_INVALID_PARAMS;
    709          
    710            attr_handle = htobs(attr_handle);
    711          
    712            Osal_MemSet(&rq, 0, sizeof(rq));
    713            rq.ogf = OGF_VENDOR_CMD;
    714            rq.ocf = OCF_GATT_READ_HANDLE_VALUE;
    715            rq.cparam = &attr_handle;
    716            rq.clen = 2;
    717            rq.rparam = buffer;
    718            rq.rlen = data_len+1;
    719          
    720            if (hci_send_req(&rq) < 0)
    721              return -1;
    722          
    723            Osal_MemCpy(data, &buffer[1], data_len);
    724          
    725            return buffer[0]; 
    726          }
    727          
    728          tBleStatus aci_gatt_disc_all_prim_services(uint16_t conn_handle)
    729          {
    730            struct hci_request rq;
    731            uint8_t status;
    732            gatt_disc_all_prim_services_cp cp;
    733          
    734            cp.conn_handle = htobs(conn_handle);
    735          
    736            Osal_MemSet(&rq, 0, sizeof(rq));
    737            rq.ogf = OGF_VENDOR_CMD;
    738            rq.ocf = OCF_GATT_DISC_ALL_PRIM_SERVICES;
    739            rq.cparam = &cp;
    740            rq.clen = GATT_DISC_ALL_PRIM_SERVICES_CP_SIZE;
    741            rq.event = EVT_CMD_STATUS;
    742            rq.rparam = &status;
    743            rq.rlen = 1;
    744          
    745            if (hci_send_req(&rq) < 0)
    746              return -1;
    747          
    748            return status;
    749          }
    750          
    751          tBleStatus aci_gatt_find_included_services(uint16_t conn_handle, uint16_t start_service_handle, 
    752          					   uint16_t end_service_handle)
    753          {
    754            struct hci_request rq;
    755            uint8_t status;
    756            gatt_find_included_services_cp cp;
    757          
    758            cp.conn_handle = htobs(conn_handle);
    759            cp.start_handle = htobs(start_service_handle);
    760            cp.end_handle = htobs(end_service_handle);
    761          
    762            Osal_MemSet(&rq, 0, sizeof(rq));
    763            rq.ogf = OGF_VENDOR_CMD;
    764            rq.ocf = OCF_GATT_FIND_INCLUDED_SERVICES;
    765            rq.cparam = &cp;
    766            rq.clen = GATT_FIND_INCLUDED_SERVICES_CP_SIZE;
    767            rq.event = EVT_CMD_STATUS;
    768            rq.rparam = &status;
    769            rq.rlen = 1;
    770          
    771            if (hci_send_req(&rq) < 0)
    772              return -1;
    773          
    774            return status;
    775          }
    776          
    777          tBleStatus aci_gatt_disc_all_charac_of_serv(uint16_t conn_handle, uint16_t start_attr_handle, 
    778          					    uint16_t end_attr_handle)
    779          {
    780            struct hci_request rq;
    781            uint8_t status;
    782            gatt_disc_all_charac_of_serv_cp cp;
    783          
    784            cp.conn_handle = htobs(conn_handle);
    785            cp.start_attr_handle = htobs(start_attr_handle);
    786            cp.end_attr_handle = htobs(end_attr_handle);
    787          
    788            Osal_MemSet(&rq, 0, sizeof(rq));
    789            rq.ogf = OGF_VENDOR_CMD;
    790            rq.ocf = OCF_GATT_DISC_ALL_CHARAC_OF_SERV;
    791            rq.cparam = &cp;
    792            rq.clen = GATT_DISC_ALL_CHARAC_OF_SERV_CP_SIZE;
    793            rq.event = EVT_CMD_STATUS;
    794            rq.rparam = &status;
    795            rq.rlen = 1;
    796          
    797            if (hci_send_req(&rq) < 0)
    798              return -1;
    799          
    800            return status;
    801          }
    802          
    803          tBleStatus aci_gatt_disc_all_charac_descriptors(uint16_t conn_handle, uint16_t char_val_handle, 
    804          						uint16_t char_end_handle)
    805          {
    806            struct hci_request rq;
    807            uint8_t status;
    808            gatt_disc_all_charac_descriptors_cp cp;
    809          
    810            cp.conn_handle = htobs(conn_handle);
    811            cp.char_val_handle = htobs(char_val_handle);
    812            cp.char_end_handle = htobs(char_end_handle);
    813          
    814            Osal_MemSet(&rq, 0, sizeof(rq));
    815            rq.ogf = OGF_VENDOR_CMD;
    816            rq.ocf = OCF_GATT_DISC_ALL_CHARAC_DESCRIPTORS;
    817            rq.cparam = &cp;
    818            rq.clen = GATT_DISC_ALL_CHARAC_DESCRIPTORS_CP_SIZE;
    819            rq.event = EVT_CMD_STATUS;
    820            rq.rparam = &status;
    821            rq.rlen = 1;
    822          
    823            if (hci_send_req(&rq) < 0)
    824              return -1;
    825          
    826            return status;
    827          }
    828          
    829          tBleStatus aci_gatt_write_without_response(uint16_t conn_handle, uint16_t attr_handle, 
    830          					   uint8_t value_len, uint8_t *attr_value)
    831          {
    832            struct hci_request rq;
    833            uint8_t status;
    834            uint8_t buffer[HCI_MAX_PACKET_SIZE];
    835            uint8_t indx = 0;
    836              
    837            if ((value_len+5) > HCI_MAX_PACKET_SIZE)
    838              return BLE_STATUS_INVALID_PARAMS;
    839          
    840            conn_handle = htobs(conn_handle);
    841            Osal_MemCpy(buffer + indx, &conn_handle, 2);
    842            indx += 2;
    843              
    844            attr_handle = htobs(attr_handle);
    845            Osal_MemCpy(buffer + indx, &attr_handle, 2);
    846            indx += 2;
    847          
    848            buffer[indx] = value_len;
    849            indx++;
    850                  
    851            Osal_MemCpy(buffer + indx, attr_value, value_len);
    852            indx +=  value_len;
    853          
    854            Osal_MemSet(&rq, 0, sizeof(rq));
    855            rq.ogf = OGF_VENDOR_CMD;
    856            rq.ocf = OCF_GATT_WRITE_WITHOUT_RESPONSE;
    857            rq.cparam = (void *)buffer;
    858            rq.clen = indx;
    859            rq.rparam = &status;
    860            rq.rlen = 1;
    861          
    862            if (hci_send_req(&rq) < 0)
    863              return -1;
    864          
    865            return status;
    866          
    867          }
    868          
    869          tBleStatus aci_gatt_write_response(uint16_t conn_handle,
    870                                             uint16_t attr_handle,
    871                                             uint8_t write_status,
    872                                             uint8_t err_code,
    873                                             uint8_t att_val_len,
    874                                             uint8_t *att_val)
    875          {
    876            struct hci_request rq;
    877            uint8_t status;
    878            uint8_t buffer[HCI_MAX_PACKET_SIZE];
    879            uint8_t indx = 0;
    880            
    881            if ((att_val_len+7) > HCI_MAX_PACKET_SIZE)
    882              return BLE_STATUS_INVALID_PARAMS;
    883          
    884            conn_handle = htobs(conn_handle);  
    885            Osal_MemCpy(buffer + indx, &conn_handle, 2);
    886            indx += 2;
    887              
    888            attr_handle = htobs(attr_handle);
    889            Osal_MemCpy(buffer + indx, &attr_handle, 2);
    890            indx += 2;
    891              
    892            buffer[indx] = write_status;
    893            indx += 1;
    894              
    895            buffer[indx] = err_code;
    896            indx += 1;
    897              
    898            buffer[indx] = att_val_len;
    899            indx += 1;
    900              
    901            Osal_MemCpy(buffer + indx, &att_val, att_val_len);
    902            indx += att_val_len;
    903          
    904            Osal_MemSet(&rq, 0, sizeof(rq));
    905            rq.ogf = OGF_VENDOR_CMD;
    906            rq.ocf = OCF_GATT_WRITE_RESPONSE;
    907            rq.cparam = (void *)buffer;
    908            rq.clen = indx;
    909            rq.rparam = &status;
    910            rq.rlen = 1;
    911          
    912            if (hci_send_req(&rq) < 0)
    913              return -1;
    914          
    915            if (status) {
    916              return status;
    917            }
    918          
    919            return 0;
    920          }
    921          
    922          tBleStatus aci_gatt_read_charac_val(uint16_t conn_handle, uint16_t attr_handle)
    923          {
    924            struct hci_request rq;
    925            uint8_t status;
    926            gatt_read_charac_val_cp cp;
    927          
    928            cp.conn_handle = htobs(conn_handle);
    929            cp.attr_handle = htobs(attr_handle);
    930          
    931            Osal_MemSet(&rq, 0, sizeof(rq));
    932            rq.ogf = OGF_VENDOR_CMD;
    933            rq.ocf = OCF_GATT_READ_CHARAC_VAL;
    934            rq.cparam = &cp;
    935            rq.clen = GATT_READ_CHARAC_VAL_CP_SIZE;
    936            rq.event = EVT_CMD_STATUS;
    937            rq.rparam = &status;
    938            rq.rlen = 1;
    939          
    940            if (hci_send_req(&rq) < 0)
    941              return -1;
    942            
    943            return status;
    944          }
    945          
    946          tBleStatus aci_gatt_read_long_charac_val(uint16_t conn_handle, uint16_t attr_handle, 
    947          					 uint16_t val_offset)
    948          {
    949            struct hci_request rq;
    950            uint8_t status;
    951            gatt_read_long_charac_val_cp cp;
    952          
    953            cp.conn_handle = htobs(conn_handle);
    954            cp.attr_handle = htobs(attr_handle);
    955            cp.val_offset = htobs(val_offset);
    956          
    957            Osal_MemSet(&rq, 0, sizeof(rq));
    958            rq.ogf = OGF_VENDOR_CMD;
    959            rq.ocf = OCF_GATT_READ_LONG_CHARAC_VAL;
    960            rq.cparam = &cp;
    961            rq.clen = GATT_READ_LONG_CHARAC_VAL_CP_SIZE;
    962            rq.event = EVT_CMD_STATUS;
    963            rq.rparam = &status;
    964            rq.rlen = 1;
    965          
    966            if (hci_send_req(&rq) < 0)
    967              return -1;
    968          
    969            return status;
    970          }
    971          
    972          tBleStatus aci_gatt_write_charac_value(uint16_t conn_handle, uint16_t attr_handle, 
    973          				       uint8_t value_len, uint8_t *attr_value)
    974          {
    975            struct hci_request rq;
    976            uint8_t status;
    977            uint8_t buffer[HCI_MAX_PACKET_SIZE];
    978            uint8_t indx = 0;
    979              
    980            if ((value_len+5) > HCI_MAX_PACKET_SIZE)
    981              return BLE_STATUS_INVALID_PARAMS;
    982          
    983            conn_handle = htobs(conn_handle);
    984            Osal_MemCpy(buffer + indx, &conn_handle, 2);
    985            indx += 2;
    986              
    987            attr_handle = htobs(attr_handle);
    988            Osal_MemCpy(buffer + indx, &attr_handle, 2);
    989            indx += 2;
    990          
    991            buffer[indx] = value_len;
    992            indx++;
    993                  
    994            Osal_MemCpy(buffer + indx, attr_value, value_len);
    995            indx +=  value_len;
    996          
    997            Osal_MemSet(&rq, 0, sizeof(rq));
    998            rq.ogf = OGF_VENDOR_CMD;
    999            rq.ocf = OCF_GATT_WRITE_CHAR_VALUE;
   1000            rq.cparam = (void *)buffer;
   1001            rq.clen = indx;
   1002            rq.event = EVT_CMD_STATUS;
   1003            rq.rparam = &status;
   1004            rq.rlen = 1;
   1005          
   1006            if (hci_send_req(&rq) < 0)
   1007              return -1;
   1008          
   1009            return status;
   1010          }
   1011          
   1012          tBleStatus aci_gatt_write_charac_descriptor(uint16_t conn_handle, uint16_t attr_handle, 
   1013          					   uint8_t value_len, uint8_t *attr_value)
   1014          {
   1015            struct hci_request rq;
   1016            uint8_t status;
   1017            uint8_t buffer[HCI_MAX_PACKET_SIZE];
   1018            uint8_t indx = 0;
   1019              
   1020            if ((value_len+5) > HCI_MAX_PACKET_SIZE)
   1021              return BLE_STATUS_INVALID_PARAMS;
   1022          
   1023            conn_handle = htobs(conn_handle);
   1024            Osal_MemCpy(buffer + indx, &conn_handle, 2);
   1025            indx += 2;
   1026              
   1027            attr_handle = htobs(attr_handle);
   1028            Osal_MemCpy(buffer + indx, &attr_handle, 2);
   1029            indx += 2;
   1030          
   1031            buffer[indx] = value_len;
   1032            indx++;
   1033                  
   1034            Osal_MemCpy(buffer + indx, attr_value, value_len);
   1035            indx +=  value_len;
   1036          
   1037            Osal_MemSet(&rq, 0, sizeof(rq));
   1038            rq.ogf = OGF_VENDOR_CMD;
   1039            rq.ocf = OCF_GATT_WRITE_CHAR_DESCRIPTOR;
   1040            rq.cparam = (void *)buffer;
   1041            rq.clen = indx;
   1042            rq.event = EVT_CMD_STATUS; 
   1043            rq.rparam = &status;
   1044            rq.rlen = 1;
   1045          
   1046            if (hci_send_req(&rq) < 0)
   1047              return -1;
   1048          
   1049            return status;
   1050          }
   1051          
   1052          tBleStatus aci_hal_write_config_data(tHalUint8 offset, 
   1053                                              tHalUint8 len,
   1054                                              const tHalUint8 *val)
   1055          {
   1056            struct hci_request rq;
   1057            uint8_t status;
   1058            uint8_t buffer[HCI_MAX_PACKET_SIZE];
   1059            uint8_t indx = 0;
   1060              
   1061            if ((len+2) > HCI_MAX_PACKET_SIZE)
   1062              return BLE_STATUS_INVALID_PARAMS;
   1063          
   1064            buffer[indx] = offset;
   1065            indx++;
   1066              
   1067            buffer[indx] = len;
   1068            indx++;
   1069                  
   1070            Osal_MemCpy(buffer + indx, val, len);
   1071            indx +=  len;
   1072          
   1073            Osal_MemSet(&rq, 0, sizeof(rq));
   1074            rq.ogf = OGF_VENDOR_CMD;
   1075            rq.ocf = OCF_HAL_WRITE_CONFIG_DATA;
   1076            rq.cparam = (void *)buffer;
   1077            rq.clen = indx;
   1078            rq.rparam = &status;
   1079            rq.rlen = 1;
   1080          
   1081            if (hci_send_req(&rq) < 0)
   1082              return -1;
   1083          
   1084            if (status) {
   1085              return status;
   1086            }
   1087          
   1088            return 0;
   1089          }
   1090          
   1091          tBleStatus aci_hal_set_tx_power_level(uint8_t en_high_power, uint8_t pa_level)
   1092          {
   1093            struct hci_request rq;
   1094            hal_set_tx_power_level_cp cp;    
   1095            uint8_t status;
   1096              
   1097            cp.en_high_power = en_high_power;
   1098            cp.pa_level = pa_level;
   1099          
   1100            Osal_MemSet(&rq, 0, sizeof(rq));
   1101            rq.ogf = OGF_VENDOR_CMD;
   1102            rq.ocf = OCF_HAL_SET_TX_POWER_LEVEL;
   1103            rq.cparam = &cp;
   1104            rq.clen = HAL_SET_TX_POWER_LEVEL_CP_SIZE;
   1105            rq.rparam = &status;
   1106            rq.rlen = 1;
   1107          
   1108            if (hci_send_req(&rq) < 0)
   1109              return -1;
   1110          
   1111            if (status) {
   1112              return status;
   1113            }
   1114          
   1115            return 0;
   1116          }
   1117          
   1118          tBleStatus aci_gap_set_auth_requirement(uint8_t mitm_mode,
   1119                                                  uint8_t oob_enable,
   1120                                                  uint8_t oob_data[16],
   1121                                                  uint8_t min_encryption_key_size,
   1122                                                  uint8_t max_encryption_key_size,
   1123                                                  uint8_t use_fixed_pin,
   1124                                                  uint32_t fixed_pin,
   1125                                                  uint8_t bonding_mode)
   1126          {
   1127            struct hci_request rq;
   1128            gap_set_auth_requirement_cp cp;    
   1129            uint8_t status;
   1130              
   1131            cp.mitm_mode = mitm_mode;
   1132            cp.oob_enable = oob_enable;
   1133            Osal_MemCpy(cp.oob_data, oob_data, 16);
   1134            cp.min_encryption_key_size = min_encryption_key_size;
   1135            cp.max_encryption_key_size = max_encryption_key_size;
   1136            cp.use_fixed_pin = use_fixed_pin;
   1137            cp.fixed_pin = htobl(fixed_pin);
   1138            cp.bonding_mode = bonding_mode;
   1139          
   1140            Osal_MemSet(&rq, 0, sizeof(rq));
   1141            rq.ogf = OGF_VENDOR_CMD;
   1142            rq.ocf = OCF_GAP_SET_AUTH_REQUIREMENT;
   1143            rq.cparam = &cp;
   1144            rq.clen = GAP_SET_AUTH_REQUIREMENT_CP_SIZE;
   1145            rq.rparam = &status;
   1146            rq.rlen = 1;
   1147          
   1148            if (hci_send_req(&rq) < 0)
   1149              return -1;
   1150          
   1151            if (status) {
   1152              return status;
   1153            }
   1154              
   1155            return 0;
   1156          }
   1157          
   1158          tBleStatus aci_gap_pass_key_response(uint16_t conn_handle, uint32_t passkey)
   1159          {
   1160            struct hci_request rq;
   1161            gap_passkey_response_cp cp;    
   1162            uint8_t status;
   1163              
   1164            cp.conn_handle = htobs(conn_handle);
   1165            cp.passkey = htobl(passkey);
   1166          
   1167            Osal_MemSet(&rq, 0, sizeof(rq));
   1168            rq.ogf = OGF_VENDOR_CMD;
   1169            rq.ocf = OCF_GAP_PASSKEY_RESPONSE;
   1170            rq.cparam = &cp;
   1171            rq.clen = GAP_PASSKEY_RESPONSE_CP_SIZE;
   1172            rq.event = EVT_CMD_STATUS;
   1173            rq.rparam = &status;
   1174            rq.rlen = 1;
   1175            
   1176            if (hci_send_req(&rq) < 0)
   1177              return -1;
   1178            
   1179            return status;
   1180          }
   1181          
   1182          tBleStatus aci_gap_clear_security_database(void)
   1183          {
   1184            struct hci_request rq;
   1185            uint8_t status, dummy;
   1186            
   1187            dummy = 0;
   1188            
   1189            Osal_MemSet(&rq, 0, sizeof(rq));
   1190            rq.ogf = OGF_VENDOR_CMD;
   1191            rq.ocf = OCF_GAP_CLEAR_SECURITY_DB;
   1192            rq.cparam = (void*)&dummy;
   1193            rq.clen = 0;
   1194            rq.rparam = &status;
   1195            rq.rlen = 1;
   1196            
   1197            if (hci_send_req(&rq) < 0)
   1198              return -1;
   1199          
   1200            return status;
   1201          }
   1202          
   1203          tBleStatus aci_gap_allow_rebond(void)
   1204          {
   1205            struct hci_request rq;
   1206            uint8_t status, dummy;
   1207            
   1208            dummy = 0;
   1209            
   1210            Osal_MemSet(&rq, 0, sizeof(rq));
   1211            rq.ogf = OGF_VENDOR_CMD;
   1212            rq.ocf = OCF_GAP_ALLOW_REBOND_DB;
   1213            rq.cparam = (void*)&dummy;
   1214            rq.clen = 0;
   1215            rq.rparam = &status;
   1216            rq.rlen = 1;
   1217            
   1218            if (hci_send_req(&rq) < 0)
   1219              return -1;
   1220          
   1221            return status;
   1222          }
   1223          
   1224          tBleStatus aci_gap_slave_security_request(uint16_t conn_handle, uint8_t bonding, uint8_t mitm_protection)
   1225          {
   1226            struct hci_request rq;
   1227            gap_slave_security_request_cp cp;
   1228            uint8_t status;
   1229          
   1230            cp.conn_handle = htobs(conn_handle);
   1231            cp.bonding = bonding;
   1232            cp.mitm_protection = mitm_protection;
   1233            
   1234            Osal_MemSet(&rq, 0, sizeof(rq));
   1235            rq.ogf = OGF_VENDOR_CMD;
   1236            rq.ocf = OCF_GAP_SLAVE_SECURITY_REQUEST;
   1237            rq.cparam = &cp;
   1238            rq.clen = GAP_SLAVE_SECURITY_REQUEST_CP_SIZE;
   1239            rq.event = EVT_CMD_STATUS;
   1240            rq.rparam = &status;
   1241            rq.rlen = 1;
   1242            
   1243            if (hci_send_req(&rq) < 0)
   1244              return -1;
   1245          
   1246            return status;
   1247          
   1248          }
   1249          
   1250          tBleStatus aci_gap_configure_whitelist(void)
   1251          {
   1252            struct hci_request rq;
   1253            uint8_t status, dummy;
   1254            
   1255            dummy = 0;
   1256            
   1257            Osal_MemSet(&rq, 0, sizeof(rq));
   1258            rq.ogf = OGF_VENDOR_CMD;
   1259            rq.ocf = OCF_GAP_CONFIGURE_WHITELIST;
   1260            rq.cparam = (void*)&dummy;
   1261            rq.clen = 0;
   1262            rq.rparam = &status;
   1263            rq.rlen = 1;
   1264            
   1265            if (hci_send_req(&rq) < 0)
   1266              return -1;
   1267          
   1268            return status;
   1269          }
   1270          
   1271          tBleStatus aci_gap_start_limited_discovery_proc(uint16_t scanInterval, uint16_t scanWindow,
   1272          						uint8_t own_address_type, uint8_t filterDuplicates)
   1273          {
   1274            struct hci_request rq;
   1275            gap_start_limited_discovery_proc_cp cp;
   1276            uint8_t status;  
   1277          
   1278            cp.scanInterval = htobs(scanInterval);
   1279            cp.scanWindow = htobs(scanWindow);
   1280            cp.own_address_type = own_address_type;
   1281            cp.filterDuplicates = filterDuplicates;
   1282          
   1283            Osal_MemSet(&rq, 0, sizeof(rq));
   1284            rq.ogf = OGF_VENDOR_CMD;
   1285            rq.ocf = OCF_GAP_START_LIMITED_DISCOVERY_PROC;
   1286            rq.cparam = &cp;
   1287            rq.clen = GAP_START_LIMITED_DISCOVERY_PROC_CP_SIZE;
   1288            rq.event = EVT_CMD_STATUS;
   1289            rq.rparam = &status;
   1290            rq.rlen = 1;
   1291            
   1292            if (hci_send_req(&rq) < 0)
   1293              return -1;
   1294          
   1295            return status;
   1296          }
   1297          
   1298          tBleStatus aci_gap_start_general_discovery_proc(uint16_t scanInterval, uint16_t scanWindow,
   1299          						uint8_t own_address_type, uint8_t filterDuplicates)
   1300          {
   1301            struct hci_request rq;
   1302            gap_start_general_discovery_proc_cp cp;
   1303            uint8_t status;  
   1304          
   1305            cp.scanInterval = htobs(scanInterval);
   1306            cp.scanWindow = htobs(scanWindow);
   1307            cp.own_address_type = own_address_type;
   1308            cp.filterDuplicates = filterDuplicates;
   1309          
   1310            Osal_MemSet(&rq, 0, sizeof(rq));
   1311            rq.ogf = OGF_VENDOR_CMD;
   1312            rq.ocf = OCF_GAP_START_GENERAL_DISCOVERY_PROC;
   1313            rq.cparam = &cp;
   1314            rq.clen = GAP_START_GENERAL_DISCOVERY_PROC_CP_SIZE;
   1315            rq.event = EVT_CMD_STATUS;
   1316            rq.rparam = &status;
   1317            rq.rlen = 1;
   1318            
   1319            if (hci_send_req(&rq) < 0)
   1320              return -1;
   1321          
   1322            return status;
   1323          }
   1324          
   1325          
   1326          tBleStatus aci_gap_start_auto_conn_establishment(uint16_t scanInterval, uint16_t scanWindow,
   1327          						 uint8_t own_bdaddr_type, uint16_t conn_min_interval,	
   1328          						 uint16_t conn_max_interval, uint16_t conn_latency,	
   1329          						 uint16_t supervision_timeout, uint16_t min_conn_length, 
   1330          						 uint16_t max_conn_length, uint8_t num_whitelist_entries,
   1331          						 uint8_t *addr_array)
   1332          {
   1333            struct hci_request rq;
   1334            uint8_t status;
   1335            uint8_t buffer[HCI_MAX_PACKET_SIZE];
   1336            uint8_t indx = 0;
   1337              
   1338            if (((num_whitelist_entries*7)+18) > HCI_MAX_PACKET_SIZE)
   1339              return BLE_STATUS_INVALID_PARAMS;
   1340          
   1341            scanInterval = htobs(scanInterval);
   1342            Osal_MemCpy(buffer + indx, &scanInterval, 2);
   1343            indx += 2;
   1344              
   1345            scanWindow = htobs(scanWindow);
   1346            Osal_MemCpy(buffer + indx, &scanWindow, 2);
   1347            indx += 2;
   1348          
   1349            buffer[indx] = own_bdaddr_type;
   1350            indx++;
   1351            
   1352            conn_min_interval = htobs(conn_min_interval);
   1353            Osal_MemCpy(buffer + indx, &conn_min_interval, 2);
   1354            indx +=  2;
   1355          
   1356            conn_max_interval = htobs(conn_max_interval);
   1357            Osal_MemCpy(buffer + indx, &conn_max_interval, 2);
   1358            indx +=  2;
   1359          
   1360            conn_latency = htobs(conn_latency);
   1361            Osal_MemCpy(buffer + indx, &conn_latency, 2);
   1362            indx +=  2;
   1363          
   1364            supervision_timeout = htobs(supervision_timeout);
   1365            Osal_MemCpy(buffer + indx, &supervision_timeout, 2);
   1366            indx +=  2;
   1367          
   1368            min_conn_length = htobs(min_conn_length);
   1369            Osal_MemCpy(buffer + indx, &min_conn_length, 2);
   1370            indx +=  2;
   1371          
   1372            max_conn_length = htobs(max_conn_length);
   1373            Osal_MemCpy(buffer + indx, &max_conn_length, 2);
   1374            indx +=  2;
   1375          
   1376            buffer[indx] = num_whitelist_entries;
   1377            indx++;
   1378          
   1379            Osal_MemCpy(buffer + indx, addr_array, (num_whitelist_entries*7));
   1380            indx +=  num_whitelist_entries * 7;
   1381          
   1382            Osal_MemSet(&rq, 0, sizeof(rq));
   1383            rq.ogf = OGF_VENDOR_CMD;
   1384            rq.ocf = OCF_GAP_START_AUTO_CONN_ESTABLISHMENT;
   1385            rq.cparam = (void *)buffer;
   1386            rq.clen = indx;
   1387            rq.event = EVT_CMD_STATUS;
   1388            rq.rparam = &status;
   1389            rq.rlen = 1;
   1390          
   1391            if (hci_send_req(&rq) < 0)
   1392              return -1;
   1393          
   1394            return status;  
   1395          }
   1396          
   1397          tBleStatus aci_gap_create_connection(uint16_t scanInterval, uint16_t scanWindow,
   1398          				     uint8_t peer_bdaddr_type, tBDAddr peer_bdaddr,	
   1399          				     uint8_t own_bdaddr_type, uint16_t conn_min_interval,	
   1400          				     uint16_t conn_max_interval, uint16_t conn_latency,	
   1401          				     uint16_t supervision_timeout, uint16_t min_conn_length, 
   1402          				     uint16_t max_conn_length)
   1403          {
   1404            struct hci_request rq;
   1405            gap_create_connection_cp cp;
   1406            uint8_t status;  
   1407          
   1408            cp.scanInterval = htobs(scanInterval);
   1409            cp.scanWindow = htobs(scanWindow);
   1410            cp.peer_bdaddr_type = peer_bdaddr_type;
   1411            Osal_MemCpy(cp.peer_bdaddr, peer_bdaddr, 6);
   1412            cp.own_bdaddr_type = own_bdaddr_type;
   1413            cp.conn_min_interval = htobs(conn_min_interval);
   1414            cp.conn_max_interval = htobs(conn_max_interval);
   1415            cp.conn_latency = htobs(conn_latency);
   1416            cp.supervision_timeout = htobs(supervision_timeout);
   1417            cp.min_conn_length = htobs(min_conn_length);
   1418            cp.max_conn_length = htobs(max_conn_length);
   1419          
   1420            Osal_MemSet(&rq, 0, sizeof(rq));
   1421            rq.ogf = OGF_VENDOR_CMD;
   1422            rq.ocf = OCF_GAP_CREATE_CONNECTION;
   1423            rq.cparam = &cp;
   1424            rq.clen = GAP_CREATE_CONNECTION_CP_SIZE;
   1425            rq.event = EVT_CMD_STATUS;
   1426            rq.rparam = &status;
   1427            rq.rlen = 1;
   1428            
   1429            if (hci_send_req(&rq) < 0)
   1430              return -1;
   1431          
   1432            return status;
   1433          }
   1434          
   1435          tBleStatus aci_gap_terminate_gap_procedure(uint8_t procedure_code)
   1436          {
   1437            struct hci_request rq;
   1438            uint8_t status;  
   1439          
   1440            Osal_MemSet(&rq, 0, sizeof(rq));
   1441            rq.ogf = OGF_VENDOR_CMD;
   1442            rq.ocf = OCF_GAP_TERMINATE_GAP_PROCEDURE;
   1443            rq.cparam = &procedure_code;
   1444            rq.clen = 1;
   1445            rq.rparam = &status;
   1446            rq.rlen = 1;
   1447            
   1448            if (hci_send_req(&rq) < 0)
   1449              return -1;
   1450          
   1451            return status;
   1452          
   1453          }
   1454          
   1455          tBleStatus aci_gap_terminate(uint16_t conn_handle, uint8_t reason)
   1456          {
   1457            struct hci_request rq;
   1458            gap_terminate_cp cp;
   1459            uint8_t status;  
   1460          
   1461            cp.handle = htobs(conn_handle);
   1462            cp.reason = reason;
   1463          
   1464            Osal_MemSet(&rq, 0, sizeof(rq));
   1465            rq.ogf = OGF_VENDOR_CMD;
   1466            rq.ocf = OCF_GAP_TERMINATE;
   1467            rq.cparam = &cp;
   1468            rq.clen = GAP_TERMINATE_CP_SIZE;
   1469            rq.event = EVT_CMD_STATUS;
   1470            rq.rparam = &status;
   1471            rq.rlen = 1;
   1472            
   1473            if (hci_send_req(&rq) < 0)
   1474              return -1;
   1475          
   1476            return status; 
   1477          }
   1478          
   1479          tBleStatus aci_hal_tone_start(uint8_t rf_channel)
   1480          {
   1481            struct hci_request rq;
   1482            hal_tone_start_cp cp;    
   1483            uint8_t status;
   1484              
   1485            cp.rf_channel = rf_channel;
   1486          
   1487            Osal_MemSet(&rq, 0, sizeof(rq));
   1488            rq.ogf = OGF_VENDOR_CMD;
   1489            rq.ocf = OCF_HAL_TONE_START;
   1490            rq.cparam = &cp;
   1491            rq.clen = HAL_TONE_START_CP_SIZE;
   1492            rq.rparam = &status;
   1493            rq.rlen = 1;
   1494          
   1495            if (hci_send_req(&rq) < 0)
   1496              return -1;
   1497          
   1498            if (status) {
   1499              return status;
   1500            }
   1501              
   1502            return 0;
   1503          }
   1504          
   1505          tBleStatus aci_updater_start(void)
   1506          {
   1507            struct hci_request rq;
   1508            tHalUint8 status;
   1509          
   1510            Osal_MemSet(&rq, 0, sizeof(rq));
   1511            rq.ogf = OGF_VENDOR_CMD;
   1512            rq.ocf = OCF_UPDATER_START;
   1513            rq.rparam = &status;
   1514            rq.rlen = 1;
   1515          
   1516            if (hci_send_req(&rq) < 0)
   1517              return -1;
   1518          
   1519            return status;  
   1520          }
   1521          
   1522          tBleStatus aci_updater_reboot(void)
   1523          {
   1524            struct hci_request rq;
   1525            tHalUint8 status;
   1526          
   1527            Osal_MemSet(&rq, 0, sizeof(rq));
   1528            rq.ogf = OGF_VENDOR_CMD;
   1529            rq.ocf = OCF_UPDATER_REBOOT;
   1530            rq.rparam = &status;
   1531            rq.rlen = 1;
   1532          
   1533            if (hci_send_req(&rq) < 0)
   1534              return -1;
   1535          
   1536            return status;  
   1537          }
   1538          
   1539          tBleStatus aci_get_updater_version(uint8_t *version)
   1540          {
   1541            struct hci_request rq;
   1542            get_updater_version_rp resp;
   1543          
   1544            Osal_MemSet(&resp, 0, sizeof(resp));
   1545          
   1546            Osal_MemSet(&rq, 0, sizeof(rq));
   1547            rq.ogf = OGF_VENDOR_CMD;
   1548            rq.ocf = OCF_GET_UPDATER_VERSION;
   1549            rq.rparam = &resp;
   1550            rq.rlen = GET_UPDATER_VERSION_RP_SIZE;
   1551          
   1552            if (hci_send_req(&rq) < 0)
   1553              return -1;
   1554              
   1555            *version = resp.version;
   1556          
   1557            return resp.status;
   1558          }
   1559          
   1560          tBleStatus aci_get_updater_buffer_size(uint8_t *buffer_size)
   1561          {
   1562            struct hci_request rq;
   1563            get_updater_bufsize_rp resp;
   1564          
   1565            Osal_MemSet(&resp, 0, sizeof(resp));
   1566          
   1567            Osal_MemSet(&rq, 0, sizeof(rq));
   1568            rq.ogf = OGF_VENDOR_CMD;
   1569            rq.ocf = OCF_GET_UPDATER_BUFSIZE;
   1570            rq.rparam = &resp;
   1571            rq.rlen = GET_UPDATER_BUFSIZE_RP_SIZE;
   1572          
   1573            if (hci_send_req(&rq) < 0)
   1574              return -1;
   1575              
   1576            *buffer_size = resp.buffer_size;
   1577          
   1578            return resp.status;
   1579          }
   1580          
   1581          tBleStatus aci_erase_blue_flag(void)
   1582          {
   1583            struct hci_request rq;
   1584            tHalUint8 status;
   1585          
   1586            Osal_MemSet(&rq, 0, sizeof(rq));
   1587            rq.ogf = OGF_VENDOR_CMD;
   1588            rq.ocf = OCF_UPDATER_ERASE_BLUE_FLAG;
   1589            rq.rparam = &status;
   1590            rq.rlen = 1;
   1591          
   1592            if (hci_send_req(&rq) < 0)
   1593              return -1;
   1594          
   1595            return status;  
   1596          }
   1597          
   1598          tBleStatus aci_reset_blue_flag(void)
   1599          {
   1600            struct hci_request rq;
   1601            tHalUint8 status;
   1602          
   1603            Osal_MemSet(&rq, 0, sizeof(rq));
   1604            rq.ogf = OGF_VENDOR_CMD;
   1605            rq.ocf = OCF_UPDATER_RESET_BLUE_FLAG;
   1606            rq.rparam = &status;
   1607            rq.rlen = 1;
   1608          
   1609            if (hci_send_req(&rq) < 0)
   1610              return -1;
   1611          
   1612            return status;  
   1613          }
   1614          
   1615          tBleStatus aci_updater_erase_sector(uint32_t address)
   1616          {
   1617            struct hci_request rq;
   1618            updater_erase_sector_cp cp;    
   1619            uint8_t status;
   1620              
   1621            cp.address = htobl(address);
   1622          
   1623            Osal_MemSet(&rq, 0, sizeof(rq));
   1624            rq.ogf = OGF_VENDOR_CMD;
   1625            rq.ocf = OCF_UPDATER_ERASE_SECTOR;
   1626            rq.cparam = &cp;
   1627            rq.clen = UPDATER_ERASE_SECTOR_CP_SIZE;
   1628            rq.rparam = &status;
   1629            rq.rlen = 1;
   1630          
   1631            if (hci_send_req(&rq) < 0)
   1632              return -1;
   1633          
   1634            return status;
   1635          }
   1636          
   1637          tBleStatus aci_updater_program_data_block(uint32_t address, 
   1638          				   uint16_t len,
   1639          				   const uint8_t *data)
   1640          {
   1641            struct hci_request rq;
   1642            uint8_t status;
   1643            uint8_t buffer[HCI_MAX_PACKET_SIZE];
   1644            uint8_t indx = 0;
   1645              
   1646            if((len+6) > HCI_MAX_PACKET_SIZE)
   1647              return BLE_STATUS_INVALID_PARAMS;
   1648              
   1649            address = htobl(address);
   1650            Osal_MemCpy(buffer + indx, &address, 4);
   1651            indx += 4;
   1652              
   1653            len = htobs(len);
   1654            Osal_MemCpy(buffer + indx, &len, 2);
   1655            indx += 2;
   1656                  
   1657            Osal_MemCpy(buffer + indx, data, len);
   1658            indx +=  len;
   1659          
   1660            Osal_MemSet(&rq, 0, sizeof(rq));
   1661            rq.ogf = OGF_VENDOR_CMD;
   1662            rq.ocf = OCF_UPDATER_PROG_DATA_BLOCK;
   1663            rq.cparam = (void *)buffer;
   1664            rq.clen = indx;
   1665            rq.rparam = &status;
   1666            rq.rlen = 1;
   1667          
   1668            if (hci_send_req(&rq) < 0)
   1669              return -1;
   1670              
   1671            return status;
   1672          }
   1673          
   1674          tBleStatus aci_updater_read_data_block(uint32_t address,
   1675          				uint16_t data_len,
   1676          				uint8_t *data)
   1677          {
   1678            struct hci_request rq;
   1679            updater_read_data_block_cp cp;
   1680            uint8_t buffer[HCI_MAX_PACKET_SIZE];
   1681              
   1682            if((data_len+1) > HCI_MAX_PACKET_SIZE)
   1683              return BLE_STATUS_INVALID_PARAMS;
   1684              
   1685            cp.address = htobl(address);
   1686            cp.data_len = htobs(data_len);
   1687          
   1688            Osal_MemSet(&rq, 0, sizeof(rq));
   1689            rq.ogf = OGF_VENDOR_CMD;
   1690            rq.ocf = OCF_UPDATER_READ_DATA_BLOCK;
   1691            rq.cparam = &cp;
   1692            rq.clen = UPDATER_READ_DATA_BLOCK_CP_SIZE;
   1693            rq.rparam = buffer;
   1694            rq.rlen = data_len + 1;
   1695          
   1696            if (hci_send_req(&rq) < 0)
   1697              return -1;
   1698              
   1699            // First byte is status
   1700            Osal_MemCpy(data, buffer+1, data_len);
   1701          
   1702            return buffer[0];
   1703          }
   1704          
   1705          tBleStatus aci_updater_calc_crc(uint32_t address,
   1706                                   uint8_t num_sectors,
   1707                                   uint32_t *crc)
   1708          {
   1709            struct hci_request rq;
   1710            updater_calc_crc_cp cp;
   1711            updater_calc_crc_rp resp;
   1712              
   1713            Osal_MemSet(&resp, 0, sizeof(resp));
   1714              
   1715            cp.address = htobl(address);
   1716            cp.num_sectors = num_sectors;
   1717          
   1718            Osal_MemSet(&rq, 0, sizeof(rq));
   1719            rq.ogf = OGF_VENDOR_CMD;
   1720            rq.ocf = OCF_UPDATER_CALC_CRC;
   1721            rq.cparam = &cp;
   1722            rq.clen = UPDATER_CALC_CRC_CP_SIZE;
   1723            rq.rparam = &resp;
   1724            rq.rlen = UPDATER_CALC_CRC_RP_SIZE;
   1725          
   1726            if (hci_send_req(&rq) < 0)
   1727              return -1;
   1728              
   1729            *crc = btohl(resp.crc);
   1730              
   1731            return resp.status;
   1732          }
   1733          
   1734          tBleStatus aci_updater_hw_version(uint8_t *version)
   1735          {
   1736            struct hci_request rq;
   1737            updater_hw_version_rp resp;
   1738          
   1739            Osal_MemSet(&resp, 0, sizeof(resp));
   1740          
   1741            Osal_MemSet(&rq, 0, sizeof(rq));
   1742            rq.ogf = OGF_VENDOR_CMD;
   1743            rq.ocf = OCF_UPDATER_HW_VERSION;
   1744            rq.rparam = &resp;
   1745            rq.rlen = UPDATER_HW_VERSION_RP_SIZE;
   1746          
   1747            if (hci_send_req(&rq) < 0)
   1748              return -1;
   1749              
   1750            *version = resp.version;
   1751          
   1752            return resp.status;
   1753          }
   1754          
   1755          tBleStatus aci_l2cap_connection_parameter_update_request(uint16_t conn_handle, uint16_t interval_min,
   1756          							 uint16_t interval_max, uint16_t slave_latency,
   1757          							 uint16_t timeout_multiplier)
   1758          {
   1759            struct hci_request rq;
   1760            uint8_t status;
   1761            l2cap_conn_param_update_req_cp cp;
   1762          
   1763            cp.conn_handle = htobs(conn_handle);
   1764            cp.interval_min = htobs(interval_min);
   1765            cp.interval_max = htobs(interval_max);
   1766            cp.slave_latency = htobs(slave_latency);
   1767            cp.timeout_multiplier = htobs(timeout_multiplier);
   1768          
   1769            Osal_MemSet(&rq, 0, sizeof(rq));
   1770            rq.ogf = OGF_VENDOR_CMD;
   1771            rq.ocf = OCF_L2CAP_CONN_PARAM_UPDATE_REQ;
   1772            rq.cparam = &cp;
   1773            rq.clen = L2CAP_CONN_PARAM_UPDATE_REQ_CP_SIZE;
   1774            rq.event = EVT_CMD_STATUS;
   1775            rq.rparam = &status;
   1776            rq.rlen = 1;
   1777          
   1778            if (hci_send_req(&rq) < 0)
   1779              return -1;
   1780            
   1781            return status;  
   1782          }
   1783          
   1784          tBleStatus aci_gatt_discovery_characteristic_by_uuid(uint16_t conn_handle, uint16_t start_handle,
   1785          				                     uint16_t end_handle, tHalUint8 charUuidType,
   1786                                                               const tHalUint8* charUuid)
   1787          {
   1788            struct hci_request rq;
   1789            tHalUint8 status;
   1790            
   1791            uint8_t buffer[23];
   1792            uint8_t uuid_len;
   1793            uint8_t indx = 0;
   1794              
   1795            conn_handle = htobs(conn_handle);
   1796            Osal_MemCpy(buffer + indx, &conn_handle, 2);
   1797            indx += 2;
   1798              
   1799            start_handle = htobs(start_handle);
   1800            Osal_MemCpy(buffer + indx, &start_handle, 2);
   1801            indx += 2;
   1802            
   1803            end_handle = htobs(end_handle);
   1804            Osal_MemCpy(buffer + indx, &end_handle, 2);
   1805            indx += 2;
   1806            
   1807            buffer[indx] = charUuidType;
   1808            indx++;
   1809              
   1810            if(charUuidType == 0x01){
   1811              uuid_len = 2;
   1812            }
   1813            else {
   1814              uuid_len = 16;
   1815            }        
   1816            Osal_MemCpy(buffer + indx, charUuid, uuid_len);
   1817            indx +=  uuid_len;
   1818          
   1819            Osal_MemSet(&rq, 0, sizeof(rq));
   1820            rq.ogf = OGF_VENDOR_CMD;
   1821            rq.ocf = OCF_GATT_DISC_CHARAC_BY_UUID;
   1822            rq.cparam = (void *)buffer;
   1823            rq.clen = indx;
   1824            
   1825            rq.rparam = &status;
   1826            rq.rlen = 1;
   1827          
   1828            if (hci_send_req(&rq) < 0)
   1829              return -1;
   1830          
   1831            if (status) {
   1832              return status;
   1833            }
   1834          
   1835            return 0;
   1836          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   aci_erase_blue_flag
        32   -> Osal_MemSet
        32   -> hci_send_req
      32   aci_gap_allow_rebond
        32   -> Osal_MemSet
        32   -> hci_send_req
      32   aci_gap_clear_security_database
        32   -> Osal_MemSet
        32   -> hci_send_req
      32   aci_gap_configure_whitelist
        32   -> Osal_MemSet
        32   -> hci_send_req
      56   aci_gap_create_connection
        56   -> Osal_MemCpy
        56   -> Osal_MemSet
        56   -> hci_send_req
      56   aci_gap_init
        56   -> Osal_MemSet
        56   -> hci_send_req
      40   aci_gap_pass_key_response
        40   -> Osal_MemSet
        40   -> hci_send_req
      72   aci_gap_set_auth_requirement
        72   -> Osal_MemCpy
        72   -> Osal_MemSet
        72   -> hci_send_req
      40   aci_gap_set_direct_connectable
        40   -> Osal_MemCpy
        40   -> Osal_MemSet
        40   -> hci_send_req
      96   aci_gap_set_discoverable
        96   -> Osal_MemCpy
        96   -> Osal_MemSet
        96   -> hci_send_req
      40   aci_gap_set_io_capabilitiy
        40   -> Osal_MemSet
        40   -> hci_send_req
      96   aci_gap_set_limited_discoverable
        96   -> Osal_MemCpy
        96   -> Osal_MemSet
        96   -> hci_send_req
      32   aci_gap_set_non_discoverable
        32   -> Osal_MemSet
        32   -> hci_send_req
      40   aci_gap_slave_security_request
        40   -> Osal_MemSet
        40   -> hci_send_req
     184   aci_gap_start_auto_conn_establishment
       184   -> Osal_MemCpy
       184   -> Osal_MemSet
       184   -> hci_send_req
      40   aci_gap_start_general_discovery_proc
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   aci_gap_start_limited_discovery_proc
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   aci_gap_terminate
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   aci_gap_terminate_gap_procedure
        40   -> Osal_MemSet
        40   -> hci_send_req
      72   aci_gap_update_adv_data
        72   -> Osal_MemCpy
        72   -> Osal_MemSet
        72   -> hci_send_req
      80   aci_gatt_add_char
        80   -> Osal_MemCpy
        80   -> Osal_MemSet
        80   -> hci_send_req
     184   aci_gatt_add_char_desc
       184   -> Osal_MemCpy
       184   -> Osal_MemSet
       184   -> hci_send_req
      64   aci_gatt_add_serv
        64   -> Osal_MemCpy
        64   -> Osal_MemSet
        64   -> hci_send_req
      40   aci_gatt_allow_read
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   aci_gatt_disc_all_charac_descriptors
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   aci_gatt_disc_all_charac_of_serv
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   aci_gatt_disc_all_prim_services
        40   -> Osal_MemSet
        40   -> hci_send_req
      72   aci_gatt_discovery_characteristic_by_uuid
        72   -> Osal_MemCpy
        72   -> Osal_MemSet
        72   -> hci_send_req
      40   aci_gatt_find_included_services
        40   -> Osal_MemSet
        40   -> hci_send_req
      80   aci_gatt_include_service
        80   -> Osal_MemCpy
        80   -> Osal_MemSet
        80   -> hci_send_req
      32   aci_gatt_init
        32   -> Osal_MemSet
        32   -> hci_send_req
      40   aci_gatt_read_charac_val
        40   -> Osal_MemSet
        40   -> hci_send_req
     176   aci_gatt_read_handle_value
       176   -> Osal_MemCpy
       176   -> Osal_MemSet
       176   -> hci_send_req
      40   aci_gatt_read_long_charac_val
        40   -> Osal_MemSet
        40   -> hci_send_req
     184   aci_gatt_set_desc_value
       184   -> Osal_MemCpy
       184   -> Osal_MemSet
       184   -> hci_send_req
     176   aci_gatt_update_char_value
       176   -> Osal_MemCpy
       176   -> Osal_MemSet
       176   -> hci_send_req
     176   aci_gatt_write_charac_descriptor
       176   -> Osal_MemCpy
       176   -> Osal_MemSet
       176   -> hci_send_req
     176   aci_gatt_write_charac_value
       176   -> Osal_MemCpy
       176   -> Osal_MemSet
       176   -> hci_send_req
     184   aci_gatt_write_response
       184   -> Osal_MemCpy
       184   -> Osal_MemSet
       184   -> hci_send_req
     176   aci_gatt_write_without_response
       176   -> Osal_MemCpy
       176   -> Osal_MemSet
       176   -> hci_send_req
      40   aci_get_updater_buffer_size
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   aci_get_updater_version
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   aci_hal_set_tx_power_level
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   aci_hal_tone_start
        40   -> Osal_MemSet
        40   -> hci_send_req
     168   aci_hal_write_config_data
       168   -> Osal_MemCpy
       168   -> Osal_MemSet
       168   -> hci_send_req
      48   aci_l2cap_connection_parameter_update_request
        48   -> Osal_MemSet
        48   -> hci_send_req
      32   aci_reset_blue_flag
        32   -> Osal_MemSet
        32   -> hci_send_req
      56   aci_updater_calc_crc
        56   -> Osal_MemSet
        56   -> hci_send_req
      40   aci_updater_erase_sector
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   aci_updater_hw_version
        40   -> Osal_MemSet
        40   -> hci_send_req
     176   aci_updater_program_data_block
       176   -> Osal_MemCpy
       176   -> Osal_MemSet
       176   -> hci_send_req
     176   aci_updater_read_data_block
       176   -> Osal_MemCpy
       176   -> Osal_MemSet
       176   -> hci_send_req
      32   aci_updater_reboot
        32   -> Osal_MemSet
        32   -> hci_send_req
      32   aci_updater_start
        32   -> Osal_MemSet
        32   -> hci_send_req


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      54  aci_erase_blue_flag
      70  aci_gap_allow_rebond
      70  aci_gap_clear_security_database
      70  aci_gap_configure_whitelist
     132  aci_gap_create_connection
     106  aci_gap_init
      74  aci_gap_pass_key_response
     114  aci_gap_set_auth_requirement
      84  aci_gap_set_direct_connectable
     192  aci_gap_set_discoverable
      66  aci_gap_set_io_capabilitiy
     196  aci_gap_set_limited_discoverable
      54  aci_gap_set_non_discoverable
      78  aci_gap_slave_security_request
     206  aci_gap_start_auto_conn_establishment
      82  aci_gap_start_general_discovery_proc
      82  aci_gap_start_limited_discovery_proc
      74  aci_gap_terminate
      62  aci_gap_terminate_gap_procedure
      88  aci_gap_update_adv_data
     176  aci_gatt_add_char
     226  aci_gatt_add_char_desc
     130  aci_gatt_add_serv
      68  aci_gatt_allow_read
      80  aci_gatt_disc_all_charac_descriptors
      80  aci_gatt_disc_all_charac_of_serv
      72  aci_gatt_disc_all_prim_services
     124  aci_gatt_discovery_characteristic_by_uuid
      80  aci_gatt_find_included_services
     148  aci_gatt_include_service
      56  aci_gatt_init
      76  aci_gatt_read_charac_val
      90  aci_gatt_read_handle_value
      80  aci_gatt_read_long_charac_val
     142  aci_gatt_set_desc_value
     122  aci_gatt_update_char_value
     122  aci_gatt_write_charac_descriptor
     122  aci_gatt_write_charac_value
     128  aci_gatt_write_response
     118  aci_gatt_write_without_response
      72  aci_get_updater_buffer_size
      72  aci_get_updater_version
      70  aci_hal_set_tx_power_level
      66  aci_hal_tone_start
      96  aci_hal_write_config_data
      90  aci_l2cap_connection_parameter_update_request
      54  aci_reset_blue_flag
      90  aci_updater_calc_crc
      64  aci_updater_erase_sector
      72  aci_updater_hw_version
     114  aci_updater_program_data_block
      94  aci_updater_read_data_block
      54  aci_updater_reboot
      54  aci_updater_start

 
 5 256 bytes in section .text
 
 5 256 bytes of CODE memory

Errors: none
Warnings: none
