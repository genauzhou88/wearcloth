###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.60.1.5097/W32 for ARM      09/Oct/2014  10:33:34 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\FredZhou\Documents\Origin\Projects\platform\STM #
#                    32L1XX\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1x #
#                    x_flash.c                                                #
#    Command line =  C:\Users\FredZhou\Documents\Origin\Projects\platform\STM #
#                    32L1XX\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1x #
#                    x_flash.c -D USE_STDPERIPH_DRIVER -D STM32L1XX_MD -D     #
#                    SYSCLK_FREQ_HSI_32MHz -D ENABLE_USB -D                   #
#                    ENABLE_USB_PRINTF -D CLIENT=1 -D DEBUG -D                #
#                    BLUENRG_CONFIG=BLUENRG_16_MHZ -lcN                       #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Client\List\ --diag_suppress Pa050 -o         #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Client\Obj\ --debug --endian=little           #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.5\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\inc\ -I "C:\Users\FredZhou\Documents\Origi #
#                    n\Projects\Project\BLE_Chat\EWARM\..\..\..\Bluetooth     #
#                    LE\SimpleBlueNRG_HCI\" -I "C:\Users\FredZhou\Documents\O #
#                    rigin\Projects\Project\BLE_Chat\EWARM\..\..\..\Bluetooth #
#                     LE\SimpleBlueNRG_HCI\includes\" -I                      #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\ -I               #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\ -I     #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\CMSIS\C #
#                    M3\DeviceSupport\ST\STM32L1xx\ -I                        #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32_U #
#                    SB-FS-Device_Driver\inc\ -I                              #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32L1 #
#                    xx_StdPeriph_Driver\inc\ -I                              #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\I2C\inc #
#                    \ -I C:\Users\FredZhou\Documents\Origin\Projects\Project #
#                    \BLE_Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\LI #
#                    S3DH\inc\ -I C:\Users\FredZhou\Documents\Origin\Projects #
#                    \Project\BLE_Chat\EWARM\..\..\..\platform\STM32L1XX\Libr #
#                    aries\STLM75\inc\ -I C:\Users\FredZhou\Documents\Origin\ #
#                    Projects\Project\BLE_Chat\EWARM\..\..\..\platform\STM32L #
#                    1XX\Libraries\HTS221\inc\ -I                             #
#                    C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries\LPS25H\ #
#                    inc\ -I C:\Users\FredZhou\Documents\Origin\Projects\Proj #
#                    ect\BLE_Chat\EWARM\..\..\..\platform\STM32L1XX\Libraries #
#                    \SDK_Eval_STM32L\inc\ -Ohs --use_c++_inline -I           #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Client\List\stm32l1xx_flash.lst               #
#    Object file  =  C:\Users\FredZhou\Documents\Origin\Projects\Project\BLE_ #
#                    Chat\EWARM\Client\Obj\stm32l1xx_flash.o                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\FredZhou\Documents\Origin\Projects\platform\STM32L1XX\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_flash.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    31-January-2014
      7            * @brief   This file provides all the Flash firmware functions. These functions 
      8            *          can be executed from Internal FLASH or Internal SRAM memories. 
      9            *          The functions that should be called from SRAM are defined inside 
     10            *          the "stm32l1xx_flash_ramfunc.c" file.
     11            *          This file provides firmware functions to manage the following 
     12            *          functionalities of the FLASH peripheral:
     13            *            + FLASH Interface configuration
     14            *            + FLASH Memory Programming
     15            *            + DATA EEPROM Programming
     16            *            + Option Bytes Programming
     17            *            + Interrupts and flags management
     18            *
     19            *  @verbatim
     20          
     21            ==============================================================================
     22                                  ##### How to use this driver #####
     23            ==============================================================================
     24              [..] This driver provides functions to configure and program the Flash 
     25                   memory of all STM32L1xx devices.
     26              [..] These functions are split in 5 groups:
     27                   (#) FLASH Interface configuration functions: this group includes 
     28                       the management of following features:
     29                       (++) Set the latency.
     30                       (++) Enable/Disable the prefetch buffer.
     31                       (++) Enable/Disable the 64 bit Read Access. 
     32                       (++) Enable/Disable the RUN PowerDown mode.
     33                       (++) Enable/Disable the SLEEP PowerDown mode.  
     34              
     35                   (#) FLASH Memory Programming functions: this group includes all 
     36                       needed functions to erase and program the main memory:
     37                       (++) Lock and Unlock the Flash interface.
     38                       (++) Erase function: Erase Page.
     39                       (++) Program functions: Fast Word and Half Page(should be 
     40                            executed from internal SRAM).
     41                
     42                   (#) DATA EEPROM Programming functions: this group includes all 
     43                       needed functions to erase and program the DATA EEPROM memory:
     44                       (++) Lock and Unlock the DATA EEPROM interface.
     45                       (++) Erase function: Erase Byte, erase HalfWord, erase Word, erase 
     46                       (++) Double Word (should be executed from internal SRAM).
     47                       (++) Program functions: Fast Program Byte, Fast Program Half-Word, 
     48                            FastProgramWord, Program Byte, Program Half-Word, 
     49                            Program Word and Program Double-Word (should be executed 
     50                            from internal SRAM).
     51                
     52                   (#) FLASH Option Bytes Programming functions: this group includes 
     53                       all needed functions to:
     54                       (++) Lock and Unlock the Flash Option bytes.
     55                       (++) Set/Reset the write protection.
     56                       (++) Set the Read protection Level.
     57                       (++) Set the BOR level.
     58                       (++) rogram the user option Bytes.
     59                       (++) Launch the Option Bytes loader.
     60                       (++) Get the Write protection.
     61                       (++) Get the read protection status.
     62                       (++) Get the BOR level.
     63                       (++) Get the user option bytes.
     64              
     65                   (#) FLASH Interrupts and flag management functions: this group 
     66                       includes all needed functions to:
     67                       (++) Enable/Disable the flash interrupt sources.
     68                       (++) Get flags status.
     69                       (++) Clear flags.
     70                       (++) Get Flash operation status.
     71                       (++) Wait for last flash operation.
     72          
     73            *  @endverbatim
     74            *                      
     75            ******************************************************************************
     76            * @attention
     77            *
     78            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     79            *
     80            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     81            * You may not use this file except in compliance with the License.
     82            * You may obtain a copy of the License at:
     83            *
     84            *        http://www.st.com/software_license_agreement_liberty_v2
     85            *
     86            * Unless required by applicable law or agreed to in writing, software 
     87            * distributed under the License is distributed on an "AS IS" BASIS, 
     88            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     89            * See the License for the specific language governing permissions and
     90            * limitations under the License.
     91            *
     92            ******************************************************************************
     93            */
     94          
     95          /* Includes ------------------------------------------------------------------*/
     96          #include "stm32l1xx_flash.h"
     97          
     98          /** @addtogroup STM32L1xx_StdPeriph_Driver
     99            * @{
    100            */
    101          
    102          /** @defgroup FLASH 
    103            * @brief FLASH driver modules
    104            * @{
    105            */ 
    106          
    107          /* Private typedef -----------------------------------------------------------*/
    108          /* Private define ------------------------------------------------------------*/
    109            
    110          /* FLASH Mask */
    111          #define WRP01_MASK                 ((uint32_t)0x0000FFFF)
    112          #define WRP23_MASK                 ((uint32_t)0xFFFF0000)
    113          #define WRP45_MASK                 ((uint32_t)0x0000FFFF)
    114          #define WRP67_MASK                 ((uint32_t)0xFFFF0000)
    115          #define WRP89_MASK                 ((uint32_t)0x0000FFFF)
    116          #define WRP1011_MASK               ((uint32_t)0xFFFF0000)
    117          
    118          /* Private macro -------------------------------------------------------------*/
    119          /* Private variables ---------------------------------------------------------*/
    120          /* Private function prototypes -----------------------------------------------*/
    121          /* Private functions ---------------------------------------------------------*/
    122           
    123          /** @defgroup FLASH_Private_Functions
    124            * @{
    125            */ 
    126          
    127          /** @defgroup FLASH_Group1 FLASH Interface configuration functions
    128            *  @brief   FLASH Interface configuration functions 
    129           *
    130          @verbatim   
    131            ============================================================================== 
    132                       ##### FLASH Interface configuration functions #####
    133            ==============================================================================
    134          
    135              [..] FLASH_Interface configuration_Functions, includes the following functions:
    136               (+) void FLASH_SetLatency(uint32_t FLASH_Latency):
    137              [..] To correctly read data from Flash memory, the number of wait states (LATENCY) 
    138                   must be correctly programmed according to the frequency of the CPU clock 
    139                  (HCLK) and the supply voltage of the device.
    140            [..] 
    141            ----------------------------------------------------------------
    142           |  Wait states  |                HCLK clock frequency (MHz)      |
    143           |               |------------------------------------------------|
    144           |   (Latency)   |            voltage range       | voltage range |
    145           |               |            1.65 V - 3.6 V      | 2.0 V - 3.6 V |
    146           |               |----------------|---------------|---------------|
    147           |               |  VCORE = 1.2 V | VCORE = 1.5 V | VCORE = 1.8 V |
    148           |-------------- |----------------|---------------|---------------|
    149           |0WS(1CPU cycle)|0 < HCLK <= 2   |0 < HCLK <= 8  |0 < HCLK <= 16 |
    150           |---------------|----------------|---------------|---------------|
    151           |1WS(2CPU cycle)|2 < HCLK <= 4   |8 < HCLK <= 16 |16 < HCLK <= 32|
    152            ----------------------------------------------------------------
    153            [..]
    154               (+) void FLASH_PrefetchBufferCmd(FunctionalState NewState);
    155               (+) void FLASH_ReadAccess64Cmd(FunctionalState NewState);
    156               (+) void FLASH_RUNPowerDownCmd(FunctionalState NewState);
    157               (+) void FLASH_SLEEPPowerDownCmd(FunctionalState NewState);
    158               (+) void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState);
    159            [..]     
    160            Here below the allowed configuration of Latency, 64Bit access and prefetch buffer
    161            [..]  
    162            --------------------------------------------------------------------------------
    163           |               |              ACC64 = 0         |              ACC64 = 1        |
    164           |   Latency     |----------------|---------------|---------------|---------------|
    165           |               |   PRFTEN = 0   |   PRFTEN = 1  |   PRFTEN = 0  |   PRFTEN = 1  |
    166           |---------------|----------------|---------------|---------------|---------------|
    167           |0WS(1CPU cycle)|     YES        |     NO        |     YES       |     YES       |
    168           |---------------|----------------|---------------|---------------|---------------|
    169           |1WS(2CPU cycle)|     NO         |     NO        |     YES       |     YES       |
    170            --------------------------------------------------------------------------------
    171            [..]
    172             All these functions don't need the unlock sequence.
    173          
    174          @endverbatim
    175            * @{
    176            */
    177          
    178          /**
    179            * @brief  Sets the code latency value.
    180            * @param  FLASH_Latency: specifies the FLASH Latency value.
    181            *   This parameter can be one of the following values:
    182            *     @arg FLASH_Latency_0: FLASH Zero Latency cycle.
    183            *     @arg FLASH_Latency_1: FLASH One Latency cycle.
    184            * @retval None
    185            */
    186          void FLASH_SetLatency(uint32_t FLASH_Latency)
    187          {
    188             uint32_t tmpreg = 0;
    189            
    190            /* Check the parameters */
    191            assert_param(IS_FLASH_LATENCY(FLASH_Latency));
    192            
    193            /* Read the ACR register */
    194            tmpreg = FLASH->ACR;  
    195            
    196            /* Sets the Latency value */
    197            tmpreg &= (uint32_t) (~((uint32_t)FLASH_ACR_LATENCY));
    198            tmpreg |= FLASH_Latency;
    199            
    200            /* Write the ACR register */
    201            FLASH->ACR = tmpreg;
    202          }
    203          
    204          /**
    205            * @brief  Enables or disables the Prefetch Buffer.
    206            * @param  NewState: new state of the FLASH prefetch buffer.
    207            *              This parameter can be: ENABLE or DISABLE. 
    208            * @retval None
    209            */
    210          void FLASH_PrefetchBufferCmd(FunctionalState NewState)
    211          {
    212            /* Check the parameters */
    213            assert_param(IS_FUNCTIONAL_STATE(NewState));
    214             
    215            if(NewState != DISABLE)
    216            {
    217              FLASH->ACR |= FLASH_ACR_PRFTEN;
    218            }
    219            else
    220            {
    221              FLASH->ACR &= (uint32_t)(~((uint32_t)FLASH_ACR_PRFTEN));
    222            }
    223          }
    224          
    225          /**
    226            * @brief  Enables or disables read access to flash by 64 bits.
    227            * @param  NewState: new state of the FLASH read access mode.
    228            *              This parameter can be: ENABLE or DISABLE.
    229            * @note    If this bit is set, the Read access 64 bit is used.
    230            *          If this bit is reset, the Read access 32 bit is used.
    231            * @note    This bit cannot be written at the same time as the LATENCY and 
    232            *          PRFTEN bits.
    233            *          To reset this bit, the LATENCY should be zero wait state and the 
    234            *          prefetch off.
    235            * @retval None
    236            */
    237          void FLASH_ReadAccess64Cmd(FunctionalState NewState)
    238          {
    239            /* Check the parameters */
    240            assert_param(IS_FUNCTIONAL_STATE(NewState));
    241            
    242            if(NewState != DISABLE)
    243            {
    244              FLASH->ACR |= FLASH_ACR_ACC64;
    245            }
    246            else
    247            {
    248              FLASH->ACR &= (uint32_t)(~((uint32_t)FLASH_ACR_ACC64));
    249            }
    250          }
    251          
    252          /**
    253            * @brief  Enable or disable the power down mode during Sleep mode.
    254            * @note   This function is used to power down the FLASH when the system is in SLEEP LP mode.
    255            * @param  NewState: new state of the power down mode during sleep mode.
    256            *   This parameter can be: ENABLE or DISABLE.
    257            * @retval None
    258            */
    259          void FLASH_SLEEPPowerDownCmd(FunctionalState NewState)
    260          {
    261            /* Check the parameters */
    262            assert_param(IS_FUNCTIONAL_STATE(NewState));
    263            
    264            if (NewState != DISABLE)
    265            {
    266              /* Set the SLEEP_PD bit to put Flash in power down mode during sleep mode */
    267              FLASH->ACR |= FLASH_ACR_SLEEP_PD;
    268            }
    269            else
    270            {
    271              /* Clear the SLEEP_PD bit in to put Flash in idle mode during sleep mode */
    272              FLASH->ACR &= (uint32_t)(~((uint32_t)FLASH_ACR_SLEEP_PD));
    273            }
    274          }
    275          
    276          /**
    277            * @}
    278            */
    279          
    280          /** @defgroup FLASH_Group2 FLASH Memory Programming functions
    281           *  @brief   FLASH Memory Programming functions
    282           *
    283          @verbatim   
    284            ==============================================================================
    285                          ##### FLASH Memory Programming functions ##### 
    286            ==============================================================================
    287          
    288              [..] The FLASH Memory Programming functions, includes the following functions:
    289              (+) void FLASH_Unlock(void);
    290              (+) void FLASH_Lock(void);
    291              (+) FLASH_Status FLASH_ErasePage(uint32_t Page_Address);
    292              (+) FLASH_Status FLASH_FastProgramWord(uint32_t Address, uint32_t Data);
    293             
    294              [..] Any operation of erase or program should follow these steps:
    295              (#) Call the FLASH_Unlock() function to enable the flash control register and 
    296                  program memory access.
    297              (#) Call the desired function to erase page or program data.
    298              (#) Call the FLASH_Lock() to disable the flash program memory access 
    299                 (recommended to protect the FLASH memory against possible unwanted operation).
    300          
    301          @endverbatim
    302            * @{
    303            */
    304          
    305          /**
    306            * @brief  Unlocks the FLASH control register and program memory access.
    307            * @param  None
    308            * @retval None
    309            */
    310          void FLASH_Unlock(void)
    311          {
    312            if((FLASH->PECR & FLASH_PECR_PRGLOCK) != RESET)
    313            {
    314              /* Unlocking the data memory and FLASH_PECR register access */
    315              DATA_EEPROM_Unlock();
    316            
    317              /* Unlocking the program memory access */
    318              FLASH->PRGKEYR = FLASH_PRGKEY1;
    319              FLASH->PRGKEYR = FLASH_PRGKEY2;  
    320            }
    321          }
    322          
    323          /**
    324            * @brief  Locks the Program memory access.
    325            * @param  None
    326            * @retval None
    327            */
    328          void FLASH_Lock(void)
    329          {
    330            /* Set the PRGLOCK Bit to lock the program memory access */
    331            FLASH->PECR |= FLASH_PECR_PRGLOCK;
    332          }
    333          
    334          /**
    335            * @brief  Erases a specified page in program memory.
    336            * @note   To correctly run this function, the FLASH_Unlock() function
    337            *         must be called before.
    338            *         Call the FLASH_Lock() to disable the flash memory access 
    339            *         (recommended to protect the FLASH memory against possible unwanted operation)
    340            * @param  Page_Address: The page address in program memory to be erased.
    341            * @note   A Page is erased in the Program memory only if the address to load 
    342            *         is the start address of a page (multiple of 256 bytes).
    343            * @retval FLASH Status: The returned value can be: 
    344            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    345            */
    346          FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
    347          {
    348            FLASH_Status status = FLASH_COMPLETE;
    349          
    350            /* Check the parameters */
    351            assert_param(IS_FLASH_PROGRAM_ADDRESS(Page_Address));
    352           
    353            /* Wait for last operation to be completed */
    354            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    355            
    356            if(status == FLASH_COMPLETE)
    357            {
    358              /* If the previous operation is completed, proceed to erase the page */
    359          
    360              /* Set the ERASE bit */
    361              FLASH->PECR |= FLASH_PECR_ERASE;
    362          
    363              /* Set PROG bit */
    364              FLASH->PECR |= FLASH_PECR_PROG;
    365            
    366              /* Write 00000000h to the first word of the program page to erase */
    367              *(__IO uint32_t *)Page_Address = 0x00000000;
    368           
    369              /* Wait for last operation to be completed */
    370              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    371          
    372              /* If the erase operation is completed, disable the ERASE and PROG bits */
    373              FLASH->PECR &= (uint32_t)(~FLASH_PECR_PROG);
    374              FLASH->PECR &= (uint32_t)(~FLASH_PECR_ERASE);   
    375            }     
    376            /* Return the Erase Status */
    377            return status;
    378          }
    379          
    380          /**
    381            * @brief  Programs a word at a specified address in program memory.
    382            * @note   To correctly run this function, the FLASH_Unlock() function
    383            *         must be called before.
    384            *         Call the FLASH_Lock() to disable the flash memory access
    385            *         (recommended to protect the FLASH memory against possible unwanted operation).
    386            * @param  Address: specifies the address to be written.
    387            * @param  Data: specifies the data to be written.
    388            * @retval FLASH Status: The returned value can be:  
    389            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    390            */
    391          FLASH_Status FLASH_FastProgramWord(uint32_t Address, uint32_t Data)
    392          {
    393            FLASH_Status status = FLASH_COMPLETE;
    394          
    395            /* Check the parameters */
    396            assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
    397            
    398            /* Wait for last operation to be completed */
    399            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    400            
    401            if(status == FLASH_COMPLETE)
    402            {
    403              /* If the previous operation is completed, proceed to program the new  word */  
    404              *(__IO uint32_t *)Address = Data;
    405              
    406              /* Wait for last operation to be completed */
    407              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);       
    408            }
    409            /* Return the Write Status */
    410            return status;
    411          }
    412          
    413          /**
    414            * @}
    415            */
    416            
    417          /** @defgroup FLASH_Group3 DATA EEPROM Programming functions
    418           *  @brief   DATA EEPROM Programming functions
    419           *
    420          @verbatim   
    421           ===============================================================================
    422                               ##### DATA EEPROM Programming functions ##### 
    423           ===============================================================================  
    424           
    425              [..] The DATA_EEPROM Programming_Functions, includes the following functions:
    426                  (+) void DATA_EEPROM_Unlock(void);
    427                  (+) void DATA_EEPROM_Lock(void);
    428                  (+) FLASH_Status DATA_EEPROM_EraseByte(uint32_t Address);
    429                  (+) FLASH_Status DATA_EEPROM_EraseHalfWord(uint32_t Address);
    430                  (+) FLASH_Status DATA_EEPROM_EraseWord(uint32_t Address);
    431                  (+) FLASH_Status DATA_EEPROM_FastProgramByte(uint32_t Address, uint8_t Data);
    432                  (+) FLASH_Status DATA_EEPROM_FastProgramHalfWord(uint32_t Address, uint16_t Data);
    433                  (+) FLASH_Status DATA_EEPROM_FastProgramWord(uint32_t Address, uint32_t Data);
    434                  (+) FLASH_Status DATA_EEPROM_ProgramByte(uint32_t Address, uint8_t Data);
    435                  (+) FLASH_Status DATA_EEPROM_ProgramHalfWord(uint32_t Address, uint16_t Data);
    436                  (+) FLASH_Status DATA_EEPROM_ProgramWord(uint32_t Address, uint32_t Data);
    437             
    438              [..] Any operation of erase or program should follow these steps:
    439              (#) Call the DATA_EEPROM_Unlock() function to enable the data EEPROM access
    440                  and Flash program erase control register access.
    441              (#) Call the desired function to erase or program data.
    442              (#) Call the DATA_EEPROM_Lock() to disable the data EEPROM access
    443                  and Flash program erase control register access(recommended
    444                  to protect the DATA_EEPROM against possible unwanted operation).
    445          
    446          @endverbatim
    447            * @{
    448            */
    449          
    450          /**
    451            * @brief  Unlocks the data memory and FLASH_PECR register access.
    452            * @param  None
    453            * @retval None
    454            */
    455          void DATA_EEPROM_Unlock(void)
    456          {
    457            if((FLASH->PECR & FLASH_PECR_PELOCK) != RESET)
    458            {  
    459              /* Unlocking the Data memory and FLASH_PECR register access*/
    460              FLASH->PEKEYR = FLASH_PEKEY1;
    461              FLASH->PEKEYR = FLASH_PEKEY2;
    462            }
    463          }
    464          
    465          /**
    466            * @brief  Locks the Data memory and FLASH_PECR register access.
    467            * @param  None
    468            * @retval None
    469            */
    470          void DATA_EEPROM_Lock(void)
    471          {
    472            /* Set the PELOCK Bit to lock the data memory and FLASH_PECR register access */
    473            FLASH->PECR |= FLASH_PECR_PELOCK;
    474          }
    475          
    476          /**
    477            * @brief  Enables or disables DATA EEPROM fixed Time programming (2*Tprog).
    478            * @param  NewState: new state of the DATA EEPROM fixed Time programming mode.
    479            *         This parameter can be: ENABLE or DISABLE.  
    480            * @retval None
    481            */
    482          void DATA_EEPROM_FixedTimeProgramCmd(FunctionalState NewState)
    483          {
    484            /* Check the parameters */
    485            assert_param(IS_FUNCTIONAL_STATE(NewState));
    486            
    487            if(NewState != DISABLE)
    488            {
    489              FLASH->PECR |= (uint32_t)FLASH_PECR_FTDW;
    490            }
    491            else
    492            {
    493              FLASH->PECR &= (uint32_t)(~((uint32_t)FLASH_PECR_FTDW));
    494            }
    495          }
    496          
    497          /**
    498            * @brief  Erase a byte in data memory.
    499            * @param  Address: specifies the address to be erased.
    500            * @note   This function can be used only for STM32L1XX_HD, STM32L1XX_MDP and  
    501            *         STM32L1XX_XL devices.
    502            * @note   To correctly run this function, the DATA_EEPROM_Unlock() function
    503            *         must be called before.
    504            *         Call the DATA_EEPROM_Lock() to disable the data EEPROM access
    505            *         and Flash program erase control register access(recommended to protect 
    506            *         the DATA_EEPROM against possible unwanted operation).
    507            * @retval FLASH Status: The returned value can be: 
    508            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    509            */
    510          FLASH_Status DATA_EEPROM_EraseByte(uint32_t Address)
    511          {
    512            FLASH_Status status = FLASH_COMPLETE;
    513            
    514            /* Check the parameters */
    515            assert_param(IS_FLASH_DATA_ADDRESS(Address));
    516            
    517            /* Wait for last operation to be completed */
    518            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    519            
    520            if(status == FLASH_COMPLETE)
    521            {
    522              /* Write "00h" to valid address in the data memory" */
    523              *(__IO uint8_t *) Address = (uint8_t)0x00;
    524            }
    525             
    526            /* Return the erase status */
    527            return status;
    528          }
    529          
    530          /**
    531            * @brief  Erase a halfword in data memory.
    532            * @param  Address: specifies the address to be erased.
    533            * @note   This function can be used only for STM32L1XX_HD, STM32L1XX_MDP and  
    534            *         STM32L1XX_XL devices.
    535            * @note   To correctly run this function, the DATA_EEPROM_Unlock() function
    536            *         must be called before.
    537            *         Call the DATA_EEPROM_Lock() to disable the data EEPROM access
    538            *         and Flash program erase control register access(recommended to protect 
    539            *         the DATA_EEPROM against possible unwanted operation).
    540            * @retval FLASH Status: The returned value can be: 
    541            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    542            */
    543          FLASH_Status DATA_EEPROM_EraseHalfWord(uint32_t Address)
    544          {
    545            FLASH_Status status = FLASH_COMPLETE;
    546            
    547            /* Check the parameters */
    548            assert_param(IS_FLASH_DATA_ADDRESS(Address));
    549            
    550            /* Wait for last operation to be completed */
    551            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    552            
    553            if(status == FLASH_COMPLETE)
    554            {
    555              /* Write "0000h" to valid address in the data memory" */
    556              *(__IO uint16_t *) Address = (uint16_t)0x0000;
    557            }
    558             
    559            /* Return the erase status */
    560            return status;
    561          }
    562          
    563          /**
    564            * @brief  Erase a word in data memory.
    565            * @param  Address: specifies the address to be erased.
    566            * @note   For STM32L1XX_MD, A data memory word is erased in the data memory only 
    567            *         if the address to load is the start address of a word (multiple of a word).
    568            * @note   To correctly run this function, the DATA_EEPROM_Unlock() function
    569            *         must be called before.
    570            *         Call the DATA_EEPROM_Lock() to disable the data EEPROM access
    571            *         and Flash program erase control register access(recommended to protect 
    572            *         the DATA_EEPROM against possible unwanted operation).
    573            * @retval FLASH Status: The returned value can be: 
    574            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    575            */
    576          FLASH_Status DATA_EEPROM_EraseWord(uint32_t Address)
    577          {
    578            FLASH_Status status = FLASH_COMPLETE;
    579            
    580            /* Check the parameters */
    581            assert_param(IS_FLASH_DATA_ADDRESS(Address));
    582            
    583            /* Wait for last operation to be completed */
    584            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    585            
    586            if(status == FLASH_COMPLETE)
    587            {
    588              /* Write "00000000h" to valid address in the data memory" */
    589              *(__IO uint32_t *) Address = 0x00000000;
    590            }
    591             
    592            /* Return the erase status */
    593            return status;
    594          }
    595          
    596          /**
    597            * @brief  Write a Byte at a specified address in data memory.
    598            * @note   To correctly run this function, the DATA_EEPROM_Unlock() function
    599            *         must be called before.
    600            *         Call the DATA_EEPROM_Lock() to disable the data EEPROM access
    601            *         and Flash program erase control register access(recommended to protect 
    602            *         the DATA_EEPROM against possible unwanted operation).
    603            * @param  Address: specifies the address to be written.
    604            * @param  Data: specifies the data to be written.
    605            * @note   This function assumes that the is data word is already erased.
    606            * @retval FLASH Status: The returned value can be:
    607            *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    608            */
    609          FLASH_Status DATA_EEPROM_FastProgramByte(uint32_t Address, uint8_t Data)
    610          {
    611            FLASH_Status status = FLASH_COMPLETE;
    612          #if !defined (STM32L1XX_HD) && !defined (STM32L1XX_MDP) && !defined (STM32L1XX_XL)
    613            uint32_t tmp = 0, tmpaddr = 0;
    614          #endif
    615            
    616            /* Check the parameters */
    617            assert_param(IS_FLASH_DATA_ADDRESS(Address)); 
    618          
    619            /* Wait for last operation to be completed */
    620            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    621              
    622            if(status == FLASH_COMPLETE)
    623            {
    624              /* Clear the FTDW bit */
    625              FLASH->PECR &= (uint32_t)(~((uint32_t)FLASH_PECR_FTDW));
    626          
    627          #if !defined (STM32L1XX_HD) && !defined (STM32L1XX_MDP) && !defined (STM32L1XX_XL)
    628              if(Data != (uint8_t)0x00) 
    629              {
    630                /* If the previous operation is completed, proceed to write the new Data */
    631                *(__IO uint8_t *)Address = Data;
    632                      
    633                /* Wait for last operation to be completed */
    634                status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    635              }
    636              else
    637              {
    638                tmpaddr = Address & 0xFFFFFFFC;
    639                tmp = * (__IO uint32_t *) tmpaddr;
    640                tmpaddr = 0xFF << ((uint32_t) (0x8 * (Address & 0x3)));
    641                tmp &= ~tmpaddr;
    642                status = DATA_EEPROM_EraseWord(Address & 0xFFFFFFFC);
    643                status = DATA_EEPROM_FastProgramWord((Address & 0xFFFFFFFC), tmp);
    644              }       
    645          #elif defined (STM32L1XX_HD) || defined (STM32L1XX_MDP) || defined (STM32L1XX_XL)
    646              /* If the previous operation is completed, proceed to write the new Data */
    647              *(__IO uint8_t *)Address = Data;
    648                      
    649              /* Wait for last operation to be completed */
    650              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    651          #endif  
    652            }
    653            /* Return the Write Status */
    654            return status;
    655          }
    656          
    657          /**
    658            * @brief  Writes a half word at a specified address in data memory.
    659            * @note   To correctly run this function, the DATA_EEPROM_Unlock() function
    660            *         must be called before.
    661            *         Call the DATA_EEPROM_Lock() to disable the data EEPROM access
    662            *         and Flash program erase control register access(recommended to protect 
    663            *         the DATA_EEPROM against possible unwanted operation).
    664            * @param  Address: specifies the address to be written.
    665            * @param  Data: specifies the data to be written.
    666            * @note   This function assumes that the is data word is already erased.
    667            * @retval FLASH Status: The returned value can be: 
    668            *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or  FLASH_TIMEOUT. 
    669            */
    670          FLASH_Status DATA_EEPROM_FastProgramHalfWord(uint32_t Address, uint16_t Data)
    671          {
    672            FLASH_Status status = FLASH_COMPLETE;
    673          #if !defined (STM32L1XX_HD) && !defined (STM32L1XX_MDP) && !defined (STM32L1XX_XL)
    674            uint32_t tmp = 0, tmpaddr = 0;
    675          #endif
    676            
    677            /* Check the parameters */
    678            assert_param(IS_FLASH_DATA_ADDRESS(Address));
    679          
    680            /* Wait for last operation to be completed */
    681            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    682              
    683            if(status == FLASH_COMPLETE)
    684            {
    685              /* Clear the FTDW bit */
    686              FLASH->PECR &= (uint32_t)(~((uint32_t)FLASH_PECR_FTDW));
    687          
    688          #if !defined (STM32L1XX_HD) && !defined (STM32L1XX_MDP) && !defined (STM32L1XX_XL)
    689              if(Data != (uint16_t)0x0000) 
    690              {
    691                /* If the previous operation is completed, proceed to write the new data */
    692                *(__IO uint16_t *)Address = Data;
    693            
    694                /* Wait for last operation to be completed */
    695                status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    696              }
    697              else
    698              {
    699                if((Address & 0x3) != 0x3)
    700                {
    701                  tmpaddr = Address & 0xFFFFFFFC;
    702                  tmp = * (__IO uint32_t *) tmpaddr;
    703                  tmpaddr = 0xFFFF << ((uint32_t) (0x8 * (Address & 0x3)));
    704                  tmp &= ~tmpaddr;        
    705                  status = DATA_EEPROM_EraseWord(Address & 0xFFFFFFFC);
    706                  status = DATA_EEPROM_FastProgramWord((Address & 0xFFFFFFFC), tmp);
    707                }
    708                else
    709                {
    710                  DATA_EEPROM_FastProgramByte(Address, 0x00);
    711                  DATA_EEPROM_FastProgramByte(Address + 1, 0x00);
    712                }
    713              }
    714          #elif defined (STM32L1XX_HD) || defined (STM32L1XX_MDP) || defined (STM32L1XX_XL)
    715              /* If the previous operation is completed, proceed to write the new data */
    716              *(__IO uint16_t *)Address = Data;
    717            
    718              /* Wait for last operation to be completed */
    719              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    720          #endif
    721            }
    722            /* Return the Write Status */
    723            return status;
    724          }
    725          
    726          /**
    727            * @brief  Programs a word at a specified address in data memory.
    728            * @note   To correctly run this function, the DATA_EEPROM_Unlock() function
    729            *         must be called before.
    730            *         Call the DATA_EEPROM_Lock() to disable the data EEPROM access
    731            *         and Flash program erase control register access(recommended to protect 
    732            *         the DATA_EEPROM against possible unwanted operation).
    733            * @param  Address: specifies the address to be written.
    734            * @param  Data: specifies the data to be written.
    735            * @note   This function assumes that the is data word is already erased.
    736            * @retval FLASH Status: The returned value can be: 
    737            *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    738            */
    739          FLASH_Status DATA_EEPROM_FastProgramWord(uint32_t Address, uint32_t Data)
    740          {
    741            FLASH_Status status = FLASH_COMPLETE;
    742          
    743            /* Check the parameters */
    744            assert_param(IS_FLASH_DATA_ADDRESS(Address));
    745            
    746            /* Wait for last operation to be completed */
    747            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    748            
    749            if(status == FLASH_COMPLETE)
    750            {
    751              /* Clear the FTDW bit */
    752              FLASH->PECR &= (uint32_t)(~((uint32_t)FLASH_PECR_FTDW));
    753            
    754              /* If the previous operation is completed, proceed to program the new data */    
    755              *(__IO uint32_t *)Address = Data;
    756              
    757              /* Wait for last operation to be completed */
    758              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);       
    759            }
    760            /* Return the Write Status */
    761            return status;
    762          }
    763          
    764          /**
    765            * @brief  Write a Byte at a specified address in data memory without erase.
    766            * @note   To correctly run this function, the DATA_EEPROM_Unlock() function
    767            *         must be called before.
    768            *         Call the DATA_EEPROM_Lock() to disable the data EEPROM access
    769            *         and Flash program erase control register access(recommended to protect 
    770            *         the DATA_EEPROM against possible unwanted operation).
    771            * @note   The function  DATA_EEPROM_FixedTimeProgramCmd() can be called before 
    772            *         this function to configure the Fixed Time Programming.
    773            * @param  Address: specifies the address to be written.
    774            * @param  Data: specifies the data to be written.
    775            * @retval FLASH Status: The returned value can be: 
    776            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    777            */
    778          FLASH_Status DATA_EEPROM_ProgramByte(uint32_t Address, uint8_t Data)
    779          {
    780            FLASH_Status status = FLASH_COMPLETE;
    781          #if !defined (STM32L1XX_HD) && !defined (STM32L1XX_MDP) && !defined (STM32L1XX_XL)
    782            uint32_t tmp = 0, tmpaddr = 0;
    783          #endif
    784            
    785            /* Check the parameters */
    786            assert_param(IS_FLASH_DATA_ADDRESS(Address)); 
    787          
    788            /* Wait for last operation to be completed */
    789            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    790            
    791            if(status == FLASH_COMPLETE)
    792            {
    793          #if !defined (STM32L1XX_HD) && !defined (STM32L1XX_MDP) && !defined (STM32L1XX_XL)
    794              if(Data != (uint8_t) 0x00)
    795              {  
    796                *(__IO uint8_t *)Address = Data;
    797              
    798                /* Wait for last operation to be completed */
    799                status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    800          
    801              }
    802              else
    803              {
    804                tmpaddr = Address & 0xFFFFFFFC;
    805                tmp = * (__IO uint32_t *) tmpaddr;
    806                tmpaddr = 0xFF << ((uint32_t) (0x8 * (Address & 0x3)));
    807                tmp &= ~tmpaddr;        
    808                status = DATA_EEPROM_EraseWord(Address & 0xFFFFFFFC);
    809                status = DATA_EEPROM_FastProgramWord((Address & 0xFFFFFFFC), tmp);
    810              }
    811          #elif defined (STM32L1XX_HD) || defined (STM32L1XX_MDP) || defined (STM32L1XX_XL)
    812              *(__IO uint8_t *)Address = Data;
    813              
    814              /* Wait for last operation to be completed */
    815              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    816          #endif
    817            }
    818            /* Return the Write Status */
    819            return status;
    820          }
    821          
    822          /**
    823            * @brief  Writes a half word at a specified address in data memory without erase.
    824            * @note   To correctly run this function, the DATA_EEPROM_Unlock() function
    825            *         must be called before.
    826            *         Call the DATA_EEPROM_Lock() to disable the data EEPROM access
    827            *         and Flash program erase control register access(recommended to protect 
    828            *         the DATA_EEPROM against possible unwanted operation).
    829            * @note   The function  DATA_EEPROM_FixedTimeProgramCmd() can be called before 
    830            *         this function to configure the Fixed Time Programming
    831            * @param  Address: specifies the address to be written.
    832            * @param  Data: specifies the data to be written.
    833            * @retval FLASH Status: The returned value can be:
    834            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    835            */
    836          FLASH_Status DATA_EEPROM_ProgramHalfWord(uint32_t Address, uint16_t Data)
    837          {
    838            FLASH_Status status = FLASH_COMPLETE;
    839          #if !defined (STM32L1XX_HD) && !defined (STM32L1XX_MDP) && !defined (STM32L1XX_XL)
    840            uint32_t tmp = 0, tmpaddr = 0;
    841          #endif
    842            
    843            /* Check the parameters */
    844            assert_param(IS_FLASH_DATA_ADDRESS(Address));
    845          
    846            /* Wait for last operation to be completed */
    847            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    848            
    849            if(status == FLASH_COMPLETE)
    850            {
    851          #if !defined (STM32L1XX_HD) && !defined (STM32L1XX_MDP) && !defined (STM32L1XX_XL)
    852              if(Data != (uint16_t)0x0000)
    853              {
    854                *(__IO uint16_t *)Address = Data;
    855             
    856                /* Wait for last operation to be completed */
    857                status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    858              }
    859              else
    860              {
    861                if((Address & 0x3) != 0x3)
    862                {
    863                  tmpaddr = Address & 0xFFFFFFFC;
    864                  tmp = * (__IO uint32_t *) tmpaddr;
    865                  tmpaddr = 0xFFFF << ((uint32_t) (0x8 * (Address & 0x3)));
    866                  tmp &= ~tmpaddr;          
    867                  status = DATA_EEPROM_EraseWord(Address & 0xFFFFFFFC);
    868                  status = DATA_EEPROM_FastProgramWord((Address & 0xFFFFFFFC), tmp);
    869                }
    870                else
    871                {
    872                  DATA_EEPROM_FastProgramByte(Address, 0x00);
    873                  DATA_EEPROM_FastProgramByte(Address + 1, 0x00);
    874                }
    875              }
    876          #elif defined (STM32L1XX_HD) || defined (STM32L1XX_MDP) || defined (STM32L1XX_XL)
    877              *(__IO uint16_t *)Address = Data;
    878             
    879              /* Wait for last operation to be completed */
    880              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    881          #endif
    882            }
    883            /* Return the Write Status */
    884            return status;
    885          }
    886          
    887          /**
    888            * @brief  Programs a word at a specified address in data memory without erase.
    889            * @note   To correctly run this function, the DATA_EEPROM_Unlock() function
    890            *         must be called before.
    891            *         Call the DATA_EEPROM_Lock() to disable the data EEPROM access
    892            *         and Flash program erase control register access(recommended to protect 
    893            *         the DATA_EEPROM against possible unwanted operation).
    894            * @note   The function  DATA_EEPROM_FixedTimeProgramCmd() can be called before 
    895            *         this function to configure the Fixed Time Programming.
    896            * @param  Address: specifies the address to be written.
    897            * @param  Data: specifies the data to be written.
    898            * @retval FLASH Status: The returned value can be:
    899            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or  FLASH_TIMEOUT. 
    900            */
    901          FLASH_Status DATA_EEPROM_ProgramWord(uint32_t Address, uint32_t Data)
    902          {
    903            FLASH_Status status = FLASH_COMPLETE;
    904            
    905            /* Check the parameters */
    906            assert_param(IS_FLASH_DATA_ADDRESS(Address));
    907            
    908            /* Wait for last operation to be completed */
    909            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    910            
    911            if(status == FLASH_COMPLETE)
    912            {
    913              *(__IO uint32_t *)Address = Data;
    914          
    915              /* Wait for last operation to be completed */
    916              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
    917            }
    918            /* Return the Write Status */
    919            return status;
    920          }
    921          
    922          /**
    923            * @}
    924            */
    925          
    926          /** @defgroup FLASH_Group4 Option Bytes Programming functions
    927           *  @brief   Option Bytes Programming functions 
    928           *
    929          @verbatim   
    930            ==============================================================================
    931                          ##### Option Bytes Programming functions ##### 
    932            ==============================================================================  
    933          
    934              [..] The FLASH_Option Bytes Programming_functions, includes the following functions:
    935              (+) void FLASH_OB_Unlock(void);
    936              (+) void FLASH_OB_Lock(void);
    937              (+) void FLASH_OB_Launch(void);
    938              (+) FLASH_Status FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState);
    939              (+) FLASH_Status FLASH_OB_WRP1Config(uint32_t OB_WRP1, FunctionalState NewState);
    940              (+) FLASH_Status FLASH_OB_WRP2Config(uint32_t OB_WRP2, FunctionalState NewState);   
    941              (+) FLASH_Status FLASH_OB_RDPConfig(uint8_t OB_RDP);
    942              (+) FLASH_Status FLASH_OB_PCROPConfig(uint32_t OB_WRP, FunctionalState NewState);
    943              (+) FLASH_Status FLASH_OB_PCROP1Config(uint32_t OB_WRP1, FunctionalState NewState);
    944              (+) FLASH_Status FLASH_OB_PCROPSelectionConfig(uint16_t OB_PcROP);
    945              (+) FLASH_Status FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY);
    946              (+) FLASH_Status FLASH_OB_BORConfig(uint8_t OB_BOR);
    947              (+) uint8_t FLASH_OB_GetUser(void);
    948              (+) uint32_t FLASH_OB_GetWRP(void);
    949              (+) uint32_t FLASH_OB_GetWRP1(void);
    950              (+) uint32_t FLASH_OB_GetWRP2(void);     
    951              (+) FlagStatus FLASH_OB_GetRDP(void);
    952              (+) FlagStatus FLASH_OB_GetSPRMOD(void);    
    953              (+) uint8_t FLASH_OB_GetBOR(void);
    954              (+) FLASH_Status FLASH_OB_BootConfig(uint16_t OB_BOOT);
    955             
    956              [..] Any operation of erase or program should follow these steps:
    957              (#) Call the FLASH_OB_Unlock() function to enable the Flash option control 
    958                  register access.
    959              (#) Call one or several functions to program the desired option bytes.
    960                  (++) void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState) => to Enable/Disable 
    961                       the desired sector write protection.
    962                  (++) void FLASH_OB_RDPConfig(uint8_t OB_RDP) => to set the desired read Protection Level.
    963                  (++) void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY) => to configure 
    964                       the user option Bytes: IWDG, STOP and the Standby.
    965                  (++) void FLASH_OB_BORConfig(uint8_t OB_BOR) => to Set the BOR level.
    966              (#) Once all needed option bytes to be programmed are correctly written, call the
    967                  FLASH_OB_Launch(void) function to launch the Option Bytes programming process.
    968              (#) Call the FLASH_OB_Lock() to disable the Flash option control register access (recommended
    969                  to protect the option Bytes against possible unwanted operations).
    970          
    971              [..] Proprietary code Read Out Protection (PcROP):    
    972              (#) The PcROP sector is selected by using the same option bytes as the Write
    973                  protection (nWRPi bits). As a result, these 2 options are exclusive each other.
    974              (#) In order to activate the PcROP (change the function of the nWRPi option bits), 
    975                  the SPRMOD option bit must be activated.
    976              (#) The active value of nWRPi bits is inverted when PCROP mode is active, this
    977                  means: if SPRMOD = 1 and nWRPi = 1 (default value), then the user sector "i"
    978                  is read/write protected.
    979              (#) To activate PCROP mode for Flash sector(s), you need to follow the sequence below:
    980                  (++) For sector(s) within the first 128KB of the Flash, use this function 
    981                       FLASH_OB_PCROPConfig(OB_WRP_Pagesxxx, ENABLE)
    982                  (++) For sector(s) within the second 128KB of the Flash, use this function 
    983                       FLASH_OB_PCROP1Config(OB_WRP_Pagesxxx, ENABLE)             
    984                  (++) Activate the PCROP mode using FLASH_OB_PCROPSelectionConfig(OB_PcROP_Enable) function
    985              (#) PcROP is available only in STM32L1XX_MDP devices
    986          
    987          @endverbatim
    988            * @{
    989            */
    990          
    991          /**
    992            * @brief  Unlocks the option bytes block access.
    993            * @param  None
    994            * @retval None
    995            */
    996          void FLASH_OB_Unlock(void)
    997          {
    998            if((FLASH->PECR & FLASH_PECR_OPTLOCK) != RESET)
    999            {
   1000              /* Unlocking the data memory and FLASH_PECR register access */
   1001              DATA_EEPROM_Unlock();
   1002            
   1003              /* Unlocking the option bytes block access */
   1004              FLASH->OPTKEYR = FLASH_OPTKEY1;
   1005              FLASH->OPTKEYR = FLASH_OPTKEY2;
   1006            }
   1007          }
   1008          
   1009          /**
   1010            * @brief  Locks the option bytes block access.
   1011            * @param  None
   1012            * @retval None
   1013            */
   1014          void FLASH_OB_Lock(void)
   1015          {
   1016            /* Set the OPTLOCK Bit to lock the option bytes block access */
   1017            FLASH->PECR |= FLASH_PECR_OPTLOCK;
   1018          }
   1019          
   1020          /**
   1021            * @brief  Launch the option byte loading.
   1022            * @param  None
   1023            * @retval None
   1024            */
   1025          void FLASH_OB_Launch(void)
   1026          {
   1027            /* Set the OBL_Launch bit to lauch the option byte loading */
   1028            FLASH->PECR |= FLASH_PECR_OBL_LAUNCH;
   1029          }
   1030          
   1031          /**
   1032            * @brief  Write protects the desired pages of the first 128KB of the Flash.
   1033            * @param  OB_WRP: specifies the address of the pages to be write protected.
   1034            *   This parameter can be:
   1035            *     @arg  value between OB_WRP_Pages0to15 and OB_WRP_Pages496to511
   1036            *     @arg  OB_WRP_AllPages
   1037            * @param  NewState: new state of the specified FLASH Pages Wtite protection.
   1038            *   This parameter can be: ENABLE or DISABLE.
   1039            * @retval FLASH Status: The returned value can be: 
   1040            *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1041            */
   1042          FLASH_Status FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
   1043          {
   1044            uint32_t WRP01_Data = 0, WRP23_Data = 0;
   1045            
   1046            FLASH_Status status = FLASH_COMPLETE;
   1047            uint32_t tmp1 = 0, tmp2 = 0;
   1048            
   1049            /* Check the parameters */
   1050            assert_param(IS_OB_WRP(OB_WRP));
   1051            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1052               
   1053            /* Wait for last operation to be completed */
   1054            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1055           
   1056            if(status == FLASH_COMPLETE)
   1057            {
   1058              if (NewState != DISABLE)
   1059              {
   1060                WRP01_Data = (uint16_t)(((OB_WRP & WRP01_MASK) | OB->WRP01));
   1061                WRP23_Data = (uint16_t)((((OB_WRP & WRP23_MASK)>>16 | OB->WRP23))); 
   1062                tmp1 = (uint32_t)(~(WRP01_Data) << 16)|(WRP01_Data);
   1063                OB->WRP01 = tmp1;
   1064                
   1065                tmp2 = (uint32_t)(~(WRP23_Data) << 16)|(WRP23_Data);
   1066                OB->WRP23 = tmp2;      
   1067              }             
   1068              
   1069              else
   1070              {
   1071                WRP01_Data = (uint16_t)(~OB_WRP & (WRP01_MASK & OB->WRP01));
   1072                WRP23_Data = (uint16_t)((((~OB_WRP & WRP23_MASK)>>16 & OB->WRP23))); 
   1073          
   1074                tmp1 = (uint32_t)((~WRP01_Data) << 16)|(WRP01_Data);
   1075                OB->WRP01 = tmp1;
   1076                
   1077                tmp2 = (uint32_t)((~WRP23_Data) << 16)|(WRP23_Data);
   1078                OB->WRP23 = tmp2;
   1079              }
   1080              /* Wait for last operation to be completed */
   1081              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1082            }
   1083          
   1084            /* Return the write protection operation Status */
   1085            return status;      
   1086          }
   1087          
   1088          /**
   1089            * @brief  Write protects the desired pages of the second 128KB of the Flash.
   1090            * @note   This function can be used only for STM32L1XX_HD, STM32L1XX_MDP and  
   1091            *         STM32L1XX_XL devices.
   1092            * @param  OB_WRP1: specifies the address of the pages to be write protected.
   1093            *   This parameter can be:
   1094            *     @arg  value between OB_WRP_Pages512to527 and OB_WRP_Pages1008to1023
   1095            *     @arg OB_WRP_AllPages
   1096            * @param  NewState: new state of the specified FLASH Pages Wtite protection.
   1097            *         This parameter can be: ENABLE or DISABLE.
   1098            * @retval FLASH Status: The returned value can be: 
   1099            *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1100            */
   1101          FLASH_Status FLASH_OB_WRP1Config(uint32_t OB_WRP1, FunctionalState NewState)
   1102          {
   1103            uint32_t WRP45_Data = 0, WRP67_Data = 0;
   1104            
   1105            FLASH_Status status = FLASH_COMPLETE;
   1106            uint32_t tmp1 = 0, tmp2 = 0;
   1107            
   1108            /* Check the parameters */
   1109            assert_param(IS_OB_WRP(OB_WRP1));
   1110            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1111               
   1112            /* Wait for last operation to be completed */
   1113            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1114           
   1115            if(status == FLASH_COMPLETE)
   1116            {
   1117              if (NewState != DISABLE)
   1118              {
   1119                WRP45_Data = (uint16_t)(((OB_WRP1 & WRP45_MASK) | OB->WRP45));
   1120                WRP67_Data = (uint16_t)((((OB_WRP1 & WRP67_MASK)>>16 | OB->WRP67))); 
   1121                tmp1 = (uint32_t)(~(WRP45_Data) << 16)|(WRP45_Data);
   1122                OB->WRP45 = tmp1;
   1123                
   1124                tmp2 = (uint32_t)(~(WRP67_Data) << 16)|(WRP67_Data);
   1125                OB->WRP67 = tmp2;      
   1126              }             
   1127              
   1128              else
   1129              {
   1130                WRP45_Data = (uint16_t)(~OB_WRP1 & (WRP45_MASK & OB->WRP45));
   1131                WRP67_Data = (uint16_t)((((~OB_WRP1 & WRP67_MASK)>>16 & OB->WRP67))); 
   1132          
   1133                tmp1 = (uint32_t)((~WRP45_Data) << 16)|(WRP45_Data);
   1134                OB->WRP45 = tmp1;
   1135                
   1136                tmp2 = (uint32_t)((~WRP67_Data) << 16)|(WRP67_Data);
   1137                OB->WRP67 = tmp2;
   1138              }
   1139              /* Wait for last operation to be completed */
   1140              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1141            }
   1142          
   1143            /* Return the write protection operation Status */
   1144            return status;      
   1145          }
   1146          
   1147          /**
   1148            * @brief  Write protects the desired pages of the third 128KB of the Flash.
   1149            * @note   This function can be used only for STM32L1XX_HD and STM32L1XX_XL devices.
   1150            * @param  OB_WRP2: specifies the address of the pages to be write protected.
   1151            *   This parameter can be:
   1152            *     @arg  value between OB_WRP_Pages1024to1039 and OB_WRP_Pages1520to1535
   1153            *     @arg OB_WRP_AllPages
   1154            * @param  NewState: new state of the specified FLASH Pages Wtite protection.
   1155            *         This parameter can be: ENABLE or DISABLE.
   1156            * @retval FLASH Status: The returned value can be: 
   1157            *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1158            */
   1159          FLASH_Status FLASH_OB_WRP2Config(uint32_t OB_WRP2, FunctionalState NewState)
   1160          {
   1161            uint32_t WRP89_Data = 0, WRP1011_Data = 0;
   1162            
   1163            FLASH_Status status = FLASH_COMPLETE;
   1164            uint32_t tmp1 = 0, tmp2 = 0;
   1165            
   1166            /* Check the parameters */
   1167            assert_param(IS_OB_WRP(OB_WRP2));
   1168            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1169               
   1170            /* Wait for last operation to be completed */
   1171            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1172           
   1173            if(status == FLASH_COMPLETE)
   1174            {
   1175              if (NewState != DISABLE)
   1176              {
   1177                WRP89_Data = (uint16_t)(((OB_WRP2 & WRP89_MASK) | OB->WRP89));
   1178                WRP1011_Data = (uint16_t)((((OB_WRP2 & WRP1011_MASK)>>16 | OB->WRP1011))); 
   1179                tmp1 = (uint32_t)(~(WRP89_Data) << 16)|(WRP89_Data);
   1180                OB->WRP89 = tmp1;
   1181                
   1182                tmp2 = (uint32_t)(~(WRP1011_Data) << 16)|(WRP1011_Data);
   1183                OB->WRP1011 = tmp2;      
   1184              }             
   1185              
   1186              else
   1187              {
   1188                WRP89_Data = (uint16_t)(~OB_WRP2 & (WRP89_MASK & OB->WRP89));
   1189                WRP1011_Data = (uint16_t)((((~OB_WRP2 & WRP1011_MASK)>>16 & OB->WRP1011))); 
   1190          
   1191                tmp1 = (uint32_t)((~WRP89_Data) << 16)|(WRP89_Data);
   1192                OB->WRP89 = tmp1;
   1193                
   1194                tmp2 = (uint32_t)((~WRP1011_Data) << 16)|(WRP1011_Data);
   1195                OB->WRP1011 = tmp2;
   1196              }
   1197              /* Wait for last operation to be completed */
   1198              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1199            }
   1200          
   1201            /* Return the write protection operation Status */
   1202            return status;      
   1203          }
   1204          
   1205          /**
   1206            * @brief  Enables or disables the read out protection.
   1207            * @note   To correctly run this function, the FLASH_OB_Unlock() function
   1208            *         must be called before.
   1209            * @param  FLASH_ReadProtection_Level: specifies the read protection level. 
   1210            *   This parameter can be:
   1211            *     @arg OB_RDP_Level_0: No protection
   1212            *     @arg OB_RDP_Level_1: Read protection of the memory
   1213            *     @arg OB_RDP_Level_2: Chip protection
   1214            * 
   1215            *  !!!Warning!!! When enabling OB_RDP_Level_2 it's no more possible to go back to level 1 or 0
   1216            *   
   1217            * @retval FLASH Status: The returned value can be: 
   1218            *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1219            */
   1220          FLASH_Status FLASH_OB_RDPConfig(uint8_t OB_RDP)
   1221          {
   1222            FLASH_Status status = FLASH_COMPLETE;
   1223            uint8_t tmp1 = 0;
   1224            uint32_t tmp2 = 0;
   1225            
   1226            /* Check the parameters */
   1227            assert_param(IS_OB_RDP(OB_RDP));
   1228            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1229            
   1230            /* calculate the option byte to write */
   1231            tmp1 = (uint8_t)(~(OB_RDP ));
   1232            tmp2 = (uint32_t)(((uint32_t)((uint32_t)(tmp1) << 16)) | ((uint32_t)OB_RDP));
   1233            
   1234            if(status == FLASH_COMPLETE)
   1235            {         
   1236             /* program read protection level */
   1237              OB->RDP = tmp2;
   1238            }
   1239            
   1240            /* Wait for last operation to be completed */
   1241              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1242               
   1243            /* Return the Read protection operation Status */
   1244            return status;            
   1245          }
   1246          
   1247          /**
   1248            * @brief  Enables or disables the read/write protection (PCROP) of the desired 
   1249            *         sectors, for the first 128KB of the Flash.
   1250            * @note   This function can be used only for STM32L1XX_MDP devices
   1251            * @param  OB_WRP: specifies the address of the pages to be write protected.
   1252            *   This parameter can be:
   1253            *     @arg  value between OB_WRP_Pages0to15 and OB_WRP_Pages496to511
   1254            *     @arg  OB_WRP_AllPages
   1255            * @param  NewState: new state of the specified FLASH Pages Write protection.
   1256            *   This parameter can be: ENABLE or DISABLE.
   1257            * @retval FLASH Status: The returned value can be: 
   1258            *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1259            */
   1260          FLASH_Status FLASH_OB_PCROPConfig(uint32_t OB_WRP, FunctionalState NewState)
   1261          {
   1262            uint32_t WRP01_Data = 0, WRP23_Data = 0;
   1263            
   1264            FLASH_Status status = FLASH_COMPLETE;
   1265            uint32_t tmp1 = 0, tmp2 = 0;
   1266            
   1267            /* Check the parameters */
   1268            assert_param(IS_OB_WRP(OB_WRP));
   1269            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1270               
   1271            /* Wait for last operation to be completed */
   1272            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1273           
   1274            if(status == FLASH_COMPLETE)
   1275            {
   1276              if (NewState != DISABLE)
   1277              {
   1278                WRP01_Data = (uint16_t)(~OB_WRP & (WRP01_MASK & OB->WRP01));
   1279                WRP23_Data = (uint16_t)((((~OB_WRP & WRP23_MASK)>>16 & OB->WRP23))); 
   1280          
   1281                tmp1 = (uint32_t)((~WRP01_Data) << 16)|(WRP01_Data);
   1282                OB->WRP01 = tmp1;
   1283                
   1284                tmp2 = (uint32_t)((~WRP23_Data) << 16)|(WRP23_Data);
   1285                OB->WRP23 = tmp2;
   1286              
   1287              }             
   1288              
   1289              else
   1290              {
   1291                WRP01_Data = (uint16_t)((OB_WRP & WRP01_MASK) | OB->WRP01);
   1292                WRP23_Data = (uint16_t)(((OB_WRP & WRP23_MASK) >> 16) | OB->WRP23); 
   1293               
   1294                tmp1 = (uint32_t)(~(WRP01_Data) << 16)|(WRP01_Data);
   1295                OB->WRP01 = tmp1;
   1296                
   1297                tmp2 = (uint32_t)(~(WRP23_Data) << 16)|(WRP23_Data);
   1298                OB->WRP23 = tmp2;  
   1299          
   1300              }
   1301              /* Wait for last operation to be completed */
   1302              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1303            }
   1304          
   1305            /* Return the write protection operation Status */
   1306            return status;      
   1307          }
   1308          
   1309          /**
   1310            * @brief  Enables or disables the read/write protection (PCROP) of the desired 
   1311            *         sectors, for the second 128KB of the Flash.
   1312            * @note   This function can be used only for STM32L1XX_MDP devices
   1313            * @param  OB_WRP1: specifies the address of the pages to be write protected.
   1314            *   This parameter can be:
   1315            *     @arg  value between OB_WRP_Pages512to527 and OB_WRP_Pages1008to1023
   1316            *     @arg OB_WRP_AllPages
   1317            * @param  NewState: new state of the specified FLASH Pages Write protection.
   1318            *         This parameter can be: ENABLE or DISABLE.
   1319            * @retval FLASH Status: The returned value can be: 
   1320            *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1321            */
   1322          FLASH_Status FLASH_OB_PCROP1Config(uint32_t OB_WRP1, FunctionalState NewState)
   1323          {
   1324            uint32_t WRP45_Data = 0, WRP67_Data = 0;
   1325            
   1326            FLASH_Status status = FLASH_COMPLETE;
   1327            uint32_t tmp1 = 0, tmp2 = 0;
   1328            
   1329            /* Check the parameters */
   1330            assert_param(IS_OB_WRP(OB_WRP1));
   1331            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1332               
   1333            /* Wait for last operation to be completed */
   1334            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1335           
   1336            if(status == FLASH_COMPLETE)
   1337            {
   1338              if (NewState != DISABLE)
   1339              {
   1340                WRP45_Data = (uint16_t)(~OB_WRP1 & (WRP45_MASK & OB->WRP45));
   1341                WRP67_Data = (uint16_t)((((~OB_WRP1 & WRP67_MASK)>>16 & OB->WRP67))); 
   1342          
   1343                tmp1 = (uint32_t)((~WRP45_Data) << 16)|(WRP45_Data);
   1344                OB->WRP45 = tmp1;
   1345                
   1346                tmp2 = (uint32_t)((~WRP67_Data) << 16)|(WRP67_Data);
   1347                OB->WRP67 = tmp2;
   1348              }             
   1349              else
   1350              {
   1351                WRP45_Data = (uint16_t)((OB_WRP1 & WRP45_MASK) | OB->WRP45);
   1352                WRP67_Data = (uint16_t)(((OB_WRP1 & WRP67_MASK)>>16) | OB->WRP67); 
   1353                tmp1 = (uint32_t)(~(WRP45_Data) << 16)|(WRP45_Data);
   1354                OB->WRP45 = tmp1;
   1355                
   1356                tmp2 = (uint32_t)(~(WRP67_Data) << 16)|(WRP67_Data);
   1357                OB->WRP67 = tmp2;   
   1358              }
   1359              /* Wait for last operation to be completed */
   1360              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1361            }
   1362          
   1363            /* Return the write protection operation Status */
   1364            return status;      
   1365          }
   1366          
   1367          /**
   1368            * @brief  Select the Protection Mode (SPRMOD).
   1369            * @note   This function can be used only for STM32L1XX_MDP devices
   1370            * @note   Once SPRMOD bit is active, unprotection of a protected sector is not possible 
   1371            * @note   Read a protected sector will set RDERR Flag and write a protected sector will set WRPERR Flag
   1372            * @param  OB_PcROP: Select the Protection Mode of nWPRi bits. 
   1373            *   This parameter can be:
   1374            *     @arg OB_PcROP_Enable: nWRPi control the  read&write protection (PcROP) of respective user sectors.
   1375            *     @arg OB_PcROP_Disable: nWRPi control the write protection of respective user sectors.
   1376            * @retval FLASH Status: The returned value can be: 
   1377            *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1378            */
   1379          FLASH_Status FLASH_OB_PCROPSelectionConfig(uint16_t OB_PcROP)
   1380          {
   1381            FLASH_Status status = FLASH_COMPLETE;
   1382            uint16_t tmp1 = 0;
   1383            uint32_t tmp2 = 0;
   1384            uint8_t optiontmp = 0;
   1385            uint16_t optiontmp2 = 0;
   1386            
   1387            /* Check the parameters */
   1388            assert_param(IS_OB_PCROP_SELECT(OB_PcROP));
   1389            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1390            
   1391            /* Mask RDP Byte */
   1392            optiontmp =  (uint8_t)(*(__IO uint8_t *)(OB_BASE)); 
   1393            
   1394            /* Update Option Byte */
   1395            optiontmp2 = (uint16_t)(OB_PcROP | optiontmp); 
   1396            
   1397            
   1398            /* calculate the option byte to write */
   1399            tmp1 = (uint16_t)(~(optiontmp2 ));
   1400            tmp2 = (uint32_t)(((uint32_t)((uint32_t)(tmp1) << 16)) | ((uint32_t)optiontmp2));
   1401            
   1402            if(status == FLASH_COMPLETE)
   1403            {         
   1404              /* program PCRop */
   1405              OB->RDP = tmp2;
   1406            }
   1407            
   1408            /* Wait for last operation to be completed */
   1409            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1410            
   1411            /* Return the Read protection operation Status */
   1412            return status;            
   1413          }
   1414          
   1415          /**
   1416            * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.
   1417            * @param  OB_IWDG: Selects the WDG mode.
   1418            *   This parameter can be one of the following values:
   1419            *     @arg OB_IWDG_SW: Software WDG selected
   1420            *     @arg OB_IWDG_HW: Hardware WDG selected
   1421            * @param  OB_STOP: Reset event when entering STOP mode.
   1422            *   This parameter can be one of the following values:
   1423            *     @arg OB_STOP_NoRST: No reset generated when entering in STOP
   1424            *     @arg OB_STOP_RST: Reset generated when entering in STOP
   1425            * @param  OB_STDBY: Reset event when entering Standby mode.
   1426            *   This parameter can be one of the following values:
   1427            *     @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
   1428            *     @arg OB_STDBY_RST: Reset generated when entering in STANDBY
   1429            * @retval FLASH Status: The returned value can be: 
   1430            *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1431            */
   1432          FLASH_Status FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
   1433          {
   1434            FLASH_Status status = FLASH_COMPLETE; 
   1435            uint32_t tmp = 0, tmp1 = 0;
   1436          
   1437            /* Check the parameters */
   1438            assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
   1439            assert_param(IS_OB_STOP_SOURCE(OB_STOP));
   1440            assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
   1441          
   1442            /* Get the User Option byte register */
   1443            tmp1 = (FLASH->OBR & 0x000F0000) >> 16;
   1444              
   1445            /* Calculate the user option byte to write */ 
   1446            tmp = (uint32_t)(((uint32_t)~((uint32_t)((uint32_t)(OB_IWDG) | (uint32_t)(OB_STOP) | (uint32_t)(OB_STDBY) | tmp1))) << ((uint32_t)0x10));
   1447            tmp |= ((uint32_t)(OB_IWDG) | ((uint32_t)OB_STOP) | (uint32_t)(OB_STDBY) | tmp1);
   1448            
   1449            /* Wait for last operation to be completed */
   1450            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1451            
   1452            if(status == FLASH_COMPLETE)
   1453            {  
   1454              /* Write the User Option Byte */              
   1455              OB->USER = tmp; 
   1456            }
   1457            
   1458            /* Wait for last operation to be completed */
   1459              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1460                 
   1461            /* Return the Option Byte program Status */
   1462            return status;
   1463          }
   1464          
   1465          /**
   1466            * @brief  Programs the FLASH brownout reset threshold level Option Byte.
   1467            * @param  OB_BOR: Selects the brownout reset threshold level.
   1468            *   This parameter can be one of the following values:
   1469            *     @arg OB_BOR_OFF: BOR is disabled at power down, the reset is asserted when the VDD 
   1470            *                      power supply reaches the PDR(Power Down Reset) threshold (1.5V)
   1471            *     @arg OB_BOR_LEVEL1: BOR Reset threshold levels for 1.7V - 1.8V VDD power supply
   1472            *     @arg OB_BOR_LEVEL2: BOR Reset threshold levels for 1.9V - 2.0V VDD power supply
   1473            *     @arg OB_BOR_LEVEL3: BOR Reset threshold levels for 2.3V - 2.4V VDD power supply
   1474            *     @arg OB_BOR_LEVEL4: BOR Reset threshold levels for 2.55V - 2.65V VDD power supply
   1475            *     @arg OB_BOR_LEVEL5: BOR Reset threshold levels for 2.8V - 2.9V VDD power supply
   1476            * @retval FLASH Status: The returned value can be: 
   1477            * FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1478            */
   1479          FLASH_Status FLASH_OB_BORConfig(uint8_t OB_BOR)
   1480          {
   1481            FLASH_Status status = FLASH_COMPLETE;
   1482            uint32_t tmp = 0, tmp1 = 0;
   1483          
   1484            /* Check the parameters */
   1485            assert_param(IS_OB_BOR_LEVEL(OB_BOR));
   1486          
   1487            /* Get the User Option byte register */
   1488            tmp1 = (FLASH->OBR & 0x00F00000) >> 16;
   1489               
   1490            /* Calculate the option byte to write */
   1491            tmp = (uint32_t)~(OB_BOR | tmp1)<<16;
   1492            tmp |= (OB_BOR | tmp1);
   1493              
   1494            /* Wait for last operation to be completed */
   1495            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1496            
   1497            if(status == FLASH_COMPLETE)
   1498            {  
   1499              /* Write the BOR Option Byte */            
   1500              OB->USER = tmp; 
   1501            }
   1502            
   1503            /* Wait for last operation to be completed */
   1504            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1505                  
   1506            /* Return the Option Byte program Status */
   1507            return status;
   1508          }
   1509          
   1510          /**
   1511            * @brief  Configures to boot from Bank1 or Bank2.
   1512            * @note   This function can be used only for STM32L1XX_HD and STM32L1XX_XL devices.
   1513            * @param  OB_BOOT: select the FLASH Bank to boot from.
   1514            *   This parameter can be one of the following values:
   1515            *     @arg OB_BOOT_BANK2: At startup, if boot pins are set in boot from user Flash
   1516            *        position and this parameter is selected the device will boot from Bank2 or Bank1,
   1517            *        depending on the activation of the bank. The active banks are checked in
   1518            *        the following order: Bank2, followed by Bank1.
   1519            *        The active bank is recognized by the value programmed at the base address
   1520            *        of the respective bank (corresponding to the initial stack pointer value
   1521            *        in the interrupt vector table).
   1522            *     @arg OB_BOOT_BANK1: At startup, if boot pins are set in boot from user Flash
   1523            *        position and this parameter is selected the device will boot from Bank1(Default).
   1524            *        For more information, please refer to AN2606 from www.st.com. 
   1525            * @retval FLASH Status: The returned value can be: 
   1526            *         FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1527            */
   1528          FLASH_Status FLASH_OB_BootConfig(uint8_t OB_BOOT)
   1529          {
   1530            FLASH_Status status = FLASH_COMPLETE; 
   1531            uint32_t tmp = 0, tmp1 = 0;
   1532          
   1533            /* Check the parameters */
   1534            assert_param(IS_OB_BOOT_BANK(OB_BOOT));
   1535          
   1536            /* Get the User Option byte register */
   1537            tmp1 = (FLASH->OBR & 0x007F0000) >> 16;
   1538               
   1539            /* Calculate the option byte to write */
   1540            tmp = (uint32_t)~(OB_BOOT | tmp1)<<16;
   1541            tmp |= (OB_BOOT | tmp1);
   1542              
   1543            /* Wait for last operation to be completed */
   1544            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1545            
   1546            if(status == FLASH_COMPLETE)
   1547            {  
   1548              /* Write the BOOT Option Byte */            
   1549              OB->USER = tmp; 
   1550            }
   1551            
   1552            /* Wait for last operation to be completed */
   1553            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   1554                 
   1555            /* Return the Option Byte program Status */
   1556            return status;
   1557          }
   1558          
   1559          /**
   1560            * @brief  Returns the FLASH User Option Bytes values.
   1561            * @param  None
   1562            * @retval The FLASH User Option Bytes.
   1563            */
   1564          uint8_t FLASH_OB_GetUser(void)
   1565          {
   1566            /* Return the User Option Byte */
   1567            return (uint8_t)(FLASH->OBR >> 20);
   1568          }
   1569          
   1570          /**
   1571            * @brief  Returns the FLASH Write Protection Option Bytes value.
   1572            * @param  None
   1573            * @retval The FLASH Write Protection Option Bytes value.
   1574            */
   1575          uint32_t FLASH_OB_GetWRP(void)
   1576          {
   1577            /* Return the FLASH write protection Register value */
   1578            return (uint32_t)(FLASH->WRPR);
   1579          }
   1580          
   1581          /**
   1582            * @brief  Returns the FLASH Write Protection Option Bytes value.
   1583            * @note   This function can be used only for STM32L1XX_HD, STM32L1XX_MDP and  
   1584            *         STM32L1XX_XL devices.
   1585            * @param  None
   1586            * @retval The FLASH Write Protection Option Bytes value.
   1587            */
   1588          uint32_t FLASH_OB_GetWRP1(void)
   1589          {
   1590            /* Return the FLASH write protection Register value */
   1591            return (uint32_t)(FLASH->WRPR1);
   1592          }
   1593          
   1594          /**
   1595            * @brief  Returns the FLASH Write Protection Option Bytes value.
   1596            * @note   This function can be used only for STM32L1XX_HD and STM32L1XX_XL devices.
   1597            * @param  None
   1598            * @retval The FLASH Write Protection Option Bytes value.
   1599            */
   1600          uint32_t FLASH_OB_GetWRP2(void)
   1601          {
   1602            /* Return the FLASH write protection Register value */
   1603            return (uint32_t)(FLASH->WRPR2);
   1604          }
   1605          
   1606          /**
   1607            * @brief  Checks whether the FLASH Read out Protection Status is set or not.
   1608            * @param  None
   1609            * @retval FLASH ReadOut Protection Status(SET or RESET).
   1610            */
   1611          FlagStatus FLASH_OB_GetRDP(void)
   1612          {
   1613            FlagStatus readstatus = RESET;
   1614            
   1615            if ((uint8_t)(FLASH->OBR) != (uint8_t)OB_RDP_Level_0)
   1616            {
   1617              readstatus = SET;
   1618            }
   1619            else
   1620            {
   1621              readstatus = RESET;
   1622            }
   1623            return readstatus;
   1624          }
   1625          
   1626          /**
   1627            * @brief  Returns the SPRMOD Status.
   1628            * @note   This function can be used only for STM32L1XX_MDP devices  
   1629            * @param  None
   1630            * @retval The SPRMOD Status.
   1631            */
   1632          FlagStatus FLASH_OB_GetSPRMOD(void)
   1633          {
   1634            FlagStatus readstatus = RESET;
   1635            uint16_t tmp = 0;
   1636            
   1637            /* Return the SPRMOD value */
   1638            tmp = (uint16_t)(FLASH->OBR & (uint16_t)(0x0100));
   1639            
   1640            if (tmp != (uint16_t)0x0000)
   1641            {
   1642              readstatus = SET;
   1643            }
   1644            else
   1645            {
   1646              readstatus = RESET;
   1647            }
   1648            return readstatus;
   1649          }
   1650          
   1651          /**
   1652            * @brief  Returns the FLASH BOR level.
   1653            * @param  None
   1654            * @retval The FLASH User Option Bytes.
   1655            */
   1656          uint8_t FLASH_OB_GetBOR(void)
   1657          {
   1658            /* Return the BOR level */
   1659            return (uint8_t)((FLASH->OBR & (uint32_t)0x000F0000) >> 16);
   1660          }
   1661          
   1662          /**
   1663            * @}
   1664            */
   1665          
   1666          /** @defgroup FLASH_Group5 Interrupts and flags management functions
   1667           *  @brief   Interrupts and flags management functions
   1668           *
   1669          @verbatim   
   1670            ==============================================================================
   1671                        ##### Interrupts and flags management functions #####
   1672            ==============================================================================    
   1673          
   1674          @endverbatim
   1675            * @{
   1676            */
   1677          
   1678          /**
   1679            * @brief  Enables or disables the specified FLASH interrupts.
   1680            * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or 
   1681            *         disabled.
   1682            *   This parameter can be any combination of the following values:
   1683            *     @arg FLASH_IT_EOP: FLASH end of programming Interrupt
   1684            *     @arg FLASH_IT_ERR: FLASH Error Interrupt
   1685            * @retval None 
   1686            */
   1687          void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
   1688          {
   1689            /* Check the parameters */
   1690            assert_param(IS_FLASH_IT(FLASH_IT)); 
   1691            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1692            
   1693            if(NewState != DISABLE)
   1694            {
   1695              /* Enable the interrupt sources */
   1696              FLASH->PECR |= FLASH_IT;
   1697            }
   1698            else
   1699            {
   1700              /* Disable the interrupt sources */
   1701              FLASH->PECR &= ~(uint32_t)FLASH_IT;
   1702            }
   1703          }
   1704          
   1705          /**
   1706            * @brief  Checks whether the specified FLASH flag is set or not.
   1707            * @param  FLASH_FLAG: specifies the FLASH flag to check.
   1708            *   This parameter can be one of the following values:
   1709            *     @arg FLASH_FLAG_BSY: FLASH write/erase operations in progress flag 
   1710            *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag
   1711            *     @arg FLASH_FLAG_READY: FLASH Ready flag after low power mode
   1712            *     @arg FLASH_FLAG_ENDHV: FLASH End of high voltage flag
   1713            *     @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
   1714            *     @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag
   1715            *     @arg FLASH_FLAG_SIZERR: FLASH size error flag
   1716            *     @arg FLASH_FLAG_OPTVERR: FLASH Option validity error flag
   1717            *     @arg FLASH_FLAG_OPTVERRUSR: FLASH Option User validity error flag
   1718            *     @arg FLASH_FLAG_RDERR: FLASH Read protected error flag (available only in STM32L1XX_MDP devices)
   1719            * @retval The new state of FLASH_FLAG (SET or RESET).
   1720            */
   1721          FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
   1722          {
   1723            FlagStatus bitstatus = RESET;
   1724          
   1725            /* Check the parameters */
   1726            assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));
   1727          
   1728            if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
   1729            {
   1730              bitstatus = SET;
   1731            }
   1732            else
   1733            {
   1734              bitstatus = RESET;
   1735            }
   1736            /* Return the new state of FLASH_FLAG (SET or RESET) */
   1737            return bitstatus; 
   1738          }
   1739          
   1740          /**
   1741            * @brief  Clears the FLASH's pending flags.
   1742            * @param  FLASH_FLAG: specifies the FLASH flags to clear.
   1743            *   This parameter can be any combination of the following values:
   1744            *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag
   1745            *     @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
   1746            *     @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag 
   1747            *     @arg FLASH_FLAG_SIZERR: FLASH size error flag    
   1748            *     @arg FLASH_FLAG_OPTVERR: FLASH Option validity error flag
   1749            *     @arg FLASH_FLAG_OPTVERRUSR: FLASH Option User validity error flag
   1750            *     @arg FLASH_FLAG_RDERR: FLASH Read protected error flag (available only in STM32L1XX_MDP devices)
   1751            * @retval None
   1752            */
   1753          void FLASH_ClearFlag(uint32_t FLASH_FLAG)
   1754          {
   1755            /* Check the parameters */
   1756            assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
   1757            
   1758            /* Clear the flags */
   1759            FLASH->SR = FLASH_FLAG;
   1760          }
   1761          
   1762          /**
   1763            * @brief  Returns the FLASH Status.
   1764            * @param  None
   1765            * @retval FLASH Status: The returned value can be: 
   1766            *   FLASH_BUSY, FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP or FLASH_COMPLETE.
   1767            */
   1768          FLASH_Status FLASH_GetStatus(void)
   1769          {
   1770            FLASH_Status FLASHstatus = FLASH_COMPLETE;
   1771            
   1772            if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
   1773            {
   1774              FLASHstatus = FLASH_BUSY;
   1775            }
   1776            else 
   1777            {  
   1778              if((FLASH->SR & (uint32_t)FLASH_FLAG_WRPERR)!= (uint32_t)0x00)
   1779              { 
   1780                FLASHstatus = FLASH_ERROR_WRP;
   1781              }
   1782              else 
   1783              {
   1784                if((FLASH->SR & (uint32_t)0x1E00) != (uint32_t)0x00)
   1785                {
   1786                  FLASHstatus = FLASH_ERROR_PROGRAM; 
   1787                }
   1788                else
   1789                {
   1790                  FLASHstatus = FLASH_COMPLETE;
   1791                }
   1792              }
   1793            }
   1794            /* Return the FLASH Status */
   1795            return FLASHstatus;
   1796          }
   1797          
   1798          
   1799          /**
   1800            * @brief  Waits for a FLASH operation to complete or a TIMEOUT to occur.
   1801            * @param  Timeout: FLASH programming Timeout.
   1802            * @retval FLASH Status: The returned value can be: FLASH_BUSY, 
   1803            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1804            */
   1805          FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
   1806          { 
   1807            __IO FLASH_Status status = FLASH_COMPLETE;
   1808             
   1809            /* Check for the FLASH Status */
   1810            status = FLASH_GetStatus();
   1811            
   1812            /* Wait for a FLASH operation to complete or a TIMEOUT to occur */
   1813            while((status == FLASH_BUSY) && (Timeout != 0x00))
   1814            {
   1815              status = FLASH_GetStatus();
   1816              Timeout--;
   1817            }
   1818            
   1819            if(Timeout == 0x00 )
   1820            {
   1821              status = FLASH_TIMEOUT;
   1822            }
   1823            /* Return the operation status */
   1824            return status;
   1825          }
   1826          
   1827          /**
   1828            * @}
   1829            */
   1830          
   1831          /**
   1832            * @}
   1833            */
   1834             
   1835            /**
   1836            * @}
   1837            */ 
   1838          
   1839          /**
   1840            * @}
   1841            */ 
   1842          
   1843          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DATA_EEPROM_EraseByte
       8   DATA_EEPROM_EraseHalfWord
       8   DATA_EEPROM_EraseWord
      24   DATA_EEPROM_FastProgramByte
         0   -> FLASH_WaitForLastOperation
        24   -> FLASH_WaitForLastOperation
      32   DATA_EEPROM_FastProgramHalfWord
        32   -> FLASH_WaitForLastOperation
      16   DATA_EEPROM_FastProgramWord
       0   DATA_EEPROM_FixedTimeProgramCmd
       0   DATA_EEPROM_Lock
      24   DATA_EEPROM_ProgramByte
         0   -> FLASH_WaitForLastOperation
        24   -> FLASH_WaitForLastOperation
      32   DATA_EEPROM_ProgramHalfWord
        32   -> FLASH_WaitForLastOperation
      16   DATA_EEPROM_ProgramWord
       0   DATA_EEPROM_Unlock
       0   FLASH_ClearFlag
      16   FLASH_ErasePage
        16   -> FLASH_WaitForLastOperation
      16   FLASH_FastProgramWord
         0   -> FLASH_WaitForLastOperation
        16   -> FLASH_WaitForLastOperation
       0   FLASH_GetFlagStatus
       0   FLASH_GetStatus
       0   FLASH_ITConfig
       0   FLASH_Lock
      12   FLASH_OB_BORConfig
      12   FLASH_OB_BootConfig
       0   FLASH_OB_GetBOR
       0   FLASH_OB_GetRDP
       0   FLASH_OB_GetSPRMOD
       0   FLASH_OB_GetUser
       0   FLASH_OB_GetWRP
       0   FLASH_OB_GetWRP1
       0   FLASH_OB_GetWRP2
       0   FLASH_OB_Launch
       0   FLASH_OB_Lock
      16   FLASH_OB_PCROP1Config
      16   FLASH_OB_PCROPConfig
      12   FLASH_OB_PCROPSelectionConfig
      12   FLASH_OB_RDPConfig
       0   FLASH_OB_Unlock
      12   FLASH_OB_UserConfig
      16   FLASH_OB_WRP1Config
      16   FLASH_OB_WRP2Config
      16   FLASH_OB_WRPConfig
       0   FLASH_PrefetchBufferCmd
       0   FLASH_ReadAccess64Cmd
       0   FLASH_SLEEPPowerDownCmd
       0   FLASH_SetLatency
       0   FLASH_Unlock
       4   FLASH_WaitForLastOperation


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable23
       4  ??DataTable43
       4  ??DataTable43_1
       4  ??DataTable43_10
       4  ??DataTable43_11
       4  ??DataTable43_12
       4  ??DataTable43_2
       4  ??DataTable43_3
       4  ??DataTable43_4
       4  ??DataTable43_5
       4  ??DataTable43_6
       4  ??DataTable43_7
       4  ??DataTable43_8
       4  ??DataTable43_9
     148  DATA_EEPROM_EraseByte
     148  DATA_EEPROM_EraseHalfWord
     148  DATA_EEPROM_EraseWord
     314  DATA_EEPROM_FastProgramByte
     520  DATA_EEPROM_FastProgramHalfWord
     242  DATA_EEPROM_FastProgramWord
      22  DATA_EEPROM_FixedTimeProgramCmd
      14  DATA_EEPROM_Lock
     304  DATA_EEPROM_ProgramByte
     512  DATA_EEPROM_ProgramHalfWord
     234  DATA_EEPROM_ProgramWord
      24  DATA_EEPROM_Unlock
       6  FLASH_ClearFlag
      70  FLASH_ErasePage
      40  FLASH_FastProgramWord
      16  FLASH_GetFlagStatus
      36  FLASH_GetStatus
      18  FLASH_ITConfig
      14  FLASH_Lock
     250  FLASH_OB_BORConfig
     248  FLASH_OB_BootConfig
      12  FLASH_OB_GetBOR
      16  FLASH_OB_GetRDP
      14  FLASH_OB_GetSPRMOD
      10  FLASH_OB_GetUser
       6  FLASH_OB_GetWRP
       6  FLASH_OB_GetWRP1
       6  FLASH_OB_GetWRP2
      12  FLASH_OB_Launch
      12  FLASH_OB_Lock
     292  FLASH_OB_PCROP1Config
     292  FLASH_OB_PCROPConfig
     248  FLASH_OB_PCROPSelectionConfig
     244  FLASH_OB_RDPConfig
      36  FLASH_OB_Unlock
     262  FLASH_OB_UserConfig
     290  FLASH_OB_WRP1Config
     292  FLASH_OB_WRP2Config
     290  FLASH_OB_WRPConfig
      22  FLASH_PrefetchBufferCmd
      22  FLASH_ReadAccess64Cmd
      22  FLASH_SLEEPPowerDownCmd
      16  FLASH_SetLatency
      42  FLASH_Unlock
     112  FLASH_WaitForLastOperation

 
 5 984 bytes in section .text
 
 5 984 bytes of CODE memory

Errors: none
Warnings: none
